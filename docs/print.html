<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>L2 Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="Introducci√≥n.html"><strong aria-hidden="true">1.</strong> Introducci√≥n Parte 1</a></li><li class="chapter-item "><a href="Bases_Criptogr√°ficas.html"><strong aria-hidden="true">2.</strong> Bases Criptogr√°ficas</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Criptograf√≠a_Sim√©trica.html"><strong aria-hidden="true">2.1.</strong> Criptograf√≠a Sim√©trica</a></li><li class="chapter-item "><a href="Criptograf√≠a_Asim√©trica.html"><strong aria-hidden="true">2.2.</strong> Criptograf√≠a Asim√©trica</a></li><li class="chapter-item "><a href="Criptograf√≠a_H√≠bridas.html"><strong aria-hidden="true">2.3.</strong> Criptograf√≠a H√≠bridas</a></li><li class="chapter-item "><a href="Firmas_Digitales.html"><strong aria-hidden="true">2.4.</strong> Firmas Digitales</a></li><li class="chapter-item "><a href="Generador_de_Claves.html"><strong aria-hidden="true">2.5.</strong> Generador de Claves</a></li><li class="chapter-item "><a href="Funciones_Hash.html"><strong aria-hidden="true">2.6.</strong> Funciones Hash</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Merkle_Tree_en_Blockchain.html"><strong aria-hidden="true">2.6.1.</strong> Merkle Tree en Blockchain</a></li><li class="chapter-item "><a href="Patricia_Merkle_Trie.html"><strong aria-hidden="true">2.6.2.</strong> Patricia Merkle Trie</a></li><li class="chapter-item "><a href="Sha256.html"><strong aria-hidden="true">2.6.3.</strong> SHA-256</a></li><li class="chapter-item "><a href="Keccak.html"><strong aria-hidden="true">2.6.4.</strong> Keccak - El nuevo SHA-3</a></li></ol></li><li class="chapter-item "><a href="Quantum_Secure.html"><strong aria-hidden="true">2.7.</strong> Quantum Secure</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Grover.html"><strong aria-hidden="true">2.7.1.</strong> Grover</a></li><li class="chapter-item "><a href="Shor.html"><strong aria-hidden="true">2.7.2.</strong> Shor</a></li><li class="chapter-item "><a href="Lattice.html"><strong aria-hidden="true">2.7.3.</strong> Lattice</a></li><li class="chapter-item "><a href="Kyber_Crystal.html"><strong aria-hidden="true">2.7.4.</strong> Kyber Crystal</a></li><li class="chapter-item "><a href="EOA_AA.html"><strong aria-hidden="true">2.7.5.</strong> EOA y AA - Firmantes</a></li></ol></li><li class="chapter-item "><a href="Starknet_AA.html"><strong aria-hidden="true">2.8.</strong> Starknet AA</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Stark_Curve.html"><strong aria-hidden="true">2.8.1.</strong> EC en Cairo - STARK Curve</a></li><li class="chapter-item "><a href="Secp256r1.html"><strong aria-hidden="true">2.8.2.</strong> MyBraavos Secp256r1</a></li><li class="chapter-item "><a href="Stark_Key.html"><strong aria-hidden="true">2.8.3.</strong> Creaci√≥n de una Stark Key en StarkEx</a></li></ol></li><li class="chapter-item "><a href="Starknet_funciones_hash.html"><strong aria-hidden="true">2.9.</strong> Starknet y Funciones Hash</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Keccak_Starknet.html"><strong aria-hidden="true">2.9.1.</strong> Hash Keccak</a></li><li class="chapter-item "><a href="Pedersen_Starknet.html"><strong aria-hidden="true">2.9.2.</strong> Hash Pedersen</a></li><li class="chapter-item "><a href="Poseidon_Starknet.html"><strong aria-hidden="true">2.9.3.</strong> Hash Poseidon</a></li><li class="chapter-item "><a href="Hashing_Array.html"><strong aria-hidden="true">2.9.4.</strong> Hashing de Array</a></li></ol></li><li class="chapter-item "><a href="Starks.html"><strong aria-hidden="true">2.10.</strong> S-T-ARKs</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Starks_Propiedades.html"><strong aria-hidden="true">2.10.1.</strong> Propiedades de las STARKs</a></li><li class="chapter-item "><a href="Starks_Eficientes.html"><strong aria-hidden="true">2.10.2.</strong> STARKs eficientes</a></li><li class="chapter-item "><a href="Starks_Iops.html"><strong aria-hidden="true">2.10.3.</strong> IOPs</a></li><li class="chapter-item "><a href="Starks_Polinomios.html"><strong aria-hidden="true">2.10.4.</strong> Polinomios</a></li></ol></li><li class="chapter-item "><a href="Starks_Creacion.html"><strong aria-hidden="true">2.11.</strong> Creaci√≥n de un STARK</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Starks_Aritmetizacion.html"><strong aria-hidden="true">2.11.1.</strong> Aritmetizaci√≥n</a></li><li class="chapter-item "><a href="Starks_Traza.html"><strong aria-hidden="true">2.11.2.</strong> Polinomio y Composici√≥n para nuestra Traza</a></li><li class="chapter-item "><a href="Starks_Bajo.html"><strong aria-hidden="true">2.11.3.</strong> Pruebas de Bajo Grado</a></li><li class="chapter-item "><a href="Starks_Fri.html"><strong aria-hidden="true">2.11.4.</strong> FRI</a></li></ol></li><li class="chapter-item "><a href="Cairo.html"><strong aria-hidden="true">2.12.</strong> Leve introducci√≥n a Cairo (AIR)</a></li><li class="chapter-item "><a href="Conclusi√≥n.html"><strong aria-hidden="true">2.13.</strong> Conclusiones</a></li></ol></li><li class="chapter-item "><a href="Introducci√≥n2.html"><strong aria-hidden="true">3.</strong> Introducci√≥n Parte 2 üöß</a></li><li class="chapter-item "><a href="Arquitectura_Starknet.html"><strong aria-hidden="true">4.</strong> Arquitectura Starknet y Cairo üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Componentes.html"><strong aria-hidden="true">4.1.</strong> Componentes üöß</a></li><li class="chapter-item "><a href="Secuenciadores.html"><strong aria-hidden="true">4.2.</strong> Secuenciadores</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Secuenciadores_Rust.html"><strong aria-hidden="true">4.2.1.</strong> Secuenciadores Basados en Rustüöß</a></li><li class="chapter-item "><a href="Madara_Base.html"><strong aria-hidden="true">4.2.2.</strong> Madara - Bases de su arquitectura üöß</a></li></ol></li><li class="chapter-item "><a href="Fullnode.html"><strong aria-hidden="true">4.3.</strong> Full Nodes - Starknet Stack üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Pathfinder.html"><strong aria-hidden="true">4.3.1.</strong> Pathfinder üöß</a></li><li class="chapter-item "><a href="Juno.html"><strong aria-hidden="true">4.3.2.</strong> Juno üöß</a></li><li class="chapter-item "><a href="Deoxys.html"><strong aria-hidden="true">4.3.3.</strong> Deoxys üöß</a></li><li class="chapter-item "><a href="Papyrus.html"><strong aria-hidden="true">4.3.4.</strong> Papyrus üöß</a></li></ol></li><li class="chapter-item "><a href="SHARP.html"><strong aria-hidden="true">4.4.</strong> SHARP üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="SHARP_Recursividad.html"><strong aria-hidden="true">4.4.1.</strong> Recursividad - SHARP</a></li><li class="chapter-item "><a href="SHARP_Componentes.html"><strong aria-hidden="true">4.4.2.</strong> Componentes - SHARP</a></li><li class="chapter-item "><a href="Playground.html"><strong aria-hidden="true">4.4.3.</strong> Playground</a></li><li class="chapter-item "><a href="Cairo_Verifier_Rust.html"><strong aria-hidden="true">4.4.4.</strong> Cairo Verifier - Rust</a></li></ol></li><li class="chapter-item "><a href="Quantum_Leap.html"><strong aria-hidden="true">4.5.</strong> Quantum Leap üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Versiones.html"><strong aria-hidden="true">4.5.1.</strong> Versiones</a></li></ol></li><li class="chapter-item "><a href="Starknet_Stack.html"><strong aria-hidden="true">4.6.</strong> Starknet Stack üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Appchain_Paradex.html"><strong aria-hidden="true">4.6.1.</strong> AppChain Paradex - Starknet Stack</a></li></ol></li><li class="chapter-item "><a href="DA.html"><strong aria-hidden="true">4.7.</strong> Data Avalability üöß</a></li><li class="chapter-item "><a href="EVM_zkEVM.html"><strong aria-hidden="true">4.8.</strong> EVM vs zkEVM üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Kakarot_Base.html"><strong aria-hidden="true">4.8.1.</strong> Kakarot - Bases de su arquitectura üöß</a></li></ol></li><li class="chapter-item "><a href="VM_Cairo.html"><strong aria-hidden="true">4.9.</strong> VM de Cairo üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Sierra.html"><strong aria-hidden="true">4.9.1.</strong> Sierra - IR üöß</a></li><li class="chapter-item "><a href="Cairo_Native.html"><strong aria-hidden="true">4.9.2.</strong> Cairo Native - MLIR üöß</a></li></ol></li><li class="chapter-item "><a href="Storage_Proof.html"><strong aria-hidden="true">4.10.</strong> Herodotus - Storage Proof üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Arquitectura_Herodotus.html"><strong aria-hidden="true">4.10.1.</strong> Arquitectura Herodotus üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Commitments_Inbox.html"><strong aria-hidden="true">4.10.1.1.</strong> Commitments Inbox üöß</a></li><li class="chapter-item "><a href="Headers_Store.md.html"><strong aria-hidden="true">4.10.1.2.</strong> Headers Store üöß</a></li><li class="chapter-item "><a href="Facts_Registry.html"><strong aria-hidden="true">4.10.1.3.</strong> Facts Registry üöß</a></li></ol></li><li class="chapter-item "><a href="Herodotus_Turbo.html"><strong aria-hidden="true">4.10.2.</strong> Herodotus Turbo üöß</a></li><li class="chapter-item "><a href="Casos_de_uso.html"><strong aria-hidden="true">4.10.3.</strong> Casos de Usos üöß</a></li><li class="chapter-item "><a href="Ejemplos_Storage_Proof.html"><strong aria-hidden="true">4.10.4.</strong> Ejemplos Storage Proof üöß</a></li><li class="chapter-item "><a href="Proyectos_Storage_Proof.html"><strong aria-hidden="true">4.10.5.</strong> Proyectos SHH y Hackaton üöß</a></li><li class="chapter-item "><a href="Merkle_Mountain_Ranges.html"><strong aria-hidden="true">4.10.6.</strong> Merkle Mountain Ranges en Cairo üöß</a></li><li class="chapter-item "><a href="Storage_Proof_Oracle.html"><strong aria-hidden="true">4.10.7.</strong> Storage Proof Vs Oracle üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Estado_Oracle_Starknet.html"><strong aria-hidden="true">4.10.7.1.</strong> Estado de Oracles en Starknet üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Pragma.html"><strong aria-hidden="true">4.10.7.1.1.</strong> Pragma - Bases üöß</a></li><li class="chapter-item "><a href="Chainlink.html"><strong aria-hidden="true">4.10.7.1.2.</strong> Chainlink - Bases üöß</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><a href="Arquitectura_Cairo.html"><strong aria-hidden="true">4.11.</strong> Cairo - Arquitectura üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Cairov2.html"><strong aria-hidden="true">4.11.1.</strong> Cairo v2 - Nueva versi√≥n del Compilador üöß</a></li><li class="chapter-item "><a href="Sintaxis_Basica.html"><strong aria-hidden="true">4.11.2.</strong> Sint√°xis B√°sica üöß</a></li></ol></li><li class="chapter-item "><a href="Node_Guardians.html"><strong aria-hidden="true">4.12.</strong> Node Guardians - Cairo Educacional üöß</a></li></ol></li><li class="chapter-item "><a href="Introducci√≥n3.html"><strong aria-hidden="true">5.</strong> Introducci√≥n Parte 3 üöß</a></li><li class="chapter-item "><a href="Otras_Arquitecturas.html"><strong aria-hidden="true">6.</strong> Otras Arquitecturas üöß</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">L2 Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introducci√≥n"><a class="header" href="#introducci√≥n">Introducci√≥n</a></h1>
<p>¬°Hola comunidad! üëã</p>
<p>Antes que nada nos gustar√≠a expresar nuestro m√°s sincero agradecimiento a todos aquellos que han contribuido y hecho posible la realizaci√≥n de esta exhaustiva investigaci√≥n y documento sobre criptograf√≠a y como se adaptan en StarkWare. Especial reconocimiento a los expertos que han colaborado en su creaci√≥n y a <a href="https://twitter.com/0xhasher_">Carlos</a> que ha brindado sus valiosas correcciones y orientaci√≥n en numerosos aspectos del trabajo. Sus experiencias y conocimientos han sido fundamentales para alcanzar los resultados y conclusiones presentados en este informe.</p>
<p>En esta ocasi√≥n, estamos emocionados de presentar una serie de art√≠culos profundos sobre el desarrollo detr√°s de Starkware. Recomendamos a los lectores que previamente hayan le√≠do otros documentos y tengan conocimientos t√©cnicos para una mejor comprensi√≥n, para este documento en concreto recomendamos:</p>
<p><a href="https://starkware.co/resource/stark-endgame/">Stark END-Game</a> | <a href="https://starkware.co/resource/stark-endgame/">Recursive Stark</a> |  <a href="https://starkware.co/resource/account-abstraction-improving-security-and-user-experience-for-mainstream-crypto-adoption/">Account Abstraction</a> | <a href="https://starkware.co/stark-math-a-very-short-primer/">Intro Maths Starks</a></p>
<p>El panorama actual es complejo, pero nos enorgullece contar con las mentes m√°s brillantes trabajando en el ecosistema, una STARK que los une a todos.</p>
<p>¬øEres o ser√°s uno de ellos? Antes de sumergirnos, exploraremos una serie de conceptos para establecer bases e historias sobre criptograf√≠a, lo que nos permitir√° adentrarnos a√∫n m√°s en el ecosistema STARKs. ¬°Comencemos!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bases-criptogr√°ficas"><a class="header" href="#bases-criptogr√°ficas">Bases Criptogr√°ficas</a></h1>
<p>La <a href="https://en.wikipedia.org/wiki/Cryptography"><strong>criptograf√≠a</strong></a> es el campo de estudio y desarrollo de t√©cnicas y algoritmos para asegurar la confidencialidad, integridad y autenticidad de la informaci√≥n. Utilizando claves secretas o p√∫blicas, <strong>la criptograf√≠a transforma los datos en un formato incomprensible para terceros no autorizados</strong>, garantizando que solo los destinatarios leg√≠timos puedan acceder a la informaci√≥n original. La criptograf√≠a desempe√±a un papel vital en la seguridad de las comunicaciones y el almacenamiento de datos, protegiendo la privacidad y la confianza en diversos √°mbitos de la vida moderna.</p>
<ul>
<li>
<p><strong>Encryption:</strong> <a href="https://en.wikipedia.org/wiki/Encryption">el cifrado</a> es el proceso de convertir informaci√≥n legible en un formato ilegible llamado texto cifrado, mediante el uso de algoritmos y una clave. El objetivo principal del cifrado es proteger la confidencialidad de los datos, asegurando que solo las personas autorizadas puedan acceder y comprender la informaci√≥n cifrada. Para ello, se aplica una serie de transformaciones matem√°ticas al texto original, lo que dificulta su interpretaci√≥n sin la clave correspondiente.</p>
</li>
<li>
<p><strong>Cryptographic protocol:</strong> <a href="https://en.wikipedia.org/wiki/Cryptographic_protocol">un protocolo criptogr√°fico</a> o protocolo de seguridad (tambi√©n llamado protocolo de cifrado) es un protocolo abstracto o concreto que realiza funciones relacionadas con la seguridad, aplicando m√©todos criptogr√°ficos.‚Äã Un protocolo describe la forma en que un algoritmo debe usarse.</p>
</li>
<li>
<p><strong>Algorithm:</strong> <a href="https://es.wikipedia.org/wiki/Algoritmo">un algoritmo</a> de cifrado es un procedimiento que convierte un mensaje de texto plano en un texto cifrado. Los algoritmos modernos utilizan matem√°ticas avanzadas y una o varias claves de cifrado. Esto hace que sea relativamente f√°cil cifrar un mensaje, pero pr√°cticamente imposible descifrarlo sin conocer las claves requeridas.</p>
</li>
</ul>
<h2 id="esquema-de-cifrado"><a class="header" href="#esquema-de-cifrado">Esquema de cifrado</a></h2>
<p>Estos esquemas definen c√≥mo se realiza la transformaci√≥n de los datos originales en texto cifrado y c√≥mo se realiza la operaci√≥n inversa para recuperar los datos originales a partir del texto cifrado. Un esquema de cifrado generalmente consta de los siguientes elementos:</p>
<ul>
<li>
<p><strong>Encryption Algorithm:</strong> vimos que es el conjunto de operaciones matem√°ticas utilizadas para cifrar los datos en texto cifrado.</p>
</li>
<li>
<p><strong>Decryption Algorithm:</strong> es el conjunto de operaciones matem√°ticas inversas utilizadas para descifrar el texto cifrado y recuperar los datos originales.</p>
</li>
<li>
<p><strong>Key:</strong> conocida como clave, es un valor secreto que se utiliza como entrada para el algoritmo de cifrado. La key determina c√≥mo se realiza la transformaci√≥n de los datos y es esencial para descifrar el texto cifrado.</p>
</li>
<li>
<p><strong>Protocols:</strong> establecen c√≥mo se utiliza el esquema de cifrado, incluyendo la generaci√≥n y distribuci√≥n segura de claves, el manejo de errores y la gesti√≥n de la seguridad.</p>
</li>
</ul>
<p>Existen varios tipos de esquemas de cifrado:</p>
<ol>
<li>
<p>El <a href="https://academy.bit2me.com/que-es-criptografia-simetrica/"><strong>cifrado sim√©trico</strong></a> (donde se utiliza una sola clave tanto para cifrar como para descifrar),</p>
</li>
<li>
<p>El <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_asim%C3%A9trica"><strong>cifrado asim√©trico</strong></a> o de clave p√∫blica (donde se utilizan pares de claves p√∫blica y privada)</p>
</li>
<li>
<p>Otras variantes de esquemas de cifrados como de <a href="https://es.wikipedia.org/wiki/Cifrador_de_flujo">flujo</a> y de <a href="https://es.wikipedia.org/wiki/Cifrado_por_bloques">bloque</a>. Cada esquema tiene sus propias caracter√≠sticas y se utiliza en diferentes contextos seg√∫n los requisitos de seguridad y las necesidades espec√≠ficas de la aplicaci√≥n, pero nos centraremos en las principales para entender su funcionamiento antes de pasar a la evoluci√≥n de las STARKs.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="criptograf√≠a-sim√©trica"><a class="header" href="#criptograf√≠a-sim√©trica">Criptograf√≠a Sim√©trica</a></h2>
<p>La historia de la criptograf√≠a sim√©trica se remonta a tiempos antiguos, pero su uso moderno se consolid√≥ en el siglo XX con el desarrollo de m√©todos m√°s sofisticados. Un ejemplo ic√≥nico es la <a href="https://en.wikipedia.org/wiki/Enigma_machine">m√°quina Enigma</a>, utilizada por los alemanes durante la Segunda Guerra Mundial para cifrar y descifrar mensajes, esta m√°quina demostr√≥ la eficacia de la criptograf√≠a sim√©trica en entornos militares.</p>
<p>Podemos ver la criptograf√≠a sim√©trica como una antigua y confiable llave maestra en el mundo de la seguridad inform√°tica. Es una t√©cnica que ha sido utilizada desde hace mucho tiempo y a√∫n en la actualidad sigue siendo efectiva y segura para proteger informaci√≥n en diversas situaciones.</p>
<p>Imag√≠nate una llave que puede tanto cerrar como abrir una puerta. Los algoritmos criptogr√°ficos de clave sim√©trica funcionan de manera similar, utilizan la misma clave para cifrar el texto original y descifrar el texto cifrado, esta clave compartida es como el secreto que solo t√∫ y los destinatarios autorizados conocen.</p>
<p><img src="./assets/simetrico.gif" alt="graph" /></p>
<div align="center">
<em>Criptograf√≠a Sim√©trica - √önica Key</em>
</div>
<p>Sin embargo, a medida que la tecnolog√≠a avanzaba y las capacidades de c√≥mputo aumentaban, se hizo evidente que era necesario fortalecer los sistemas de cifrado. Surgieron nuevos desaf√≠os y amenazas que requer√≠an niveles m√°s altos de seguridad. Es por eso que se desarrollaron otros m√©todos criptogr√°ficos, como la criptograf√≠a asim√©trica, que utiliza pares de claves diferentes para el cifrado y el descifrado.</p>
<p>Aunque la criptograf√≠a sim√©trica ha evolucionado con el tiempo, todav√≠a se utiliza ampliamente en muchos sistemas y aplicaciones. Su simplicidad y eficiencia la convierten en una opci√≥n popular para proteger datos en redes privadas, sistemas de comunicaci√≥n y almacenamiento de informaci√≥n sensible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="criptograf√≠a-asim√©trica"><a class="header" href="#criptograf√≠a-asim√©trica">Criptograf√≠a Asim√©trica</a></h1>
<p>El concepto de algoritmos criptogr√°ficos de clave asim√©trica, fue un enfoque revolucionario que introdujo un concepto completamente diferente, <strong>el uso de un par de claves complementarias, una p√∫blica y una privada</strong>, para asegurar la confidencialidad de los datos. Cada clave del par ten√≠a una funci√≥n espec√≠fica:</p>
<ul>
<li><strong>Public key</strong>: esta clave p√∫blica se compart√≠a abiertamente y se utilizaba para cifrar la informaci√≥n.</li>
<li><strong>Private key:</strong> esta clave privada se guardaba cuidadosamente y se utilizaba para descifrarla.</li>
</ul>
<p>Con la criptograf√≠a de clave p√∫blica, los mensajes cifrados pod√≠an ser transmitidos a trav√©s de redes inseguras sin el temor de que fueran interceptados y descifrados por personas no autorizadas, pero en este caso diferenci√°ndose de la sim√©trica en que estos mensajes requer√≠an un Private key y una Public key. Era como si se hubiera descubierto una nueva forma de comunicaci√≥n secreta y segura en el mundo digital, fue un avance revolucionario en el campo de la criptograf√≠a.</p>
<p><img src="./assets/asimetrico.gif" alt="graph" /></p>
<div align="center">
<em>Criptograf√≠a Asim√©trica - Creaci√≥n de PK y PB</em>
</div>
<p>Algunos de los m√°s destacados y utilizados son los siguiente:</p>
<ul>
<li>
<p><strong>RSA -</strong> <a href="https://es.wikipedia.org/wiki/RSA"><strong>Rivest-Shamir-Adleman:</strong></a> es un sistema criptogr√°fico asim√©trico de clave p√∫blica desarrollado en 1979. Su seguridad radica en el problema de la factorizaci√≥n de n√∫meros enteros y se utiliza en diversos √°mbitos de la transmisi√≥n de datos en Internet debido a su facilidad de uso. Este sistema consta de una clave p√∫blica RSA y una clave privada RSA.</p>
</li>
<li>
<p><strong>ECC -</strong> <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_de_curva_el%C3%ADptica"><strong>Elliptic Curve Cryptography:</strong></a> en la d√©cada de 1980 se desarroll√≥ este enfoque de curva el√≠ptica criptogr√°fica, una variante de la criptograf√≠a asim√©trica o de clave p√∫blica basada en las matem√°ticas de las curvas el√≠pticas que proporciona niveles de seguridad similares o superiores a RSA pero con claves m√°s cortas.</p>
</li>
<li>
<p><strong>ECDSA -</strong> <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf"><strong>Elliptic Curve Digital Signature Algorithm:</strong></a> en los A√±os 1990 naci√≥ ECDSA, un algoritmo de firma digital y autenticaci√≥n en criptograf√≠a asim√©trica, basado en curvas el√≠pticas. Se utiliza en criptograf√≠a para garantizar la autenticidad, integridad de los datos. ECDSA se basa en la dificultad computacional de resolver el problema del logaritmo discreto en curvas el√≠pticas.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="criptograf√≠a-h√≠brida"><a class="header" href="#criptograf√≠a-h√≠brida">Criptograf√≠a H√≠brida</a></h1>
<p>El <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_h%C3%ADbrida"><strong>cifrado h√≠brido</strong></a> utiliza las propiedades √∫nicas de la criptograf√≠a de clave p√∫blica para intercambiar informaci√≥n secreta a trav√©s de un canal no confiable, combinando la eficacia del cifrado sim√©trico. Esto proporciona una soluci√≥n pr√°ctica de extremo a extremo para garantizar la privacidad de los datos.</p>
<p>Aunque los algoritmos de clave p√∫blica, como RSA-OAEP, son menos eficientes que los algoritmos sim√©tricos, generalmente no se utilizan directamente para cifrar los datos. Sin embargo, desempe√±an un papel importante en el ecosistema criptogr√°fico al permitir el intercambio seguro de claves.</p>
<p>Para utilizar el cifrado sim√©trico, las partes deben compartir una clave. Si ya existe un canal seguro, se puede enviar la clave a trav√©s de √©l. Sin embargo, si no hay un canal seguro disponible, se resuelve el problema del intercambio de claves utilizando la criptograf√≠a de clave p√∫blica.</p>
<ul>
<li><strong>DH -</strong> <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"><strong>Diffie‚ÄìHellman:</strong></a> el intercambio de claves DH es un algoritmo criptogr√°fico de clave p√∫blica dise√±ado espec√≠ficamente para acordar una clave sim√©trica en ausencia de un canal seguro.
La combinaci√≥n de criptograf√≠a de clave p√∫blica para el intercambio de claves y el cifrado sim√©trico para el cifrado de datos en masa se conoce como cifrado h√≠brido.</li>
</ul>
<p>El cifrado h√≠brido se utiliza ampliamente en los protocolos de transferencia de datos para la web, como en la capa de seguridad de transporte <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">(TLS)</a>. Cuando te conectas a un sitio web que utiliza <a href="https://en.wikipedia.org/wiki/HTTPS">HTTPS</a> (HTTP seguro con TLS), tu navegador negocia los algoritmos criptogr√°ficos que aseguran la conexi√≥n. Estos algoritmos incluyen m√©todos para el intercambio de claves, cifrado sim√©trico y firmas digitales.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="firmas-digitales"><a class="header" href="#firmas-digitales">Firmas digitales</a></h1>
<p>Los esquemas de firma digital son un tipo de criptograf√≠a de clave p√∫blica que garantiza la integridad, autenticidad y no repudio de los datos.</p>
<p>Es importante destacar que el esquema de firma digital puede variar dependiendo del algoritmo utilizado, ECDSA, es un ejemplo com√∫n de esquema de firma basado en criptograf√≠a de curva el√≠ptica. Aqu√≠ EC recordemos que representa la curva el√≠ptica utilizada y <a href="https://en.wikipedia.org/wiki/Digital_Signature_Algorithm"><strong>DSA</strong></a> (una variante de los esquemas de firma <a href="https://en.wikipedia.org/wiki/Schnorr_signature">Schnorr</a> y <a href="https://en.wikipedia.org/wiki/ElGamal_signature_scheme">ElGamal</a>) el algoritmo de firma digital. Cada esquema tiene sus propias caracter√≠sticas y propiedades de seguridad, y se selecciona seg√∫n los requisitos y consideraciones espec√≠ficas de la aplicaci√≥n.</p>
<p>Cuando se trata de firmas digitales, los pasos generales suelen ser los siguientes:</p>
<ul>
<li>
<p><strong>Key generation:</strong> el Generador de Claves es un protocolo o algoritmo que genera <strong>un Keypar</strong>, un par de claves asim√©tricas como se explic√≥ anteriormente compuestas por una public key y una private key. En el caso de la criptograf√≠a de curva el√≠ptica (como ECDSA), se generan los par√°metros necesarios para definir la curva y se elige una clave privada aleatoria. A partir de la clave privada, se calcula la clave p√∫blica correspondiente utilizando operaciones matem√°ticas espec√≠ficas.</p>
</li>
<li>
<p><strong>Hash del mensaje:</strong> antes de firmar el mensaje, se aplica una funci√≥n hash criptogr√°fica al contenido del mensaje. Esto reduce el mensaje a un valor de longitud fija llamado resumen o hash. El objetivo es garantizar la integridad y eficiencia del proceso de firma, ya que es m√°s r√°pido firmar y verificar un resumen m√°s corto que el mensaje completo.</p>
</li>
<li>
<p><strong>Digital Signature:</strong> este proceso tiene el prop√≥sito de realizar una serie de operaciones matem√°ticas utilizando la clave privada y el hash del mensaje para generar la firma digital.</p>
</li>
<li>
<p><strong>Verify Signature:</strong> para verificar la autenticidad de la firma, se necesita la clave p√∫blica del firmante. Se aplica nuevamente la funci√≥n hash al mensaje original y se utiliza la clave p√∫blica junto con la firma para realizar operaciones matem√°ticas espec√≠ficas. Si el resultado coincide con la firma original, se considera que la firma es v√°lida y se confirma la autenticidad del mensaje y del firmante.</p>
</li>
</ul>
<p>El proceso de firma puede considerarse como el cifrado del archivo mediante la clave privada. Para ello, la persona que firma utiliza su clave privada para producir una firma.</p>
<p>Exploraremos a continuaci√≥n la relevancia de los diversos esquemas de firmas para garantizar la seguridad de nuestros datos, as√≠ como la forma en que Starknet usa AA para abstraer la firma de la validaci√≥n. En este contexto, se pueden dise√±ar diferentes esquemas o configuraciones, como el <code>secp256r1</code>, una variante de STARK Curve, la versi√≥n amigable de ECDSA optimizada en Starknet. Este esquema de firma se puede utilizar para incorporar firmas en dispositivos modernos de manera biom√©trica, aislada y abstra√≠da por naturaleza, lo que mejora significativamente la eficiencia, tal como se discutir√° en detalle m√°s adelante.</p>
<p>Por lo tanto, resulta crucial abordar el siguiente apartado relacionado con el uso de Key generation que desempe√±an un papel fundamental en este contexto.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-generator"><a class="header" href="#key-generator">Key generator</a></h1>
<p>Tenemos que entender c√≥mo el generador de claves <a href="https://en.wikipedia.org/wiki/Key_generator"><strong>(Key generator)</strong></a> genera el Keypair, para lograrlo, es necesario trabajar con valores pseudoaleatorios que se utilizan en la generaci√≥n de la private key. Un Key generator se puede implementar en un sistema con el prop√≥sito de generar y autenticar claves.</p>
<p>Key generator puede implementarse en cualquier sistema criptogr√°fico que utilice la curva el√≠ptica, como es el caso de <code>secp256k1</code> (una curva optimizada basada en las propiedades matem√°ticas de las curvas el√≠pticas para proporcionar un esquema de firma digital seguro y eficiente), como Bitcoin y Ethereum.</p>
<p>Este generador de claves garantiza que, con alta probabilidad, las claves privadas generadas sean √∫nicas y seguras, lo que a su vez respalda la integridad y autenticidad de las transacciones realizadas en la red.</p>
<h2 id="generadores-de-n√∫meros-pseudoaleatorios"><a class="header" href="#generadores-de-n√∫meros-pseudoaleatorios">Generadores de n√∫meros pseudoaleatorios</a></h2>
<p>Para garantizar la seguridad usando la pseudoaleatoriedad estad√≠stica de un <strong>PRNG -</strong> <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator"><strong>Pseudorandom number generator</strong></a>, es crucial contar con una semilla inicial. Si la semilla es f√°cilmente predecible, generar√° valores predecibles de n√∫meros y todo el proceso ser√° inseguro.</p>
<p>Para lograr una inicializaci√≥n segura del generador pseudoaleatorio, es necesario recolectar <a href="https://en.wikipedia.org/wiki/Entropy_(computing)"><strong>Entrop√≠a</strong></a>, que representa la aleatoriedad necesaria en el proceso.</p>
<h2 id="entrop√≠a"><a class="header" href="#entrop√≠a">Entrop√≠a</a></h2>
<p>La entrop√≠a o aleatoriedad impredecible en computaci√≥n, generalmente se mide en bits. Tenemos varios ejemplos para entender el concepto y grado de aleatoriedad. Si mueve el mouse de su computadora, generar√° algunos eventos dif√≠ciles de predecir, como la ubicaci√≥n de inicio y la ubicaci√≥n final del cursor del mouse.</p>
<blockquote>
<p>Si suponemos que el mouse ha cambiado su posici√≥n en el rango de <code>[ 0 ... 255 p√≠xeles ]</code>, la entrop√≠a recolectada de este movimiento del mouse debe ser de aproximadamente <strong>8 bits</strong>, porque <code>2‚Å∏ = 255</code></p>
</blockquote>
<blockquote>
<p>Si se le pide al usuario que piense en un n√∫mero en el rango <code>[ 0 ... 1000 ]</code>, este n√∫mero tendr√° alrededor de <strong>9-10 bits</strong> de entrop√≠a porque, <code>2¬π‚Å∞ = 1024</code></p>
</blockquote>
<p>Para recolectar 256 bits de entrop√≠a, es decir, para generar de forma segura un n√∫mero entero de 256 bits, deber√° tener en cuenta una secuencia de varios eventos similares (como movimientos del mouse e interracidades del teclado del usuario).</p>
<p>Aqu√≠ la importancia de d√≥nde y c√≥mo hemos generado nuestras claves privadas y p√∫blicas y las posibles vulnerabilidades en algunos malos usos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funciones-hash-y-funciones-hash-criptogr√°ficas"><a class="header" href="#funciones-hash-y-funciones-hash-criptogr√°ficas">Funciones hash y funciones hash criptogr√°ficas</a></h1>
<p>Este cap√≠tulo es de suma importancia para comprender el funcionamiento de las funciones hash. A diferencia de los esquemas de cifrado o las firmas, las funciones hash no requieren de una clave. Cualquier persona puede calcular el hash de una entrada determinada, y la funci√≥n hash siempre producir√° la misma salida para la misma entrada.</p>
<p>As√≠ que podemos definir una <a href="https://en.wikipedia.org/wiki/Hash_function"><strong>funci√≥n hash</strong></a> como un algoritmo que toma una entrada, como un mensaje o un archivo, y produce una salida de longitud fija llamada hash o resumen. Esta salida es √∫nica para cada entrada espec√≠fica, lo que permite la verificaci√≥n de la integridad de los datos y garantiza que cualquier cambio en la entrada resultar√° en un hash completamente diferente.</p>
<p>Una <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function"><strong>funci√≥n hash criptogr√°fica</strong></a>, por otro lado, es aquella funci√≥n hash que se utiliza en el √°mbito de la criptograf√≠a, para evaluar la seguridad de una funci√≥n de hash criptogr√°fica, se consideran las siguientes propiedades:</p>
<ul>
<li><strong>Resistencia a la preimagen:</strong> partiendo de un valor <code>hash h</code>, es dif√≠cil encontrar un mensaje <code>m</code> que genere ese <code>hash</code>, es decir, <code>h = hash(m)</code>, este concepto est√° relacionado con el de una funci√≥n de sentido √∫nico. Las funciones que carecen de esta propiedad son vulnerables a ataques de preimagen.</li>
<li><strong>Resistencia a la segunda preimagen:</strong> dado un mensaje <code>m‚ÇÅ</code>, es dif√≠cil encontrar otro mensaje <code>m‚ÇÇ</code> distinto a <code>m‚ÇÅ</code> que produzca el mismo valor de hash, es decir, <code>hash(m‚ÇÅ) = hash(m‚ÇÇ)</code>. Esta propiedad tambi√©n se conoce como resistencia d√©bil a colisiones. Las funciones que no cumplen esta propiedad son vulnerables a ataques de segunda preimagen.</li>
<li><strong>Resistencia a colisiones:</strong> es dif√≠cil encontrar dos mensajes diferentes <code>m‚ÇÅ</code> y <code>m‚ÇÇ</code> que produzcan el mismo valor de hash, es decir, <code>hash(m‚ÇÅ) = hash(m‚ÇÇ)</code>. Estas colisiones son conocidas como colisiones criptogr√°ficas de hash. Esta propiedad tambi√©n se conoce como resistencia fuerte a colisiones. Se requiere que el tama√±o del hash sea al menos el doble de largo para garantizar la resistencia a la preimagen.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merkle-tree-en-blockchain"><a class="header" href="#merkle-tree-en-blockchain">Merkle Tree en Blockchain</a></h1>
<p>Ahora que hemos comprendido mejor qu√© es un hash, veamos c√≥mo en criptograf√≠a y <a href="https://en.wikipedia.org/wiki/Computer_science">ciencias de la computaci√≥n</a>, un √°rbol hash, tambi√©n conocido c√≥mo <a href="https://en.wikipedia.org/wiki/Merkle_tree"><strong>Merkle Tree o binary Merkle tree</strong></a>, es una <a href="https://en.wikipedia.org/wiki/Data_structure">estructura de datos</a> utilizada para garantizar la integridad de los contenidos almacenados en un sistema, como la tecnolog√≠a blockchain.</p>
<p>Podemos ver los Merkle Trees como una estructura de √°rbol en la que cada &quot;hoja&quot; o nodo terminal, est√° etiquetado con el hash criptogr√°fico de un bloque de datos. A su vez, cada nodo que no es una hoja, tambi√©n conocido como rama, nodo interior o inodo, est√° etiquetado con el hash criptogr√°fico de las etiquetas de sus nodos secundarios.</p>
<p>La construcci√≥n de un Merkle Tree implica dividir los datos en bloques m√°s peque√±os y aplicar una funci√≥n de hash criptogr√°fico a cada uno de ellos. Luego, los bloques hash se combinan en pares y se vuelven a hashear, repitiendo este proceso hasta obtener un √∫nico hash llamado ra√≠z de Merkle o ‚ÄúMerkle root‚Äù. Esta ra√≠z se coloca en la cabecera de un bloque o transacci√≥n y se utiliza como una firma digital que representa y verifica la integridad de todos los datos incluidos en el bloque.</p>
<p><img src="./assets/merkle.gif" alt="graph" /></p>
<div align="center">
<em>Ejemplo de estructura de un Merkle Tree</em>
</div>
<p>Una de las principales ventajas de los Merkle Trees es su capacidad para proporcionar una verificaci√≥n eficiente y segura de los contenidos de una gran estructura de datos. Como cada nodo intermedio en el √°rbol est√° etiquetado con el hash criptogr√°fico de las etiquetas de sus nodos secundarios, cualquier cambio realizado en los datos se reflejar√° en cambios en los hashes correspondientes.</p>
<p>En la tecnolog√≠a blockchain que usan los Merkle Trees, los utilizan para garantizar la integridad de los datos almacenados en cada bloque de la cadena. Cada bloque contiene una lista de transacciones, y el Merkle Tree se construye utilizando los hashes de estas transacciones.</p>
<p>Cuando se agrega un nuevo bloque a la cadena, la ra√≠z de Merkle del bloque anterior se incluye en el nuevo bloque, creando una cadena enlazada de √°rboles de Merkle. Esto permite verificar r√°pidamente la integridad de cualquier bloque en la cadena sin necesidad de verificar todos los datos desde el inicio. Adem√°s, si alg√∫n dato se modifica en un bloque, el hash del bloque cambiar√°, lo que afectar√° la ra√≠z de Merkle y se√±alar√° la alteraci√≥n en la cadena.</p>
<p>Algunos casos posibles de uso de los binary Merkle Trees para los diferentes esquemas pueden ser:</p>
<ul>
<li><strong>Los binary Merkle Trees:</strong> son estructuras de datos muy eficientes para autenticar informaci√≥n que se presenta en formato de &quot;lista&quot;, es decir, una secuencia de elementos consecutivos.</li>
<li><strong>Los transaction trees:</strong> tambi√©n resultan beneficiosos, ya que una vez creado el √°rbol, no importa cu√°nto tiempo se tarde en editarlo, ya que permanecer√° inmutable.</li>
<li><strong>Los State trees:</strong> sin embargo, cuando se trata de un √°rbol que almacena estados la situaci√≥n se vuelve m√°s compleja, el estado en Ethereum, que consiste en un mapa de valores clave donde:
<ul>
<li><strong>Las claves son direcciones</strong></li>
<li><strong>Los valores son las declaraciones de cuenta que incluyen:</strong> saldo, nonce, c√≥digo y almacenamiento asociados a cada cuenta, r</li>
<li><strong>Requiere la construcci√≥n de una prueba de transici√≥n de estado de Merkle</strong> <a href="https://medium.com/@chiqing/verify-ethereum-account-balance-with-state-proof-83b51ceb15cf">(Merkle state transition proof)</a></li>
</ul>
</li>
</ul>
<p>As√≠ que, comprender el funcionamiento de los State Trees y su optimizaci√≥n de datos es crucial en el contexto actual donde los datos y los hashes desempe√±an un papel fundamental. En el caso de Ethereum, uno de los principales actores en el √°mbito de los State Trees, se han incorporado modificaciones interesantes usando Patricia Merkle Trie.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patricia-merkle-trie"><a class="header" href="#patricia-merkle-trie">Patricia Merkle Trie</a></h1>
<p>La especificaci√≥n de Ethereum define el <a href="https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/"><strong>Modified Merkle Patricia Trie</strong></a> (tambi√©n conocido como MPT) este m√©todo se utiliza para guardar estados. B√°sicamente, el MPT es una combinaci√≥n del Patricia trie y el Merkle tree, con algunas optimizaciones adicionales adaptadas a las caracter√≠sticas de Ethereum.</p>
<p>Patricia trie, <a href="https://en.wikipedia.org/wiki/Radix_tree">(Radix tree o Radix trie)</a>, √°rbol de prefijos compacto <strong>(compact prefix tree)</strong> o √°rbol de prefijos comprimido <strong>(compressed trie)</strong>, es una sofisticada estructura de datos que ofrece una optimizaci√≥n espacial en la representaci√≥n de [Tries] (√°rboles de prefijos). Una de las caracter√≠sticas clave de este tipo de √°rbol es la fusi√≥n de nodos cuando un nodo es hijo √∫nico de su padre, lo que contribuye a una mayor eficiencia y rendimiento.</p>
<p>Esta estructura es un tipo de <strong>√°rbol de b√∫squeda k-ary</strong>, siendo un <a href="https://en.wikipedia.org/wiki/M-ary_tree">m-ary tree</a> (tambi√©n conocido como <code>n-ary tree</code>, <code>k-ary tree</code> o <code>k-way tree</code>) un √°rbol ra√≠z en el cual cada nodo tiene como m√°ximo m hijos. Ambas estructuras de datos se utilizan para localizar claves espec√≠ficas dentro de un conjunto.</p>
<p>Estos √°rboles son completamente deterministas, lo que significa que aquellos con las mismas asociaciones de (clave, valor) est√°n garantizados de ser id√©nticos, hasta el √∫ltimo byte. Esto asegura que tengan el mismo hash ra√≠z, lo que proporciona la deseada eficiencia de <code>O(log(n))</code> para inserciones, b√∫squedas y eliminaciones. Adem√°s, son m√°s f√°ciles de entender y programar que alternativas m√°s complejas basadas en comparaciones, como los <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">red-black tree.</a></p>
<p>El Patricia Merkle Trie combina la estructura de un √°rbol de b√∫squeda binario con la estructura de √°rbol de Merkle, lo cual permite verificar eficientemente la integridad de los datos y proporciona una representaci√≥n compacta del estado completo de la cadena.</p>
<p>El uso del Patricia Merkle Trie en Ethereum ofrece ventajas significativas en t√©rminos de eficiencia y escalabilidad. Permite realizar consultas r√°pidas sobre el estado de las cuentas y los contratos, evitando la necesidad de recorrer todo el estado completo. En cambio, solo es necesario verificar y acceder a los nodos relevantes en el √°rbol, lo que ahorra tiempo y recursos.</p>
<p>Adem√°s, esta estructura de √°rbol facilita la implementaci√≥n de funciones de snapshot y revert en Ethereum. Estas funciones permiten crear instant√°neas del estado del sistema en momentos espec√≠ficos y revertir cambios en caso de errores o ataques, brindando una capa adicional de seguridad y confiabilidad a la red blockchain.</p>
<p><img src="" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>La comprensi√≥n de los Merkle Trees y el MPT resulta especialmente relevante al explorar otras estructuras de datos criptogr√°ficas, como las Merkle Mountain Ranges (MMRs) en Herodotus para las Storage Proof. Las MMRs pueden considerarse una lista de √Årboles de Merkle, donde cada √°rbol se representa como una monta√±a y la lista completa forma el rango. La utilizaci√≥n de funciones hash espec√≠ficas y sus caracter√≠sticas de seguridad se explorar√°n para comprender c√≥mo crear estos √°rboles de manera eficiente y √≥ptima.</p>
<p>Por lo tanto, es crucial comprender a fondo las diferentes funciones hash y sus propiedades para tomar decisiones informadas sobre la selecci√≥n y optimizaci√≥n de las mismas en la construcci√≥n de estructuras de datos criptogr√°ficas m√°s eficientes y seguras en los √Årboles de Merkle.</p>
<p>Las funciones hash desempe√±an un papel fundamental en garantizar la integridad y la seguridad de los datos almacenados en los √°rboles de Merkle, ya que se utilizan para calcular los hashes de los nodos y verificar su integridad durante la construcci√≥n y la verificaci√≥n del √°rbol.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sha-256"><a class="header" href="#sha-256">SHA-256</a></h1>
<p>En este cap√≠tulo aprenderemos algunos ejemplos de funciones hash criptogr√°ficas ampliamente utilizadas, un ejemplo es <code>SHA-256</code> <a href="https://es.wikipedia.org/wiki/SHA-2"><strong>(Secure Hash Algorithm 256-bit)</strong></a>, <strong>que es una funci√≥n de hash criptogr√°fica perteneciente a la familia de algoritmos SHA-2.</strong> Esta funci√≥n acepta una entrada de cualquier longitud y genera una salida de 256 bits que se considera √∫nica y asociada de forma irreversible a dicha entrada.</p>
<p>Pueden probar la generaci√≥n de un hash utilizando cualquier <a href="https://miniwebtool.com/es/sha256-hash-generator/">generador en l√≠nea</a>. En este caso, <a href="https://bfotool.com/category/encode-decoder">realizamos pruebas</a> utilizando la funci√≥n hash <code>SHA-256</code> y <code>keccak-256</code>, tambi√©n pueden explorar y probar <a href="https://bfotool.com/category/encode-decoder">m√°s funciones hash desde aqu√≠.</a></p>
<p>El cambio de un solo bit causa un efecto avalancha, lo que significa que incluso un cambio m√≠nimo como un <code>.</code> en la entrada, produce un cambio significativo en la salida. Puedes revisar el hash de <code>L2 en Espa√±ol</code> y <code>L2 en Espa√±ol.</code></p>
<p><img src="./assets/Sha256.png" alt="graph" /></p>
<div align="center">
<em>Salida de datos completamente diferente a√±adiendo un "."</em>
</div>
<p><code>SHA-256</code> se utiliza ampliamente en criptograf√≠a, y cuenta con diversos casos de uso destacados:</p>
<ol>
<li><strong>Verificaci√≥n de integridad:</strong> <code>SHA-256</code> se utiliza para verificar la integridad de los datos almacenados en un sistema. Al calcular el hash de un archivo o conjunto de datos, se puede comparar con el hash original para detectar cualquier cambio o alteraci√≥n en los datos.</li>
<li><strong>Firmas digitales:</strong> las firmas digitales se generan mediante algoritmos criptogr√°ficos y se basan en la funci√≥n SHA-256 para asegurar la autenticidad e integridad de los mensajes. El hash <code>SHA-256</code> se utiliza para resumir y proteger la informaci√≥n que se firma digitalmente.</li>
<li><strong>Almacenamiento seguro de contrase√±as:</strong> en lugar de almacenar contrase√±as en texto plano, los sistemas de seguridad suelen almacenar el hash <code>SHA-256</code> de las contrase√±as. Cuando un usuario ingresa su contrase√±a, se calcula el hash y se compara con el valor almacenado, lo que permite verificar la autenticidad de la contrase√±a sin almacenarla directamente.</li>
<li><strong>Generaci√≥n de claves criptogr√°ficas:</strong> <code>SHA-256</code> se utiliza en algoritmos de generaci√≥n de claves criptogr√°ficas para producir claves aleatorias y seguras.</li>
</ol>
<p>En resumen, <code>SHA-256</code> es una funci√≥n hash criptogr√°fica ampliamente utilizada que forma parte de la familia de algoritmos <code>SHA-2</code>, la hace ideal para verificar la integridad de los datos, generar firmas digitales, almacenar contrase√±as de forma segura y generar claves criptogr√°ficas. <code>SHA-256</code> ha demostrado su robustez y eficacia en numerosos casos de uso en criptograf√≠a. Ahora es el turno de explorar otra funci√≥n hash criptogr√°fica m√°s moderna llamada Keccak.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak---el-nuevo-sha-3"><a class="header" href="#keccak---el-nuevo-sha-3">Keccak - El nuevo SHA-3</a></h1>
<p>Este cap√≠tulo nos centraremos en el <code>SHA-3</code> <a href="https://en.wikipedia.org/wiki/SHA-3"><strong>(Secure Hash Algorithm 3)</strong></a>, es un est√°ndar de funci√≥n hash criptogr√°fica dise√±ado por los cript√≥grafos Joan Daemen y Gilles Van Assche. El algoritmo utilizado en <code>SHA-3</code> se llama <a href="https://keccak.team/index.html"><strong>Keccak</strong></a>, el cual fue <a href="https://www.federalregister.gov/documents/2015/08/05/2015-19181/announcing-approval-of-federal-information-processing-standard-fips-202-sha-3-standard"><strong>seleccionado como el ganador del concurso</strong></a> organizado por el Instituto Nacional de Est√°ndares y Tecnolog√≠a <a href="https://en.wikipedia.org/wiki/National_Institute_of_Standards_and_Technology">(NIST)</a> para encontrar un nuevo est√°ndar de funci√≥n hash criptogr√°fica.</p>
<p>A diferencia de <code>SHA-256</code>, <code>Keccak</code> utiliza una estructura y operaciones diferentes. En lugar de rondas, <code>Keccak</code> se basa en una construcci√≥n llamada funci√≥n de esponja <a href="https://en.wikipedia.org/wiki/Sponge_function">(Sponge function)</a>, que se basa en una funci√≥n pseudoaleatoria amplia o <a href="https://keccak.team/glossary.html#permutation">(permutation)</a> pseudoaleatorio permitiendo ingresar <strong>&quot;absorbing&quot;</strong> y <strong>&quot;squeezing&quot;</strong>.</p>
<p><code>Keccak-256</code> es una funci√≥n hash criptogr√°fica utilizada en Ethereum. Pertenece a la familia de algoritmos <code>SHA-3</code> y se emplea ampliamente en la plataforma Ethereum para diversos prop√≥sitos.</p>
<p>Algunos casos de uso de <code>Keccak-256</code> incluyen:</p>
<ul>
<li>Ethereum utiliza <code>Keccak-256</code> para garantizar la integridad de los datos y generar identificadores √∫nicos (hash) para verificar la autenticidad de los archivos y mensajes en sistemas criptogr√°ficos.</li>
<li>Tambi√©n se utiliza en la firma criptogr√°fica de peque√±o tama√±o, donde en lugar de firmar la entrada completa, se firma el hash <code>Keccak-256</code> del mensaje o dato.</li>
<li><code>Keccak-256</code> es utilizado para obtener una identificaci√≥n √∫nica y determinista de una colecci√≥n de datos. Por ejemplo, en Ethereum, las direcciones de Ethereum se derivan de claves p√∫blicas o contratos utilizando la funci√≥n hash unidireccional <code>Keccak-256</code>.</li>
</ul>
<p>Las direcciones Ethereum son n√∫meros hexadecimales, identificadores derivados de los √∫ltimos 20 bytes del hash <code>Keccak-256</code> de la clave p√∫blica.</p>
<p>A diferencia de las direcciones de Bitcoin, que est√°n codificadas en la interfaz de usuario de todos los clientes para incluir una suma de verificaci√≥n incorporada para proteger contra direcciones mal escritas, las direcciones de Ethereum se presentan como hexadecimales sin ninguna suma de verificaci√≥n.</p>
<p><img src="./assets/Keccak.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>El algoritmo <strong>Keccak</strong> utiliza la <a href="https://keccak.team/glossary.html#sponge_construction"><strong>Sponge construction</strong></a> para procesar los datos de entrada de longitud variable para generar una salida de longitud variable. Esta construcci√≥n se basa en una funci√≥n interna llamada <code>&quot;F&quot;</code> que opera en un n√∫mero fijo de bits, denotado como <code>&quot;width&quot;</code> <a href="https://keccak.team/glossary.html#width">(anchura)</a>.</p>
<p>La anchura total del algoritmo Keccak se determina sumando dos componentes, el valor de <code>&quot;r&quot;</code> <a href="https://keccak.team/glossary.html#rate">(rate)</a> y el valor de <code>&quot;c&quot;</code> <a href="https://keccak.team/glossary.html#capacity">(capacity)</a>, donde <code>b = r + c</code>.</p>
<ul>
<li>El valor de <code>&quot;r&quot;</code> representa la cantidad de bits absorbidos en cada paso de la funci√≥n esponja, es decir, <strong>la capacidad de absorci√≥n de la esponja.</strong> Un valor de <code>&quot;r&quot;</code> m√°s grande permite procesar m√°s informaci√≥n en cada paso, lo que reduce la cantidad de pasos necesarios para procesar una entrada espec√≠fica.</li>
<li>El valor de <code>&quot;c&quot;</code> representa la capacidad de la esponja, es decir, <strong>la cantidad de bits que se mantienen en el estado interno del algoritmo despu√©s de cada paso de absorci√≥n</strong>. Estos bits se mezclan con los datos de entrada y el resultado de la funci√≥n interna <code>&quot;F&quot;</code>. La capacidad afecta la resistencia del algoritmo a ataques criptogr√°ficos como colisiones o preimagen.</li>
</ul>
<p>La suma de <code>&quot;r&quot;</code> y <code>&quot;c&quot;</code> da como resultado el n√∫mero total de bits, <code>&quot;b&quot;</code>, utilizados en la funci√≥n esponja de Keccak. Este valor determina la longitud del estado interno y, por lo tanto, la longitud de la salida generada por el algoritmo.</p>
<h2 id="funcionamiento-keccak"><a class="header" href="#funcionamiento-keccak">Funcionamiento keccak</a></h2>
<p>El algoritmo funciona de la siguiente manera, inicialmente la cadena de entrada se rellena con bits adicionales para enmascarar el mensaje inicial y se divide en bloques de longitud <code>&quot;r&quot;</code> bits. Luego, los <code>&quot;b&quot;</code> bits de estado se inicializan a <code>0</code>, que da inicio a la <strong>Sponge construction</strong> en dos fases <strong>&quot;absorbing&quot;</strong> y <strong>&quot;squeezing&quot;</strong>.</p>
<ul>
<li><strong>Fase Absorbing:</strong> a los bloques de entrada de longitud <code>r-bits</code> se les aplica un <a href="https://en.wikipedia.org/wiki/XOR_cipher">XOR</a> (toma dos bits y devuelve un resultado que es 1 si solo uno de los bits es 1, y 0 en caso contrario) a los primeros <code>r</code> bits del estado, altern√°ndose con la funci√≥n <code>f</code>. Cuando todos los bloques han sido procesados, se pasa a la siguiente fase.</li>
<li><strong>Fase Squeezing:</strong> los primeros <code>r</code> bits del estado son devueltos como bloques de salida, altern√°ndose con ejecuciones de la funci√≥n <code>f</code>. El n√∫mero de bloques de salida es seleccionado por el usuario.</li>
</ul>
<p>A continuaci√≥n os dejamos una tabla que enumeran algunas de las diferencias entre <code>SHA-256</code> y <code>Keccak-256</code>.</p>
<p><img src="./assets/Comparativa_Sha_keccak.png" alt="graph" /></p>
<div align="center">
<em>Algunas diferencias entre SHA-256 y Keccak-256</em>
</div>
<p>Vemos c√≥mo cada tipo de criptograf√≠a o funci√≥n hash tiene caracter√≠sticas distintas. En el contexto actual de la computaci√≥n cu√°ntica en constante evoluci√≥n, es crucial abordar las preocupaciones emergentes sobre seguridad. Algunos algoritmos criptogr√°ficos podr√≠an ser vulnerables a los ataques cu√°nticos en un futuro cercano. Es en este punto donde entra en juego el concepto de criptograf√≠a <a href="https://en.wikipedia.org/wiki/Post-quantum_cryptography">Post-Quantum</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quantum-secure"><a class="header" href="#quantum-secure">Quantum Secure</a></h1>
<p>Recomendamos repasar los episodios previos antes de leer este cap√≠tulo, con el fin de adquirir un mayor conocimiento de algunas definiciones y explorar posibles escenarios te√≥ricos apocal√≠pticos que podr√≠an ocurrir. Pero antes comencemos con una breve descripci√≥n sobre <a href="https://es.wikipedia.org/wiki/Computaci%C3%B3n_cu%C3%A1ntica">computaci√≥n cu√°ntica</a> para sumergirnos en el tema. <strong>No es m√°s que un modelo de computaci√≥n basado en la</strong> <a href="https://es.wikipedia.org/wiki/Mec%C3%A1nica_cu%C3%A1ntica"><strong>f√≠sica cu√°ntica</strong></a>, que funciona de manera diferente a las computadoras cl√°sicas (el tipo de computadoras que usamos habitualmente) y tiene la capacidad de realizar tareas que estas √∫ltimas no pueden, como romper ciertos algoritmos de manera eficiente.</p>
<blockquote>
<p><strong>¬°As√≠ que espera un momento!</strong> Antes de que tu imaginaci√≥n se desborde y te veas rodeado de supercomputadoras cu√°nticas capaces de solucionar todos nuestros problemas, d√©jame contarte una peque√±a an√©cdota.</p>
</blockquote>
<blockquote>
<p><em>Ah, las computadoras cu√°nticas, esas criaturas de la f√≠sica cu√°ntica que nos hacen so√±ar con un futuro lleno de posibilidades. Pero, ¬øsab√≠as que no son m√°quinas m√°gicas capaces de resolver todos nuestros problemas inform√°ticos en un abrir y cerrar de ojos?</em></p>
</blockquote>
<blockquote>
<p><strong>Imagina esto:</strong> las computadoras cu√°nticas son como esas personas brillantes que son s√∫per eficientes en ciertas tareas, pero bastante d√©biles en otras. Son como el genio matem√°tico que resuelve complicados problemas de c√°lculo en segundos, pero se le olvida c√≥mo atarse los zapatos.</p>
</blockquote>
<blockquote>
<p><em>Entonces, s√≠, las computadoras cu√°nticas pueden ser incre√≠blemente poderosas cuando se trata de ciertos problemas espec√≠ficos, como el factorizar n√∫meros grandes o buscar en enormes bases de datos. Pero cuando se trata de tareas cotidianas, como revisar correos electr√≥nicos o navegar por la web, bueno, digamos que son como un caracol tratando de correr una marat√≥n.</em></p>
</blockquote>
<p>Despu√©s de esta peque√±a relato, es importante comprender el concepto de criptograf√≠a post-cu√°ntica <a href="https://cryptobook.nakov.com/quantum-safe-cryptography"><strong>(PQC)</strong></a>, tambi√©n conocida como <a href="https://cryptobook.nakov.com/quantum-safe-cryptography"><strong>Resistente a la Computaci√≥n Cu√°ntica</strong></a>, se refiere a algoritmos criptogr√°ficos especialmente algoritmos de clave p√∫blica, que se consideran seguros contra los ataques criptoanal√≠ticos llevados a cabo por computadoras cu√°nticas.</p>
<p>A medida que avanza la computaci√≥n cu√°ntica, se espera que algunos algoritmos y t√©cnicas criptogr√°ficas tradicionales utilizadas en los sistemas de seguridad actuales sean vulnerables a los ataques cu√°nticos. Esto se debe a la capacidad de las computadoras cu√°nticas para realizar c√°lculos a una escala exponencialmente mayor que las computadoras cl√°sicas, lo que podr√≠a comprometer la seguridad de los sistemas criptogr√°ficos actuales.</p>
<p>Es bien sabido en inform√°tica que las computadoras cu√°nticas podr√°n romper algunos algoritmos criptogr√°ficos, especialmente los criptosistemas de clave p√∫blica como <strong>RSA</strong>, el intercambio de llaves <strong>Diffie‚ÄìHellman</strong> y <strong>ECDSA</strong>, que dependen del <a href="https://es.wikipedia.org/wiki/Factorizaci%C3%B3n_de_enteros"><strong>IFP</strong></a> (problema de factorizaci√≥n en n√∫meros primos), el <a href="https://es.wikipedia.org/wiki/Logaritmo_discreto"><strong>DLP</strong></a> (problema del logaritmo discreto) y el ECDLP (problema del logaritmo discreto de curva el√≠ptica). Todos estos problemas podr√≠an resolverse f√°cilmente en una computadora cu√°ntica suficientemente poderosa que ejecute el algoritmo de Shor.</p>
<p>Pero los algoritmos cu√°nticos no significar√°n el fin de la criptograf√≠a, porque:</p>
<ul>
<li>Solo algunos criptosistemas son inseguros frente a la computaci√≥n cu√°ntica (como RSA, DHKE, ECDSA y ECDH).</li>
<li>Algunos criptosistemas son seguros frente a la computaci√≥n cu√°ntica y solo se ver√°n ligeramente afectados (como los hash criptogr√°ficos, algoritmos <a href="https://es.wikipedia.org/wiki/C%C3%B3digo_de_autenticaci%C3%B3n_de_mensaje">MAC</a> y cifrados de clave sim√©trica como <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard?wprov=srpw1_0">AES</a>, siempre que se utilicen tama√±os de clave suficientemente grandes).</li>
</ul>
<p>A diferencia de la amenaza que representa la computaci√≥n cu√°ntica para los algoritmos de clave p√∫blica actuales, <strong>la mayor√≠a de los algoritmos criptogr√°ficos sim√©tricos y las funciones hash actuales se consideran relativamente seguros contra ataques de computadoras cu√°nticas.</strong> Si bien el algoritmo cu√°ntico de Grover acelera los ataques contra los cifrados sim√©tricos, duplicar el tama√±o de la clave puede bloquear eficazmente estos ataques. Por lo tanto, la criptograf√≠a sim√©trica post-cu√°ntica no necesita diferir significativamente de la criptograf√≠a sim√©trica actual.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="el-algoritmo-de-grover-y-la-b√∫squeda-no-estructurada"><a class="header" href="#el-algoritmo-de-grover-y-la-b√∫squeda-no-estructurada">El algoritmo de Grover y la b√∫squeda no estructurada</a></h1>
<p>El <a href="https://es.wikipedia.org/wiki/Algoritmo_de_Grover">algoritmo de Grover</a> es un <a href="https://es.wikipedia.org/wiki/Algoritmo_cu%C3%A1ntico">algortimo cu√°ntico</a> para la b√∫squeda en una secuencia no ordenada de datos con <code>N</code> componentes en un tiempo <a href="https://es.wikipedia.org/wiki/Cota_superior_asint%C3%B3tica">O</a>(N¬π/‚ÇÇ), y con una necesidad adicional de espacio de almacenamiento de <code>O(logN)</code>. Fue inventado por Lov K. Grover en <a href="https://es.wikipedia.org/wiki/1996">1996</a>.</p>
<p>Aunque el algoritmo de Grover es eficiente, su paralelizaci√≥n √≥ptima resulta complicada y no se espera que las computadoras cu√°nticas actuales tengan suficiente potencia para comprometer la seguridad de esquemas como ECDSA o de funciones de hash como SHA256.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="el-algoritmo-de-shor-te√≥rico-y-su-impacto-en-ecdsa"><a class="header" href="#el-algoritmo-de-shor-te√≥rico-y-su-impacto-en-ecdsa">El algoritmo de Shor te√≥rico y su impacto en ECDSA</a></h1>
<p>El <a href="https://en.wikipedia.org/wiki/Shor&#x27;s_algorithm"><strong>algoritmo de Shor</strong></a> es un algoritmo cu√°ntico desarrollado por Peter Shor en 1994. Este algoritmo es conocido por su capacidad para factorizar grandes n√∫meros enteros de manera mucho m√°s eficiente que los algoritmos cl√°sicos conocidos, lo que tiene implicaciones importantes para la seguridad de algunos sistemas criptogr√°ficos basados en la factorizaci√≥n de n√∫meros enteros.</p>
<p>En el contexto de sistemas centralizados, como los sistemas bancarios, ECDSA se utiliza para garantizar la autenticidad de las transacciones, proteger la confidencialidad de la informaci√≥n y asegurar la integridad de los datos. En el √°mbito de Bitcoin y Ethereum, si bien los algoritmos de b√∫squeda cu√°ntica, como el algoritmo de Shor, podr√≠an eventualmente romper la ECDSA, es importante destacar que estos algoritmos a√∫n est√°n en una etapa te√≥rica.</p>
<p>Cada implementaci√≥n de algoritmos o protocolos puede ser diversa, ya sea privada o abstracta. Nos hemos centrado en los principios b√°sicos comunes de ECDSA, adem√°s se espera que la implementaci√≥n pr√°ctica de algoritmos de b√∫squeda cu√°ntica sea un desaf√≠o t√©cnico debido a los requisitos de recursos y la necesidad de superar errores cu√°nticos.</p>
<p>Aqu√≠ tienes una descripci√≥n general de en qu√© consisten algunos problemas que se consideran complejos de resolver mediante la computaci√≥n cl√°sica.</p>
<h2 id="ifp"><a class="header" href="#ifp">IFP</a></h2>
<p>El IFP se refiere al desaf√≠o de descomponer un n√∫mero entero grande en sus factores primos. En el caso de n√∫meros peque√±os, esto puede hacerse f√°cilmente mediante el uso de algoritmos como <a href="https://yosoytuprofe.20minutos.es/2022/11/09/que-es-la-criba-de-eratostenes-y-cual-es-su-importancia-en-las-matematicas/">el cribado de Erat√≥stenes</a> o <a href="https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm_for_logarithms">el algoritmo de factorizaci√≥n de Pollard</a>.</p>
<p>A modo de ejemplo simplificado, supongamos que queremos factorizar el n√∫mero compuesto <code>N = 35</code> utilizando el algoritmo de Shor. Despu√©s de aplicar el algoritmo, encontrar√≠amos que los factores primos de <code>N</code> son <code>5 y 7</code>.</p>
<p>Sin embargo, a medida que los n√∫meros crecen en tama√±o, el IFP se vuelve cada vez m√°s dif√≠cil de resolver. De hecho, la seguridad de muchos sistemas criptogr√°ficos se basa en la dificultad de factorizar n√∫meros grandes en tiempo razonable, como el popular algoritmo RSA.</p>
<h2 id="dlp"><a class="header" href="#dlp">DLP</a></h2>
<p>Por otro lado, el DLP implica encontrar el exponente desconocido de una potencia modular dada. En t√©rminos m√°s sencillos, se trata de resolver la ecuaci√≥n <code>(y = gÀ£ mod p)</code> para el exponente desconocido <code>(x)</code>, donde <code>(g)</code> y <code>(p)</code> son n√∫meros conocidos e <code>(y)</code> es el resultado de la operaci√≥n de potenciaci√≥n modular. Para valores peque√±os de <code>(p)</code>, el DLP puede resolverse mediante la aplicaci√≥n de m√©todos exhaustivos como la prueba y error.</p>
<p>A modo de ejemplo simplificado, ser√≠a encontrar el logaritmo discreto de <code>base 2</code> para el n√∫mero <code>5</code> <code>m√≥dulo 11</code>. Esto implica encontrar el valor de <code>x</code> en la ecuaci√≥n <code>2À£ ‚â° 5 (mod 11).</code></p>
<p>Realizando los c√°lculos paso a paso:</p>
<ul>
<li>2¬π ‚â° 2 (mod 11)</li>
<li>2¬≤ ‚â° 4 (mod 11)</li>
<li>2¬≥ ‚â° 8 (mod 11)</li>
<li>2‚Å¥ ‚â° 5 (mod 11)</li>
</ul>
<p>Entonces, el valor de <code>x</code> que satisface la ecuaci√≥n <code>2À£ ‚â° 5 (mod 11)</code> es <code>x = 4</code>.</p>
<h2 id="ecdlp"><a class="header" href="#ecdlp">ECDLP</a></h2>
<p>La seguridad de esquemas criptogr√°ficos basados en <strong>ECC</strong>, como <strong>ECDSA</strong>, se basa en la dificultad de resoluci√≥n del problema del logaritmo discreto de curva el√≠ptica o <strong>ECDLP</strong>. Las curvas el√≠pticas son objetos matem√°ticos utilizados en criptograf√≠a de clave p√∫blica, y el <strong>ECDLP</strong> ser√≠a el problema de hallar el valor de <code>‚ÄòK‚Äô</code> en esta ecuaci√≥n, <code>P =k‚ãÖG</code>, donde <code>P</code> es un punto en la curva, <code>k</code> es el valor que debemos hallar y <code>G</code> es un punto base conocido (el generador).</p>
<p>Al igual que en el caso del <strong>DLP</strong>, el <strong>ECDLP</strong> se vuelve m√°s dif√≠cil de resolver a medida que el tama√±o de los n√∫meros involucrados en esas expresiones matem√°ticas aumentan</p>
<h2 id="ecdsa"><a class="header" href="#ecdsa">ECDSA</a></h2>
<p>Por √∫ltimo llegamos a un algoritmo ampliamente utilizado y conocido como es el <strong>ECDSA</strong>, que se utiliza com√∫nmente en blockchain. La clave p√∫blica se obtiene multiplicando un punto base conocido (llamado generador) en la curva el√≠ptica por un entero, que representa la llave privada. El desaf√≠o radica en encontrar ese valor privado a partir del punto p√∫blico conocido en la curva.</p>
<p>La curva el√≠ptica <strong>secp256k1</strong> est√° definida por la ecuaci√≥n: <code>y¬≤ = x¬≥ + ax + b</code> sobre <code>ùîΩp</code> donde <code>p</code> es un n√∫mero primo grande.</p>
<p>El algoritmo de Shor, en su versi√≥n completa y ejecutado en un computador cu√°ntico lo suficientemente grande y estable, podr√≠a factorizar el n√∫mero primo <code>p</code> en esta ecuaci√≥n, lo que proporcionar√≠a informaci√≥n sobre el orden del subgrupo c√≠clico relacionado con la curva.</p>
<p>Si se pudiera determinar el orden del subgrupo c√≠clico relacionado con la curva <code>secp256k1</code> utilizando el algoritmo de <strong>Shor</strong>, ser√≠a posible encontrar el valor privado a partir de la clave p√∫blica. Esto comprometer√≠a la seguridad de <strong>ECDSA</strong>, ya que la clave privada es fundamental para generar firmas digitales y autenticar transacciones. Es importante destacar que el algoritmo de Shor plantea un desaf√≠o para los sistemas criptogr√°ficos actuales basados en la factorizaci√≥n de n√∫meros enteros o en el logaritmo discreto, como <strong>RSA</strong> y <strong>ECDSA</strong>.</p>
<p>No obstante, la implementaci√≥n pr√°ctica de un algoritmo cu√°ntico capaz de realizar estos c√°lculos, como los mencionados ejemplos, todav√≠a se encuentra en desarrollo y no representa una amenaza inmediata para los sistemas criptogr√°ficos utilizados en la actualidad. La investigaci√≥n y el desarrollo continuo en criptograf√≠a pos-cu√°ntica son fundamentales para garantizar la seguridad en un entorno tecnol√≥gico en constante evoluci√≥n.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="criptograf√≠a-basada-en-lattice-previene-shor"><a class="header" href="#criptograf√≠a-basada-en-lattice-previene-shor">Criptograf√≠a basada en Lattice previene Shor</a></h2>
<p>En este cap√≠tulo aprenderemos c√≥mo una verificaci√≥n de esquemas de firmas puede ser lo suficientemente fuerte para prevenirnos contra un posible ataque ejecutado con el algoritmo de Shor, la criptograf√≠a basada en ret√≠culos <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_basada_en_ret%C3%ADculos"><strong>(Lattice)</strong></a>, es una forma segura de protegerse frente a muchos algoritmos.</p>
<p>Pensemos en un <a href="https://es.wikipedia.org/wiki/Red_(grupo)">ret√≠culo</a>, como una estructura matem√°tica que se forma mediante una red de puntos en un espacio n-dimensional. Es similar a una cuadr√≠cula o una rejilla en dos dimensiones, pero se extiende a cualquier n√∫mero de dimensiones. Cada punto en el ret√≠culo est√° ubicado en una posici√≥n determinada y est√° conectado a los puntos vecinos por l√≠neas rectas de igual longitud.</p>
<p>En el contexto de la criptograf√≠a basada en ret√≠culos, se utilizan ret√≠culos en <a href="https://es.wikipedia.org/wiki/Teor%C3%ADa_de_n%C3%BAmeros">teor√≠a de n√∫meros</a> para construir sistemas criptogr√°ficos. Estos ret√≠culos se definen mediante un conjunto de vectores base, que son combinaciones lineales de vectores de coordenadas con coeficientes enteros. Los ret√≠culos tienen propiedades matem√°ticas interesantes, como la propiedad de ser densos y uniformes en el espacio.</p>
<p>Los problemas computacionales basados en ret√≠culos, como el problema de la aproximaci√≥n m√°s cercana en ret√≠culos o el problema del vector corto m√°s cercano, se utilizan en criptograf√≠a para establecer la seguridad de los esquemas basados en ret√≠culos. Estos problemas son dif√≠ciles de resolver y se cree que no existen algoritmos eficientes para resolverlos en el caso general, lo que brinda seguridad a los sistemas criptogr√°ficos basados en ret√≠culos.</p>
<p>La criptograf√≠a basada en ret√≠culos es el t√©rmino gen√©rico para las construcciones de primitivas criptogr√°ficas que involucran ret√≠culos, ya sea en la construcci√≥n misma o en la prueba de seguridad.</p>
<p><strong>Las construcciones basadas en ret√≠culos son actualmente candidatas importantes para la criptograf√≠a post-cu√°ntica.</strong> A diferencia de los esquemas de clave p√∫blica m√°s ampliamente utilizados y conocidos, como RSA, Diffie-Hellman o los criptosistemas de curva el√≠ptica, que te√≥ricamente podr√≠an ser derrotados utilizando el algoritmo de Shor en un computador cu√°ntico, algunas construcciones basadas en ret√≠culos parecen ser resistentes a los ataques tanto de computadoras cl√°sicas como cu√°nticas. Adem√°s, muchas construcciones basadas en ret√≠culos se consideran seguras bajo la suposici√≥n de que ciertos problemas computacionales bien estudiados en ret√≠culos no pueden ser resueltos.</p>
<p>Aqu√≠ hay una breve explicaci√≥n de las diferencias entre los esquemas de criptograf√≠a basados en ret√≠culos en t√©rminos de encriptaci√≥n, funciones hash y intercambio de claves:</p>
<ol>
<li><strong>Encriptaci√≥n basada en ret√≠culos:</strong> los esquemas de encriptaci√≥n basados en ret√≠culos aprovechan las propiedades matem√°ticas de los ret√≠culos para proporcionar seguridad en la comunicaci√≥n.</li>
<li><strong>Funciones hash basadas en ret√≠culos:</strong> las funciones hash basadas en ret√≠culos utilizan ret√≠culos y operaciones matem√°ticas relacionadas para calcular los hashes y se utilizan en diversas aplicaciones criptogr√°ficas, como la integridad de datos y la firma digital.</li>
<li><strong>Intercambio de claves basado en ret√≠culos:</strong> el intercambio de claves basado en ret√≠culos como el <a href="https://newhopecrypto.org/">(Intercambio NewHope Protocol)</a> implica el establecimiento de una clave compartida entre dos o m√°s partes que desean comunicarse de manera segura. Los protocolos de intercambio de claves basados en ret√≠culos utilizan los ret√≠culos y los problemas computacionales relacionados con ellos para garantizar que las partes puedan acordar una clave sin que un tercero pueda determinarla. Estos esquemas se basan en la dificultad de resolver ciertos problemas matem√°ticos relacionados con los ret√≠culos para asegurar la confidencialidad de la clave compartida.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kyber-crystal"><a class="header" href="#kyber-crystal">Kyber Crystal</a></h1>
<p>En este estudio post-quantum veremos <a href="https://pq-crystals.org/kyber/resources.shtml"><strong>Kyber</strong></a>, antes de entrar dentro del ecosistema de Starkware y aprender c√≥mo se generan los contratos de cuentas, as√≠ como las caracter√≠sticas criptogr√°ficas y matem√°ticas detr√°s de las STARKs.</p>
<p>Kyber es un m√©todo de encapsulaci√≥n de clave <a href="https://en.wikipedia.org/wiki/Key_encapsulation">(KEM)</a> dise√±ado para resistir ataques criptoanal√≠ticos realizados por futuras computadoras cu√°nticas poderosas. Se utiliza para establecer un secreto compartido entre dos partes que se comunican, sin que un atacante <a href="https://en.wikipedia.org/wiki/Ciphertext_indistinguishability">(IND-CCA2)</a> en el sistema de transmisi√≥n pueda descifrarlo. Este criptosistema asim√©trico utiliza una variante del problema de redes de aprendizaje con errores <a href="https://en.wikipedia.org/wiki/Learning_with_errors">(learning with errors, LWE)</a> como su <a href="https://en.wikipedia.org/wiki/Trapdoor_function">funci√≥n b√°sica con trampa</a>. Gan√≥ la competencia del NIST para el primer est√°ndar de criptograf√≠a PQ.</p>
<p>La generaci√≥n de claves en Kyber no se basa en la factorizaci√≥n de enteros o en problemas relacionados con las curvas el√≠pticas, sino que utiliza el problema de aprendizaje con errores en ret√≠culos como base para la seguridad del algoritmo.</p>
<p>El sistema se basa en el aprendizaje con errores en m√≥dulos (M-LWE) del campo del aprendizaje autom√°tico, en conjunto con anillos ciclot√≥micos. Recientemente, tambi√©n se ha logrado una reducci√≥n formal matem√°tica estrecha de la problem√°tica del anillo LWE al MLWE. <strong>En comparaci√≥n con otros m√©todos de criptograf√≠a post-cu√°ntica, tiene las ventajas t√≠picas de los m√©todos basados en ret√≠culos, como el tiempo de ejecuci√≥n, el tama√±o de los textos cifrados y el material clave.</strong></p>
<p>En cuanto a los par√°metros, Kyber proporciona diferentes conjuntos para alcanzar diferentes niveles de seguridad. Por ejemplo, <code>Kyber-512</code> tiene una seguridad aproximada equivalente a <code>AES-128</code>, <code>Kyber-768</code> tiene una seguridad aproximada equivalente a <code>AES-192</code> y <code>Kyber-1024</code> tiene una seguridad aproximada equivalente a <code>AES-256</code>.</p>
<p>En resumen, Kyber utiliza un enfoque matem√°tico diferente a ECDSA en la generaci√≥n de claves. Se basa en el problema de aprendizaje con errores en ret√≠culos y en la selecci√≥n adecuada de par√°metros de seguridad. La seguridad de Kyber radica en la dificultad de resolver problemas criptogr√°ficos espec√≠ficos asociados a ese enfoque matem√°tico.</p>
<p>Con esto hemos concluido las bases criptogr√°ficas que nos han brindado los detalles de c√≥mo se generan los distintos tipos de criptograf√≠a sim√©trica o asim√©trica, as√≠ como las funciones hash y su importancia en la seguridad. Nos adentramos en c√≥mo se integraban en los Merkle Tree o Patricia Trie, para luego explorar el √°mbito de la computaci√≥n cu√°ntica y ver c√≥mo se pod√≠an resolver algunos de los problemas planteados por ciertas criptograf√≠as. Tambi√©n destacamos la importancia de las firmas y las verificaciones de firmas en los avances de la tecnolog√≠a de la computaci√≥n cu√°ntica.</p>
<p>La computaci√≥n cu√°ntica se mostr√≥ resistente a las bases sim√©tricas de una llave maestra o a las funciones hash en s√≠. Adem√°s, presenciamos avances en la prevenci√≥n de ataques cu√°nticos y en algoritmos cu√°nticos como Lattice o encapsulamientos por Kyber. Con estos avances en mente, es hora de pasar a ver las EOA (Externally Owned Accounts) y los firmantes en Ethereum, para luego diferenciarlos de la Account Abstraction nativa en Starknet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eoa-y-aa---firmantes"><a class="header" href="#eoa-y-aa---firmantes">EOA y AA - Firmantes</a></h1>
<p>Las cuentas de EOA <a href="https://ethereum.org/en/whitepaper/#ethereum-accounts"><strong>(Externally Owned Accounts)</strong></a> en Ethereum, al igual que muchas otras criptomonedas, utilizan el algoritmo ECDSA que aprendimos antes para generar claves y firmar transacciones digitalmente. Esto les permite participar de manera segura en la red y realizar operaciones. Las EOA son cuentas que pertenecen a usuarios externos a la cadena de bloques.</p>
<p>En Ethereum, el estado de una cuenta solo puede ser modificado a trav√©s de transacciones, las cuales deben ser iniciadas por una EOA. sin embargo, no cualquier persona puede activar una transacci√≥n desde cualquier EOA, aqu√≠ es donde entra en juego el concepto de firmante.</p>
<p>Cada cuenta en Ethereum est√° asociada con un objeto criptogr√°fico llamado keypair, como aprendimos antes.</p>
<p>La clave privada, se utiliza para firmar mensajes digitales, mientras que la clave p√∫blica permite que cualquiera pueda verificar que una firma en particular fue generada por la clave privada correspondiente.</p>
<p>La asociaci√≥n entre una cuenta y un firmante se realiza mediante la direcci√≥n de la cuenta. La direcci√≥n de un EOA se deriva de la clave p√∫blica del firmante, espec√≠ficamente, <strong>la direcci√≥n se obtiene tomando los √∫ltimos 20 bytes del hash Keccak-256 de la clave p√∫blica.</strong></p>
<p>El propietario de una cuenta puede autorizar una transacci√≥n desde su cuenta firmando los par√°metros de la transacci√≥n con la clave privada correspondiente.</p>
<p>La <a href="https://ethereum.org/en/whitepaper/#ethereum-accounts"><strong>curva el√≠ptica secp256k1</strong></a>  es una de las curvas el√≠pticas m√°s utilizadas en criptograf√≠a, especialmente en el contexto de criptomonedas como Bitcoin o Ethereum. Esto ha permitido establecer esquemas de firmas digitales que garantizan la integridad de las transacciones al asegurar la autenticidad de las claves.</p>
<p>La abstracci√≥n de firma y clave privada es una propiedad presente en algunos sistemas criptogr√°ficos, como ciertos esquemas de firmas digitales basados en identidad. Sin embargo, en el caso del algoritmo ECDSA utilizado en Ethereum y muchas otras blockchain, la firma est√° inherentemente vinculada a la clave privada de la cuenta y no es posible separarlas o abstraerlas, como podr√≠a ser el caso en otros esquemas dise√±ados con estos principios.</p>
<p>Ahora que ya hemos adquirido los conceptos b√°sicos y hemos prestado atenci√≥n para adquirir la formaci√≥n adecuada y avanzada, podemos sumergirnos en el apasionante ecosistema de StarkWare, Starknet, StarkEx y STARKs. Nuestra mente est√° mejor preparada para embarcarnos en el viaje que nos espera en el resto del documento y en las futuras series.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="starknet-aa"><a class="header" href="#starknet-aa">Starknet AA</a></h2>
<p>En esta secci√≥n sobre <a href="https://www.starknet.io/en"><strong>Starknet</strong></a>, continuaremos construyendo sobre los conceptos previamente abordados en los cap√≠tulos anteriores, donde exploramos temas fundamentales de criptograf√≠a. Esperamos que haya disfrutado de la informaci√≥n y recursos presentados en cap√≠tulos anteriores, ya que han sido de vital importancia para comprender lo que abordaremos a continuaci√≥n dentro de <strong>Starknet</strong>. Exploraremos c√≥mo mejora todo el ecosistema y c√≥mo los contratos de cuentas (CA) y el esquema de firmas abstra√≠das ofrecen beneficios significativos en comparaci√≥n con el <a href="https://medium.com/infinitism/erc-4337-account-abstraction-without-ethereum-protocol-changes-d75c9d94dc4a">ERC-4337</a>.</p>
<p><em>Si deseas aprender m√°s sobre el concepto y las variantes del ERC-4337, te recomendamos leer esta serie de art√≠culos en el blog de <a href="https://www.argent.xyz/argent-x/">Argent</a>. La serie est√° compuesta por la <a href="https://www.argent.xyz/blog/wtf-is-account-abstraction/">Parte 1</a>, <a href="https://www.argent.xyz/blog/part-2-wtf-is-account-abstraction/">Parte 2</a> y <a href="https://www.argent.xyz/blog/part-3-wtf-is-account-abstraction/">Parte 3</a>. Argent y <a href="https://braavos.app/">Braavos</a> son Smart wallets que aprovechan el poder del AA nativo en Starknet. Tambi√©n te recomendamos leer los art√≠culos de Braavos de <a href="https://braavos.app/account-abstraction-ethereum-comprehensive-guide/">Guide 101 AA</a> y <a href="https://braavos.app/account-abstraction-security-pyramid/">Security Pyramid AA</a>, los cuales presentan optimizaciones adicionales y capas de seguridad que exploraremos m√°s adelante. Estos recursos te proporcionar√°n una mejor comprensi√≥n del concepto de <strong>AA</strong> y del <strong>ERC-4337</strong>.</em></p>
<p><strong>¬°As√≠ que sin m√°s pre√°mbulos, bienvenidos a Starknet!</strong></p>
<p>En el ecosistema de Starknet, se encuentran diversas metodolog√≠as para generar claves y firmas. A diferencia de las cuentas EOA, en Starknet se emplea <strong>Account Abstraction</strong> <a href="https://book.starknet.io/chapter_5/index.html"><strong>(AA)</strong></a> para la implementaci√≥n de <strong>Contract Accounts</strong> <a href="https://book.starknet.io/chapter_5/index.html#ethereums_current_account_system_a_closer_look">(CA)</a>. Estos contratos son responsables de establecer la l√≥gica en nuestras cuentas dentro de Starknet, incluyendo la validaci√≥n del esquema de firma abstra√≠do.</p>
<p>En lugar de utilizar ECDSA, Starknet utiliza una variaci√≥n llamada [<strong>STARK Curve</strong>], un tipo de curva el√≠ptica m√°s amigable y optimizada que es nativa en el ecosistema, esta variante nos ofrece mejoras y caracter√≠sticas espec√≠ficas para las necesidades de Starknet.</p>
<p>Lo grandioso de tener esta abstracci√≥n nativa es que permite a√±adir diferentes l√≥gicas en tus esquemas o capas adicionales. Normalmente, se utiliza un sistema asim√©trico usando la curva el√≠ptica <code>secp256k1</code>, basado en la pseudoaleatoriedad y diversas operaciones matem√°ticas utilizando dicha curva, para generar claves privadas y p√∫blicas. Sin embargo, tambi√©n se pueden a√±adir curvas adicionales de forma nativa al crear un CA, como lo ha hecho Braavos con la <a href="https://github.com/myBraavos/efficient-secp256r1">secp256r1</a>. Esta curva cuenta con un sistema de firmas integrado, mejor optimizado y preparado para dispositivos modernos, donde el signer puede almacenar los datos habilitados por biometricidad en dispositivos aislados y seguros, como el m√≥dulo &quot;Enclave&quot; de Apple.</p>
<p>La AA desempe√±a un papel crucial al abstraer el esquema de firmas o verificaci√≥n de firmas de la ejecuci√≥n. Como vimos anteriormente, podemos generar una clave privada y mediante ECDSA generar una clave p√∫blica. En este caso el poseedor de esta clave privada y del esquema de firma asociado tiene el poder de realizar transacciones en Starknet, los <a href="https://book.starknet.io/chapter_8/transactions.html">dos tipos de transacciones</a> son <code>DEPLOY</code> o <code>INVOKE</code>.</p>
<p><img src="./assets/Invoke.png" alt="graph" /></p>
<div align="center">
<em>Contrato de Cuenta de usuario</em>
</div>
<p>Con AA podemos modificar estas firmas o curvas. Por ejemplo, la curva <code>Secp256r1</code>, vimos que ofrece una seguridad adicional en Braavos al configurar una firma biom√©trica en el m√≥dulo de seguridad del enclave. De esta manera, esta firma biom√©trica solo puede ser a√±adida gracias a AA.</p>
<p>Todo esto es posible gracias al lenguaje de programaci√≥n utilizado en la implementaci√≥n, el poderoso <a href="https://starkware.co/cairo/"><strong>Cairo</strong></a>, as√≠ que analicemos c√≥mo Cairo incorpora esta abstracci√≥n en su programaci√≥n.</p>
<p>En primer lugar, se necesita validar la firma y comprobar que coincide con la generada mediante ECDSA antes de proceder a la ejecuci√≥n. Estas dos funciones principales son <code>validate</code> y <code>execute</code>. Adem√°s, <code>execute</code> tambi√©n puede realizar m√∫ltiples llamadas utilizando <code>execute_calls</code>.</p>
<p><img src="./assets/invoke_execute.gif" alt="graph" /></p>
<div align="center">
<em>Informaci√≥n de la L√≥gica separada de las funciones validate, execute</em>
</div>
<p>Ahora analicemos c√≥mo Cairo incorpora esta abstracci√≥n en su programaci√≥n.</p>
<p>Veamos c√≥mo funciona un ciclo de transacci√≥n con AA nativa y c√≥mo se representa gr√°ficamente este ciclo completo de firmas para detectar si es correcto y realizar la operaci√≥n.</p>
<p>Tambi√©n pensemos en c√≥mo se podr√≠an combinar de manera eficiente firmas como ha realizado Braavos con la EC <code>secp256r1</code> o incluso realizar la verificaci√≥n de firmas, como vimos con Lattice para prevenir ataques cu√°nticos.</p>
<p><img src="./assets/transaccion.gif" alt="graph" /></p>
<div align="center">
<em>Ciclo completo de una firma y validaci√≥n de una trnasacci√≥n</em>
</div>
<p>Los conocimientos previos adquiridos nos han ense√±ado muchas cosas, una de ellas es c√≥mo el algoritmo de Shor puede te√≥ricamente romper ECDSA, pero no podr√° romper una prueba STARK. </p>
<p>En la secci√≥n de generaci√≥n de STARKs, aprenderemos como gracias a sus bases de criptograf√≠a sim√©trica y otras variables, si alguien nos roba, hackea o perdemos la cuenta, el esquema <strong>PQS</strong> para la prueba no ser√° de mucha utilidad, ya que no se ha alterado la integridad del estado de los datos, sino que por oun te√≥rico ataque criptoanal√≠tico se habr√° obtenido tu PK, lo que permitir√≠a mover los fondos de forma justa.</p>
<p><strong>Pero, ¬øqu√© suceder√≠a si tuvi√©ramos un esquema de verificaci√≥n de firmas seguro frente a un ataque cu√°ntico?</strong></p>
<p>Aqu√≠ es donde entran en juego peque√±os cambios, espec√≠ficamente en la parte de validaci√≥n y no de ejecuci√≥n, con las mejoras en Starknet y con la ayuda de AA nativo, est√° implementando para prepararse para el futuro. Una posibilidad ser√≠a el uso de Lattice o Kyber, aunque el futuro no est√° escrito, as√≠ que ha llegado el momento de ver c√≥mo se genera la parte de la EC.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-en-cairo---stark-curve"><a class="header" href="#ec-en-cairo---stark-curve">EC en Cairo - STARK Curve</a></h1>
<p>Como hemos visto en cap√≠tulos anteriores, en el contexto de los sistemas criptogr√°ficos, la elecci√≥n de la curva el√≠ptica adecuada es de suma importancia. En este caso, se utiliza una variante de EC la cual ha sido especialmente dise√±ada y optimizada para su aplicaci√≥n en el entorno de Starknet.</p>
<p>La STARK Curve <a href="https://github.com/starkware-libs/cairo-lang/blob/361fe32d5930db340ea78fe05aedfe706f6c9405/src/starkware/cairo/common/ec.cairo"><strong>(EC.cairo)</strong></a> se define mediante la ecuaci√≥n:</p>
<p><img src="./assets/stark_curve.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Los valores espec√≠ficos de <code>Œ±</code>, <code>Œ≤</code> y <code>p</code> utilizados en esta curva han sido cuidadosamente seleccionados para proporcionar propiedades criptogr√°ficas s√≥lidas y un rendimiento eficiente en el contexto de los contratos de cuenta nativos en Starknet.</p>
<p>En particular, los valores de <code>Œ±</code>, <code>Œ≤</code> (notese que es <code>œÄ</code> ‚ÄúPI‚Äù sin decimales usando 67 digitos) y <code>p</code> son los siguientes:</p>
<p><img src="./assets/stark_curve1.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Estos valores aseguran que la curva el√≠ptica Stark-friendly cumple con los requisitos de seguridad necesarios para su aplicaci√≥n en sistemas criptogr√°ficos.</p>
<p>Adem√°s se utiliza un punto generador <a href="https://docs.starkware.co/starkex/crypto/stark-curve.html">(G)</a> espec√≠fico asociado a esta curva. El punto generador <code>G</code> se define como:</p>
<p><img src="./assets/stark_curve_g.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Este punto generador desempe√±a un papel fundamental en el esquema de firmas digitales ECDSA, permitiendo la generaci√≥n de claves p√∫blicas, como aprendimos al momento de hablar del Generador de Claves.</p>
<p>La elecci√≥n de la curva el√≠ptica Stark-friendly y el punto generador <code>G</code> asociado a ella proporcionan una base s√≥lida y optimizada para la implementaci√≥n de esquemas criptogr√°ficos en el entorno de Starknet. Estos elementos garantizan la seguridad y eficiencia necesarias para la creaci√≥n de contratos de cuenta nativos y la verificaci√≥n de firmas digitales en el sistema.</p>
<p>Si desea probar y adentrarse en el despliegue de cuentas en Starknet, o si est√° interesado en aprender c√≥mo se generan y calculan off-chain, y luego financiar esas cuentas para que los contratos de cuenta se autodesplieguen, le animamos a seguir los ejercicios oficiales de <a href="https://github.com/starknet-edu/starknet-accounts/blob/answers/ES%20README.md"><strong>Starknet-Edu Account</strong></a> o las <a href="https://github.com/Nadai2010/Nadai-StarknetEs-Guia-Cairo1#configuraci%C3%B3n-de-una-cuenta"><strong>Gu√≠as Completas Cairo 1</strong></a> proporcionadas por <a href="https://twitter.com/StarkNetEs">Starknet-Es</a> para realizar pruebas reales.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-braavos---secp256r1"><a class="header" href="#my-braavos---secp256r1">My Braavos - Secp256r1</a></h1>
<p>Comencemos explorando un dato interesante relacionado con la curva el√≠ptica vista en cap√≠tulos anteriores, la <code>secp256k1</code>. En este contexto, la <code>k</code> hace referencia a <a href="https://es.wikipedia.org/wiki/Neal_Koblitz"><strong>Koblitz</strong></a>, un destacado matem√°tico cuyas contribuciones fueron fundamentales para el desarrollo de la criptograf√≠a y la teor√≠a de n√∫meros.</p>
<p>Por otro lado, en el caso de <code>secp256r1</code>, la <code>r</code> significa <code>random</code>, resaltando el √©nfasis en el proceso de selecci√≥n aleatoria de par√°metros utilizado en esta curva el√≠ptica.</p>
<p>Braavos ha incorporado la firma y validaci√≥n de transacciones utilizando <code>secp256r1</code>, lo que brinda una excelente experiencia al usuario final al permitir transacciones con firma biom√©trica directamente en el dispositivo del usuario, a√±adiendo as√≠ un nivel adicional de seguridad. Puedes encontrar m√°s detalles sobre esta implementaci√≥n en el <a href="https://braavos.app/account-abstraction-security-pyramid/">blog de Braavos</a>, donde presentan una interesante Pir√°mide de Seguridad AA.</p>
<p><img src="./assets/Mybraavos.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Podemos ver en la c√∫spide de la pir√°mide al Multi-Signer (3FA). El Multi-Signer combina la protecci√≥n de la frase de recuperaci√≥n (seed phrase) en la extensi√≥n del navegador y el Hardware Signer o Protected Signer utilizando el dispositivo m√≥vil.</p>
<p>Ahora se requieren dos firmas de dos claves diferentes para ejecutar la transacci√≥n en la cadena, obteniendo una autenticaci√≥n de 3FA:</p>
<ul>
<li><strong>Algo que sabemos:</strong> la clave derivada de tu frase de recuperaci√≥n en la extensi√≥n del navegador.</li>
<li><strong>Algo que tenemos:</strong> tu dispositivo m√≥vil.</li>
<li><strong>Algo que somos:</strong> tu huella dactilar o identificaci√≥n biom√©trica facial.</li>
</ul>
<p>Cabe destacar que aunque se ha agregado otro firmante, no se ha a√±adido otra seed phrase, esto tambi√©n tiene el beneficio adicional de alejarse de las seed phrase a una mejor seguridad en los dispositivos m√≥viles/computadoras port√°tiles modernas, y seguridad superior cuando el dispositivo del usuario admite un chip de seguridad dedicado, como el <a href="https://cloud.google.com/blog/products/identity-security/titan-in-depth-security-in-plaintext">elemento seguro Titan de Android</a> o <a href="https://support.apple.com/es-us/guide/security/sec59b0b31ff/web">Enclave Secure de Apple</a>, etc.</p>
<p>Este chip Secure Enclave/Titan es un subsistema dedicado y aislado, totalmente separado del procesador de aplicaciones que puede generar claves privadas y mensajes de signo. Genera las teclas utilizando un generador interno de n√∫meros aleatorios verdaderos <a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator"><strong>(TRNG)</strong></a> y firma mensajes a trav√©s de la curva el√≠ptica <code>secp256r1</code> a trav√©s de su acelerador interno de claves p√∫blicas <a href="https://www.rambus.com/security/crypto-accelerator-cores/pka-ip-28/"><strong>(PKA)</strong></a>. Las claves privadas nunca abandonan el sistema seguro y son desconocidas / inaccesibles para cualquier persona, ni siquiera para el usuario o para la aplicaci√≥n en s√≠.</p>
<p>Esto significa que incluso si el n√∫cleo del procesador de la aplicaci√≥n del dispositivo se ve comprometido, <strong>¬°Nuestras claves se mantendr√°n seguras!</strong></p>
<p><img src="./assets/Enclave.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Vemos que esta implementaci√≥n de la firma ECDSA <code>secp256r1</code> en Cairo no es nativa, lo que significa que no tiene un Builtin dedicado nativo, esto puede llevar a un alto costo de gas al validar la firma. Sin embargo, Braavos es uno de los que han adoptado esta maravillosa novedad y est√° trabajando en mejorar la eficiencia de este proceso.</p>
<p>Adem√°s, aprovechando la funcionalidad de Multi-Call incorporada, los usuarios pueden agrupar m√∫ltiples transacciones en una √∫nica transacci√≥n at√≥mica. Esto no solo acelera y reduce los costos de las transacciones, sino que tambi√©n permite a los usuarios aprobar la cantidad exacta que desean depositar, lo cual mejora la seguridad al eliminar la necesidad de <a href="https://hackernoon.com/erc20-infinite-approval-a-battle-between-convenience-and-security-lk60350r">aprobaci√≥n infinita</a></p>
<p>En cuanto a la <strong>gesti√≥n de firmantes</strong>, cuando se a√±ade un firmante adicional, como un Hardware Signer o Protected Signer, el firmante original basado en semillas ya no puede firmar transacciones, a menos que se solicite la eliminaci√≥n del firmante adicional y se regrese al firmante basado en semillas. <strong>Esta solicitud tiene un retraso de tiempo (actualmente de 4 d√≠as)</strong> para su procesamiento.</p>
<p>Por otro lado, la funci√≥n de multifirma permite configurar la cuenta en modo de multifirma (actualmente admite 2 de 2), lo que significa que ninguna transacci√≥n se ejecutar√° hasta que los 2 firmantes definidos en la cuenta firmen la transacci√≥n. La seed phrase puede solicitar la desactivaci√≥n de la multifirma, pero esto <strong>tambi√©n tiene un retraso de tiempo (actualmente 4 d√≠as)</strong> antes de que se haga efectiva.</p>
<p>Vemos la importancia de las firmas y como vimos en el contexto del PQS, entendemos la relevancia de poder modificar nuestros esquemas de verificaci√≥n de firmas, como la utilizaci√≥n de Lattice o Kyber, por ejemplo. Ahora, centr√©monos en aprender c√≥mo creamos una Stark Key para StarkEx, el motor de escalabilidad de Starknet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creaci√≥n-de-una-stark-key-en-starkex"><a class="header" href="#creaci√≥n-de-una-stark-key-en-starkex">Creaci√≥n de una Stark Key en StarkEx</a></h1>
<p>Es importante comprender c√≥mo <a href="https://mirror.xyz/dashboard/edit/KJVQJ6X6wvbf6ps1oy96zpE3TztWyhSIDZd2IHu5NuI">StarkEx</a> se comunica con otras billeteras en t√©rminos de firmas, y c√≥mo mantiene todo el motor de transacciones y pruebas STARKs en su interior.</p>
<p>StarkEx ofrece soluciones altamente especializadas para diferentes aplicaciones que deseen construir sobre su servicio, y esto es parte de lo que StarkWare, como compa√±√≠a, proporciona a grandes empresas o cualquier otra entidad que desee aprovechar su conjunto de profesionales y servicios adaptables.</p>
<p>Aplicaciones populares como Sorare, Rhino y Apex Pro, por ejemplo, aprovechan las soluciones ofrecidas por StarkWare. Estas aplicaciones espec√≠ficas se construyen sobre el marco de Starknet. Si bien no profundizaremos en los detalles espec√≠ficos de estas aplicaciones aqu√≠, se recomienda visitar la <a href="https://layer2es.notion.site/39d63a8af9ca4524a7237b1f2456e745">Biblioteca de Layer 2 en Espa√±ol</a> para obtener informaci√≥n m√°s detallada sobre cada una de ellas y comprender mejor c√≥mo se integran en las soluciones de escalado de capa 2 de Ethereum.</p>
<p>Para utilizar StarkEx y asociar tu cuenta de MetaMask u otra billetera a Starknet, es necesario crear una Stark Key. StarkEx admite diferentes tipos de billeteras y m√©todos para crear esta clave, dependiendo de c√≥mo se utilizar√° posteriormente. A continuaci√≥n, se detallan las opciones disponibles:</p>
<h2 id="billeteras-compatibles-con-bip32"><a class="header" href="#billeteras-compatibles-con-bip32">Billeteras compatibles con BIP32</a></h2>
<p>Si est√°s utilizando una billetera compatible con <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki"><strong>BIP32</strong></a>, como Ledger, se recomienda seguir el EIP-2645. Este est√°ndar describe una ruta denominada <code>starkPath</code> y un algoritmo de derivaci√≥n de clave que utiliza esta ruta para obtener la <code>starkPrivateKey</code>.</p>
<p>La <code>starkPath</code> est√° compuesta por cuatro par√°metros pasados y dos par√°metros internos, y sigue la siguiente estructura:</p>
<p><code>m/purpose'/layer'/application'/ethAddress1'/ethAddress2'/index</code></p>
<p>Los par√°metros externos pasados son los siguientes:</p>
<ul>
<li><strong>Purpose:</strong> el n√∫mero de EIP correspondiente (en este caso, 2645).</li>
<li><strong>Layer:</strong> se utiliza para diferenciar entre tecnolog√≠as y se calcula como <code>sha256(layer) &amp; ((1 &lt;&lt; 31) - 1))</code>. En el contexto de StarkEx, el valor es <code>579218131</code> seg√∫n lo descrito en el EIP-2645.</li>
<li><strong>Application:</strong> sirve para diferenciar entre aplicaciones y se calcula como: <code>sha256(application_name) &amp; ((1 &lt;&lt; 31) - 1))</code>.</li>
<li><strong>Index:</strong> permite tener m√∫ltiples claves por direcci√≥n de Ethereum.</li>
</ul>
<p>Los par√°metros internos usados son los siguientes:</p>
<ul>
<li><strong>ethAddress1:</strong> Los 31 LSB de la direcci√≥n Ethereum del usuario, es decir, <code>(ethAddress &amp; 1 &lt;&lt; 31) - 1</code></li>
<li><strong>ethAddress2:</strong> Los 31 LSB siguientes de la direcci√≥n Ethereum del usuario, es decir, <code>(ethAddress &gt;&gt; 31) &amp; 1 &lt;&lt; 31) - </code>.</li>
</ul>
<p>Adem√°s, es importante que las billeteras compatibles con BIP32 mantengan un estado persistente en relaci√≥n con su propia direcci√≥n de Ethereum.</p>
<h2 id="billeteras-no-compatibles-con-bip32"><a class="header" href="#billeteras-no-compatibles-con-bip32">Billeteras NO compatibles con BIP32</a></h2>
<p>Si est√°s utilizando una billetera que no es compatible con BIP32, como MetaMask, se recomienda seguir el siguiente proceso:</p>
<ol>
<li>El usuario firma un mensaje utilizando su clave privada de Ethereum a trav√©s de MetaMask u otra billetera similar. Se recomienda utilizar el est√°ndar  IP-712 para brindar transparencia al usuario durante el proceso de firma. Es importante que el mensaje incluya una advertencia, indicando al usuario que so1lo debe firmarlo si proviene de un dominio espec√≠fico.</li>
<li>La firma <code>(r, s, v)</code> se utiliza como entrada para el algoritmo de derivaci√≥n de clave, que generar√° la <code>starkPrivateKey</code>. Para realizar este c√°lculo, puedes utilizar la biblioteca <a href="https://www.npmjs.com/package/@starkware-industries/starkware-crypto-utils">StarkEx Crypto SDK</a>. Primero, llama a la funci√≥n <code>getPrivateKeyFromEthSignature</code> para obtener la clave privada a partir de la firma, y luego utiliza la funci√≥n <code>privateToStarkKey</code> para calcular la <code>StarkKey</code>.</li>
</ol>
<p>Al seguir estos pasos, podr√°s crear una Stark Key asociada a tu cuenta de MetaMask u otra billetera compatible. Esta clave te permitir√° interactuar con StarkEx y otras aplicaciones dentro del ecosistema de Starknet, realizar transacciones seguras y aprovechar las funcionalidades ofrecidas por esta plataforma.</p>
<p><img src="./assets/Stark_Key.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-y-funciones-hash"><a class="header" href="#starknet-y-funciones-hash">Starknet y Funciones Hash</a></h1>
<p>En cap√≠tulos anteriores aprendimos la importancia de las firmas, el poder de AA y la asociaci√≥n de los hash dentro del ecosistema de Starknet y StarkEx. Ahora, profundicemos en c√≥mo se utilizan y los diferentes tipos de hash que podemos encontrar.</p>
<h2 id="dominio-y-rango"><a class="header" href="#dominio-y-rango">Dominio y rango</a></h2>
<p>Todas las salidas de las funciones de hash se mapean eventualmente a elementos en <code>ùîΩ‚Çö</code> con <code>p = 2¬≤‚Åµ¬π + 17 ‚ãÖ 2¬π‚Åπ¬≤ + 1</code> como vimos en la Stark Curve.</p>
<p>Las funciones hash son componentes clave en las especificaciones de Starknet, y se utilizan para mapear las salidas de los c√°lculos a elementos en el campo finito <code>ùîΩ‚Çö</code>. A continuaci√≥n, explicaremos las tres funciones hash utilizadas en Starknet de manera m√°s clara:</p>
<p><img src="./assets/Stark_func_hash.png" alt="graph" /></p>
<div align="center">
<em>Ciclo completo de una firma y validaci√≥n de una trnasacci√≥n</em>
</div>
<ol>
<li><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#starknet_keccak"><strong>sn_keccak:</strong></a> Esta funci√≥n hash se basa en el algoritmo KECCAK, que es una familia de funciones hash criptogr√°ficas como vimos antes. Su dominio es el conjunto de cadenas de bits compuestas por ceros y unos <code>{0,1}*</code> y su rango es el campo finito <code>ùîΩ‚Çö</code> La funci√≥n toma una cadena de bits como entrada y produce una salida en el campo finito <code>ùîΩ‚Çö</code>.</li>
<li><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#pedersen_hash"><strong>Pedersen:</strong></a> La funci√≥n hash Pedersen es una funci√≥n hash computacionalmente segura que se utiliza en la construcci√≥n de criptograf√≠a de compromiso cero y otras primitivas criptogr√°ficas. Su dominio es el conjunto de pares de elementos del campo finito <code>ùîΩ¬≤p</code>, donde <code>p</code> es un n√∫mero primo, y su rango es el campo finito <code>ùîΩp</code>. La funci√≥n toma un par de elementos del campo finito <code>ùîΩ¬≤p</code> como entrada y produce una salida en el campo finito <code>ùîΩp</code>.</li>
<li><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#poseidon_hash"><strong>Poseidon:</strong></a> La funci√≥n hash Poseidon es una funci√≥n hash criptogr√°fica. Su dominio es un conjunto de elementos del campo finito <code>ùîΩp</code>, que incluye el cero y los elementos inversos multiplicativos, y su rango tambi√©n es el campo finito <code>ùîΩp</code>. La funci√≥n toma un conjunto de elementos del campo finito <code>ùîΩp</code> como entrada y produce una salida en el campo finito <code>ùîΩp</code>.</li>
</ol>
<p>Las funciones de hash mencionadas son a√±adidas como <a href="https://mirror.xyz/0x7D1c14939AcEE5ca141c8beDF3474AFBf3884041/RTgQnMxeVGRCczih1pGXKy2KGFcU_xmf2NMx52wDgH0"><strong>Builtin</strong></a> (AIR integradas espec√≠ficas de aplicaciones), que se utilizan como herramientas adicionales en el protocolo para garantizar la seguridad y la integridad de las transacciones y los datos.</p>
<p>Estas funciones hash desempe√±an un papel fundamental en las operaciones de Starknet al garantizar la integridad y seguridad de los c√°lculos realizados en el sistema.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak-starknet"><a class="header" href="#keccak-starknet">Keccak Starknet</a></h1>
<p>Keccak en Starknet es una implementaci√≥n espec√≠fica de la funci√≥n hash <code>Keccak256</code> adaptada para su uso en la red Starknet. Proporciona un m√©todo confiable y eficiente para calcular hashes dentro del entorno de Starknet.</p>
<p>Generalmente denotado por <code>sn_keccak</code>, se define como los primeros <strong>250 bits del hash Keccak256</strong> (esto es simplemente <code>Keccak256</code> ampliado para ajustarse a un field element ‚Äúelemento de campo‚Äù).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pedersen-hash-starknet"><a class="header" href="#pedersen-hash-starknet">Pedersen Hash Starknet</a></h1>
<p>El <a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#pedersen_hash">Pedersen hash</a> es una funci√≥n hash criptogr√°fica utilizada en criptograf√≠a propuesta por Torben Pedersen en 1991.</p>
<p>Uno de los aspectos interesantes del <a href="https://en.wikipedia.org/wiki/Commitment_scheme">esquema de compromiso de Pedersen</a> es su propiedad homom√≥rfica, que permite realizar la adici√≥n entre dos compromisos. En otras palabras, dados dos mensajes <code>m‚ÇÅ</code> y <code>m‚ÇÇ</code>, y sus respectivas aleatoriedades <code>r‚ÇÅ</code> y <code>r‚ÇÇ</code>, el Pedersen hash permite combinarlos de manera segura.</p>
<p>La funci√≥n Pedersen Hash utilizada en Starknet es resistente a colisiones para entradas de longitud fija, siempre y cuando la funci√≥n de codificaci√≥n subyacente sea inyectiva. Una funci√≥n inyectiva asigna elementos distintos de su dominio a elementos distintos de su codominio, esto hace que el Pedersen hash sea resistente a ciertos tipos de ataques, como colisiones y preim√°genes.</p>
<p>Sin embargo, es importante destacar que la implementaci√≥n y el contexto en el que se utilice esta funci√≥n pueden influir en su resistencia. Para obtener m√°s informaci√≥n se recomienda realizar una lectura sobre <a href="https://research.nccgroup.com/2023/03/22/breaking-pedersen-hashes-in-practice/">Pedersen hashes in Practice</a>.</p>
<p>En Starknet, se utiliza la EC amigable STARK curve sobre el campo finito <code>ùîΩ‚Çö</code> para calcular el Pedersen hash de manera eficiente y segura.</p>
<p><img src="./assets/Pedersen_Starknet.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<ul>
<li>Œ± = 1</li>
<li>Œ≤ = 31415926535897932384626433832795028841971693993751058209749 44592307816406665</li>
</ul>
<p>Los par√°metros <code>Œ±</code> y <code>Œ≤</code> de la curva son importantes en t√©rminos de seguridad y eficiencia en los algoritmos utilizados en la construcci√≥n del Pedersen hash y los protocolos de ZKP o basados en STARK.</p>
<p>Dada una entrada <code>(a, b) ‚àà ùîΩ¬≤p</code>, se divide en <code>alow</code>, <code>ahigh</code>, <code>blow</code> y <code>bhigh</code>, donde la parte <code>low</code> consiste en los <strong>248 bits menos significativos del elemento</strong> y la parte <code>high</code> consiste en los <strong>4 bits m√°s significativos del elemento.</strong> El c√°lculo del Pedersen hash se define de la siguiente manera:</p>
<p><img src="./assets/Pedersen_Starknet1.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>En esta f√≥rmula, <code>[P]x</code> denota la coordenada <code>x</code> del punto <code>P</code>. Para calcular el hash, se realiza una combinaci√≥n lineal de los puntos <code>P0, P1, P2 y P3</code>, ponderados por los valores <code>alow</code>, <code>ahigh</code>, <code>blow</code> y <code>bhigh</code>, respectivamente. Luego, se suma el punto <code>shift_point</code> y se extrae la coordenada <code>x</code> del resultado.</p>
<p>Los valores de las constantes <code>shift_point</code>, <code>P0</code>, <code>P1</code>, <code>P2</code> y <code>P3</code> se encuentran en el archivo <a href="https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/crypto/signature/fast_pedersen_hash.py">fast_pedersen_hash.py</a>. Este archivo contiene la implementaci√≥n espec√≠fica del algoritmo necesario para calcular el Pedersen hash.</p>
<p>No se trata de puntos en la EC en s√≠ misma, sino de valores espec√≠ficos que se han elegido para el c√°lculo del hash y tampoco est√°n relacionadas con la EC ni con el punto generador <code>G</code>, revise minuciosamente la informaci√≥n oficial en caso de querer hacer pruebas sobre Stark Curve o Hash en Starknet. Estas constantes se eligen de forma independiente para el c√°lculo del hash y se utilizan en combinaci√≥n con los valores de entrada para obtener el hash resultante.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poseidon-hash-starknet"><a class="header" href="#poseidon-hash-starknet">Poseidon hash Starknet</a></h1>
<p>La funci√≥n <strong>Poseidon hash</strong> es un <a href="https://www.poseidon-hash.info/">ZK-friendly Hashing</a>, pertenece a una familia de funciones hash dise√±adas para ser muy eficientes en circuitos algebraicos. Como tal, pueden ser muy √∫tiles en sistemas ZK proof como STARKs y otros.</p>
<p>Poseidon es una construcci√≥n de esponja basada en la permutaci√≥n Hades, la estrategia de dise√±o Hades se basa en dividir el proceso en diferentes rondas para garantizar la seguridad y eficiencia del algoritmo:</p>
<ul>
<li>En las primeras rondas, denominadas <code>Rf</code>, se aplican las <code>S-boxes</code> al estado completo. Las <code>S-boxes</code> son funciones no lineales que mezclan y transforman los datos. En esta etapa inicial, se busca lograr una alta dispersi√≥n de los bits en el estado.</li>
<li>Despu√©s de estas rondas iniciales, se llevan a cabo las rondas intermedias, denominadas <code>RP</code>. En cada ronda intermedia, se aplica √∫nicamente una <code>S-box</code>, mientras que el resto del estado permanece sin cambios, es decir, se utiliza una funci√≥n identidad en lugar de las <code>S-boxes</code> faltantes. Esta simplificaci√≥n reduce el costo computacional y la complejidad del algoritmo.</li>
<li>Finalmente, en las √∫ltimas rondas, nuevamente se utilizan las <code>S-boxes</code> para el estado completo. Estas rondas finales, al igual que las rondas iniciales, permiten obtener una mezcla y transformaci√≥n adicional de los datos.</li>
</ul>
<p>Para una revisi√≥n m√°s profunda sobre su integridad en sistema de Proof pueden revisar <a href="https://eprint.iacr.org/2019/458.pdf">POSEIDON: A New Hash Function for Zero-Knowledge Proof Systems (Updated Version)</a>.</p>
<p>La versi√≥n de <strong>Poseidon</strong> utilizada en Starknet se basa en una permutaci√≥n de estado de tres elementos.</p>
<p>El campo <strong>ùîΩ</strong>, sobre el que se definen las declaraciones aritm√©ticas que utilizan Poseidon. A menudo es determinado por el sistema de prueba ZK. Lo m√°s probable es que sea un subgrupo de primer orden del grupo de puntos de una curva el√≠ptica. Poseidon mapea secuencias de elementos <strong>ùîΩ</strong> a una secuencia de longitud fija de elementos <strong>ùîΩ</strong>.</p>
<p>A continuaci√≥n, se define el <strong>Poseidon hash</strong> de hasta 2 elementos, y tambi√©n se menciona una versi√≥n que admite un n√∫mero arbitrario de entradas.</p>
<p><img src="./assets/Poseidon_Starknet.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashing-de-array-matrices"><a class="header" href="#hashing-de-array-matrices">Hashing de Array (matrices)</a></h1>
<p>En este cap√≠tulo, explicaremos c√≥mo se realizan los hashings de Arrays (matrices) utilizando las funciones Pedersen y Poseidon en el contexto de Starknet. Estas operaciones son fundamentales para garantizar la integridad y seguridad de los c√°lculos realizados en el sistema.</p>
<p>El hashing de un array implica aplicar la funci√≥n de hash correspondiente a cada elemento del array, de manera secuencial o iterativa. Esto permite resumir y representar de manera compacta la informaci√≥n contenida en el array, independientemente de su longitud o contenido espec√≠fico.</p>
<p>El hashing de un array es √∫til en muchas aplicaciones, como la verificaci√≥n de integridad de datos, la indexaci√≥n eficiente de informaci√≥n y la identificaci√≥n √∫nica de elementos.</p>
<h2 id="pedersen"><a class="header" href="#pedersen">Pedersen</a></h2>
<p>La funci√≥n hash Pedersen, denotada como <code>h</code>, se utiliza para calcular el hash de un array de elementos de campo. Consideremos un arreglo <code>a‚ÇÅ</code>, <code>a‚ÇÇ</code>, ..., <code>a‚Çô</code> que contiene <code>n</code> elementos. La definici√≥n de <code>h(a‚ÇÅ a‚ÇÇ, ..., a‚Çô)</code> es la siguiente:</p>
<ol>
<li>Comenzamos con un valor inicial de 0.</li>
<li>Aplicamos la funci√≥n de hash h al primer elemento a‚ÇÅ junto con el valor inicial. El resultado se convierte en el nuevo valor inicial.</li>
<li>Continuamos aplicando la funci√≥n de hash h al siguiente elemento a‚ÇÇ junto con el valor anteriormente obtenido. Nuevamente, el resultado se convierte en el nuevo valor inicial.</li>
<li>Repetimos este proceso hasta llegar al √∫ltimo elemento a‚Çô, aplicando la funci√≥n de hash en cada paso.</li>
<li>Finalmente, aplicamos la funci√≥n de hash h al √∫ltimo elemento an junto con el valor obtenido en el paso anterior.</li>
</ol>
<p>De esta manera, obtenemos el resultado final que representa el hash del array completo.</p>
<p><img src="./assets/Hash_Array.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Esta construcci√≥n en capas nos permite combinar de manera secuencial los elementos del array a medida que calculamos el hash. Cada iteraci√≥n agrega un nivel adicional de seguridad y complejidad al resultado final.</p>
<h2 id="poseidon"><a class="header" href="#poseidon">Poseidon</a></h2>
<p>La funci√≥n de hash Poseidon utiliza la permutaci√≥n Hades, representada por hades: <code>ùîΩ¬≥‚Çö‚ÜíùîΩ‚Çö</code>, con los par√°metros de Starknet. Dado un array <code>a‚ÇÅ</code>, <code>a‚ÇÇ</code>, ..., <code>a‚Çô</code> que contiene <code>n</code> field elements, definimos <code>poseidon(a‚ÇÅ, a‚ÇÇ, ..., a‚Çô)</code> como la primera coordenada de <code>H(a‚ÇÅ, a‚ÇÇ, ..., a‚Çô; 0, 0, 0)</code>,</p>
<ul>
<li><code>H(a‚ÇÅ, a‚ÇÇ, ..., a‚Çô; s‚ÇÅ, s‚ÇÇ, s‚ÇÉ)</code> se define de la siguiente manera:</li>
</ul>
<p><img src="./assets/Hash_Poseidon.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<ul>
<li><strong>Si n ‚â• 2:</strong> entonces <code>H(a‚ÇÅ,a‚ÇÇ,...,a‚Çô;s‚ÇÅ,s‚ÇÇ,s‚ÇÉ) = H(a‚ÇÉ, a‚ÇÑ, ..., a‚Çô;hades(s‚ÇÅ + a‚ÇÅ, s‚ÇÇ + a‚ÇÇ, s‚ÇÉ))</code>.</li>
<li><strong>Si n = 1:</strong> entonces <code>H(a‚ÇÅ; s‚ÇÅ, s‚ÇÇ, s‚ÇÉ) = hades(s‚ÇÅ + a‚ÇÅ, s‚ÇÇ + 1, s‚ÇÉ)</code>.</li>
<li><strong>Si n = 0:</strong> entonces <code>H(); s‚ÇÅ, s‚ÇÇ, s‚ÇÉ) = hades(s‚ÇÅ + 1, s‚ÇÇ, s‚ÇÉ)</code>.</li>
</ul>
<p>En resumen, la <code>funci√≥n poseidon(a‚ÇÅ,a‚ÇÇ,...,a‚Çô)</code> toma el array de field elements y aplica la permutaci√≥n Hades en capas. Cada iteraci√≥n de la permutaci√≥n combina los elementos del array en funci√≥n de los valores de  <code>s‚ÇÅ</code>, <code>s‚ÇÇ</code> y <code>s‚ÇÉ</code>, generando as√≠ una salida √∫nica. La primera coordenada de la salida final se considera el resultado de la funci√≥n de hash Poseidon.</p>
<p>Esta construcci√≥n en capas y la utilizaci√≥n de la permutaci√≥n Hades permiten obtener un hash seguro y resistente a ciertos ataques criptogr√°ficos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="s-t-arks"><a class="header" href="#s-t-arks">S-T-ARKs</a></h1>
<p>Ahora, adentr√©monos en una de las partes m√°s fascinantes del ecosistema, los <strong>STARKs</strong> <a href="https://starkware.co/stark/">(Scalable Transparent Argument of Knowledge)</a> que se basan en matem√°ticas modernas, la existencia de funciones hash criptogr√°ficas seguras y resistentes a las colisiones. Los STARKs presentan variados beneficios, entre los cuales tenemos:</p>
<ol>
<li>
<p><strong>Seguridad poscu√°ntica:</strong> los <strong>STARK</strong> son plausiblemente seguros frente a ordenadores cu√°nticos eficientes.</p>
</li>
<li>
<p><strong>Eficiencia concreta:</strong> el prover <strong>STARK</strong> es al menos <strong>10 veces m√°s r√°pido</strong> que el prover SNARK y el prover <a href="https://eprint.iacr.org/2017/1066.pdf">Bulletproofs</a>.</p>
<p>El verificador <strong>STARK</strong> es al menos <strong>2 veces m√°s r√°pido</strong> que el verificador <strong>SNARK</strong> y m√°s de <strong>10 veces m√°s r√°pido</strong> que el verificador <strong>Bulletproof</strong>.</p>
<p>A medida que StarkWare contin√∫e optimizando <strong>STARKs</strong> estos ratios probablemente mejorar√°n. Sin embargo, la longitud de una prueba <strong>STARK es ~100x mayor</strong> que la correspondiente <strong>SNARK</strong> y <strong>~20x mayor que BulletProofs</strong>.</p>
</li>
</ol>
<p>Puede encontrar una imagen animada de una comparativa con los datos expuestos sobre el proving time y verification time, tama√±o de la prueba, configuraci√≥n inicial y PQS entre STARKs y SNARKs, veremos c√≥mo cada una cumple con distintas propiedades que les permite ser recomendadas para variados usos.</p>
<p><img src="./assets//Stark_Prover.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Ahora que tenemos conceptos m√°s profundos sobre algunos aspectos de la criptograf√≠a, funciones hash y las operaciones detr√°s de cada una, veamos la importancia de la Integridad Computacional (CI), una propiedad fundamental para el d√≠a a d√≠a. Esta propiedad se refiere a la confianza en que la salida de un c√°lculo es correcta, permiti√©ndonos confiar en el saldo de una cuenta o en el monto de una factura en una tienda.</p>
<blockquote>
<p><strong>Pero, ¬øc√≥mo podemos garantizar esta integridad en un entorno digital donde no siempre podemos confiar en todas las partes involucradas?</strong></p>
</blockquote>
<p>Aqu√≠ es donde entra en juego la tecnolog√≠a STARK, que se basa en estas Validity Proof para garantizar que la computaci√≥n se realice correctamente, <strong>incluso si nadie est√° observando <code>‚ÄúINTEGRO‚Äù</code></strong>. STARKs utiliza matem√°ticas para lograr este objetivo y est√° dise√±ado para monitorear y garantizar la integridad de un gran c√°lculo realizado por un grupo de supercomputadoras poco confiables.</p>
<p>Las Validity Proofs son una herramienta crucial para garantizar la integridad y validez de los cambios realizados fuera de la cadena principal. Los sistemas de ZKP, en los que el prover posee informaci√≥n secreta que no es conocida por el verifier, son clave para las Validity Proofs. En el caso de Starknet, se trata de un Validity Rollup que utiliza STARKs.</p>
<p>Es importante tener en cuenta que ZK en Starknet, es una propiedad adicional que se utiliza para afirmar al probador que no tiene que revelar ninguna informaci√≥n incluida en el c√°lculo. Sin embargo, en el caso de Starknet como una capa 2 p√∫blica, los datos de transacci√≥n son p√∫blicos, lo que significa que no se ofrece privacidad como tal en transacciones, ocultar saldos u otras operaciones opacas, aunque los zk-STRAKs est√°n listas para eso.</p>
<p>En Starknet, el enfoque principal es el Validity Rollup, que se utiliza para probar la validez del c√°lculo computacional, a diferencia de otros protocolos que utilizan el t√©rmino <code>ZK Rollup</code>. Los STARKs en Starknet son Validity Proofs en lugar de ZK Proofs.</p>
<p>Los STARKs utilizan funciones de criptograf√≠a sim√©trica y hash criptogr√°ficos como componentes fundamentales en su construcci√≥n, las vulnerabilidades cu√°nticas conocidas en criptograf√≠a, como el algoritmo de Shor que puede factorizar n√∫meros enteros grandes y romper sistemas de criptograf√≠a asim√©trica basados en factorizaci√≥n, no afectan a las STARKs.</p>
<p><img src="./assets//Stark_1.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>En la imagen superior, se puede observar que las pruebas pueden basarse en principios de criptograf√≠a sim√©trica o asim√©trica, como aprendimos al principio del documento. Adem√°s, se pueden apreciar las diferentes propiedades de cada una en cuanto a escalabilidad, transparencia, seguridad en el futuro post-cu√°ntico o tama√±o de la prueba.</p>
<p>Como conclusi√≥n final antes de pasar a sus propiedades podemos ver para pruebas cortas como se recomienda utilizar <strong>Groth16</strong> o <strong>SNARKs</strong>, mientras que para todo lo dem√°s se sugiere <strong>STARK</strong>. Es importante destacar que este campo se encuentra en constante desarrollo y cada uno sigue optimizando sus propias soluciones. Tanto las <strong>STARKs</strong> como Starknet tambi√©n experimentar√°n optimizaciones para mejorar <strong>STARK</strong> y/o admitir diferentes tipos de pruebas. Un ejemplo de esto es como <a href="https://github.com/keep-starknet-strange">Keep-Starknet-Strange</a> el equipo detr√°s de <a href="https://github.com/keep-starknet-strange/garaga"><strong>Garaga</strong></a>, que est√° trabajando en diversas librer√≠as criptogr√°ficas como <a href="https://eprint.iacr.org/2019/953.pdf">Plonk</a>, <a href="https://eprint.iacr.org/2016/260.pdf">Groth16</a>, <strong>SNARK</strong>, entre otras.</p>
<p>Si desea obtener m√°s informaci√≥n sobre como los STARKs est√°n en diversas arquitectura y sus diversos casos de uso para asentar las bases dela criptograf√≠a moderna, recomendamos leer el articulo que sacamos para L2 Espa√±ol <a href="https://mirror.xyz/layer2es.eth/8TUEfpZPgl1u3-HyyGaUA0YMrFm8XSHfYtY6tfqFX7s">Profundizando en el Ecosistema STARKs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="propiedas-de-las-starks"><a class="header" href="#propiedas-de-las-starks">Propiedas de las STARKs</a></h2>
<p>En cap√≠tulos anteriores hemos visto c√≥mo diferenciar los tipos de pruebas seg√∫n su criptograf√≠a, as√≠ como la comparativa entre varias de ellas. Ahora veamos cu√°les son las dos propiedades esenciales en las pruebas y c√≥mo se pueden lograr, antes de pasar a la definici√≥n de STARK</p>
<ol>
<li><strong>Succintness:</strong> exigimos que nuestras pruebas y, en particular, el tiempo de verificaci√≥n sean sucintos, es decir, que sean √≥rdenes de magnitud m√°s peque√±os que el tiempo necesario para calcular nuestro programa. De lo contrario, no habr√≠a ninguna ventaja para el verificador en utilizar la prueba en lugar del c√°lculo original.</li>
<li><strong>Heur√≠stica Fiat-Shamir:</strong> este es un proceso mediante el cual podemos convertir una prueba interactiva en una no interactiva. Funciona proporcionando compromisos a los mensajes que formar√≠an la interacci√≥n y las funciones hash se utilizan como fuente de aleatoriedad.</li>
</ol>
<p>Uno de los protocolos que se utiliza en sistemas criptogr√°ficos, como los STARKs, para abordar el desaf√≠o de verificar eficientemente la correcci√≥n de grandes c√°lculos polinomiales es FRI (Fast Reed-Solomon Interactive Oracle Proofs of Proximity).</p>
<p>FRI utiliza c√≥digos de correcci√≥n de errores Reed-Solomon para permitir pruebas interactivas eficientes. Esto significa que el probador puede proporcionar una prueba corta de la correcci√≥n del c√°lculo, mientras que el verificador puede verificar de manera eficiente la validez de la prueba. Este proceso interactivo permite realizar pruebas de proximidad, donde el verificador puede verificar de manera eficiente si el c√°lculo reclamado se acerca al resultado correcto sin tener que evaluar por completo todo el polinomio.</p>
<blockquote>
<p>El conjunto de operaciones matem√°ticas, bases criptogr√°ficas, FRI y otras propiedades, como Fiat-Shamir, permite que las STARKs logren seguridad cu√°ntica y escalabilidad, al tiempo que proporcionan una verificaci√≥n transparente y eficiente de c√°lculos complejos.</p>
</blockquote>
<p>Podemos decir entonces que los STARKs demuestran la correcta operaci√≥n de una m√°quina virtual al demostrar que la traza de ejecuci√≥n asociada es v√°lida con respecto al AIR dado. En t√©rminos generales, las trazas de ejecuci√≥n se organizan como tablas de n√∫meros, y el protocolo STARK demuestra que estos n√∫meros resuelven conjuntamente un sistema de polinomios.</p>
<p>As√≠ vemos c√≥mo algunas de estas propiedades, como <code>Succintness</code>, pueden venir de forma natural en las STARKs, y c√≥mo el principio de Fiat-Shamir permite realizar pruebas interactivas. Adem√°s, contar con FRI como correcci√≥n de errores ampl√≠a las capacidades y visi√≥n de las STARKs, as√≠ que ahora vayamos a su definici√≥n</p>
<h2 id="s--scalable"><a class="header" href="#s--scalable">S = Scalable</a></h2>
<p>Una de las principales ventajas de STARKs es que al trasladar un c√°lculo fuera de la cadena, se reducen de manera exponencial los costos de verificaci√≥n en la cadena de bloques. El proceso de creaci√≥n de una prueba fuera de la cadena tiene un costo similar al de solicitar a un √∫nico nodo de la cadena de bloques que realice el c√°lculo.</p>
<p>La producci√≥n de pruebas no resulta considerablemente m√°s costosa que la ejecuci√≥n del c√°lculo original, y la validaci√≥n de las pruebas es <strong>exponencialmente m√°s r√°pida</strong> que la ejecuci√≥n del c√°lculo original. Adem√°s, las pruebas son <strong>considerablemente m√°s cortas</strong> en tama√±o que el c√°lculo original.</p>
<p>Otra ventaja importante es que a medida que se incrementa la cantidad de c√≥mputo, su crecimiento es casi lineal. Esto la convierte en una opci√≥n ideal para procesar transacciones a gran escala.</p>
<p><img src="./assets//Stark_2.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Adem√°s, se puede aprovechar la capacidad de paralelizaci√≥n de pruebas por el prover y recursividad de los STARKs eficentes para mejorar significativamente la escalabilidad.</p>
<p><img src="./assets//Stark_3.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<h2 id="t--transparent"><a class="header" href="#t--transparent">T = Transparent</a></h2>
<p>La seguridad de las STARKs no depende de ceremonias de configuraci√≥n elaboradas que puedan generar residuos t√≥xicos criptogr√°ficos, como ocurre en otras tecnolog√≠as de pruebas.</p>
<p>El uso de STARKs que tienen una base matem√°tica compleja y que utilizan pseudoaleatoriedad proporciona un inicio de ceremonia transparente y elimina la necesidad de una configuraci√≥n de confianza inicial (trusted setup), lo que mejora la seguridad y confiabilidad general del sistema criptogr√°fico.</p>
<p>Una caracter√≠stica importante de las STARKs es su construcci√≥n basada en el trabajo de <a href="https://es.wikipedia.org/wiki/Silvio_Micali">Micali</a>. En esta construcci√≥n, la √∫nica criptograf√≠a necesaria para producir o validar una prueba corta <code>ùõë</code> es una <strong>funci√≥n hash criptogr√°fica</strong> <code>H</code>, como <code>SHA-256</code> o <code>Keccak</code>. La elecci√≥n de <code>H</code> se convierte en el √∫nico <strong>&quot;par√°metro global&quot;</strong> que todos los usuarios del sistema de prueba deben conocer, y <strong>esta elecci√≥n puede hacerse de manera p√∫blica, garantizando la transparencia de las pruebas criptogr√°ficas obtenidas a trav√©s de las STARKs.</strong></p>
<p>Sin embargo siempre comparamos STARKs con SNARKs o pruebas derivadas de criptograf√≠a asim√©trica como las <a href="https://eprint.iacr.org/2013/279.pdf">Pinocchio</a> de ECC, pero cada una tiene sus varientes y esquemas diversos, aunque para una explicaci√≥n m√°s clara cogeremos el ejemplo de <a href="https://medium.com/@VitalikButerin/zk-snarks-under-the-hood-b33151a013f6">VB en un art√≠culo sobre zk-SNARKs</a>.</p>
<p><img src="./assets//Stark_4.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Imaginemos que tenemos un par de puntos <code>P</code> y <code>Q</code>, donde <code>P * k = Q</code>, y tienes un punto <code>C</code>, entonces no es posible obtener <code>C * k</code> a menos que <code>C</code> est√© <strong>&quot;derivado&quot;</strong> de alguna manera que conozcas a partir de <code>P</code>. Esto puede parecer intuitivamente obvio, pero esta suposici√≥n en realidad no puede derivarse de ninguna otra suposici√≥n (por ejemplo, la dificultad del logaritmo discreto) que usualmente utilizamos al probar la seguridad de los protocolos basados en EC. Por lo tanto, los SNARKs se basan en una base un tanto m√°s fr√°gil que la ECC en general.</p>
<p>Supongamos que cae del cielo un par de puntos <code>(P, Q)</code>, donde <code>P * k = Q</code>, pero nadie conoce el valor de <code>k</code>. Ahora, supongamos que yo presento un par de puntos <code>(R, S)</code> donde <code>R * k = S</code>. Entonces, la suposici√≥n de conocimiento del extremo de la curva (KoE, por sus siglas en ingl√©s) implica que la √∫nica forma en que podr√≠a haber creado ese par de puntos es tomando <code>P</code> y <code>Q</code>, y multiplic√°ndolos por un factor <code>r</code> que <strong>solo yo conozco</strong>. Tambi√©n hay que tener en cuenta que, gracias a la magia de las parejas de curvas el√≠pticas, verificar que <code>R = k * S</code> no requiere conocer <code>k</code>; en su lugar, simplemente puedes comprobar si <code>e(R, Q) = e(P, S)</code>, donde e es una funci√≥n de emparejamiento de curvas el√≠pticas.</p>
<p>Hagamos algo m√°s interesante. Supongamos que caen del cielo diez pares de puntos: <code>(P_1, Q_1), (P_2, Q_2) ... (P_10, Q_10)</code>. En todos los casos, se cumple que <code>P_i * k = Q_i</code>, ahora, supongamos que te proporciono un par de puntos <code>(R, S)</code> donde <code>R * k = S</code>.</p>
<p><strong>¬øQu√© sabemos ahora?</strong> Que <code>R</code> es una combinaci√≥n lineal de la forma <code>P_1 * i_1 + P_2 * i_2 + ... + P_10 * i_10</code>, donde yo conozco los coeficientes <code>i_1, i_2 ... i_10</code>, es decir, la √∫nica forma de obtener un par de puntos <code>(R, S)</code> de esta manera es tomando algunos m√∫ltiplos de <code>P_1, P_2 ... P_10</code> y sum√°ndolos, y hacer el mismo c√°lculo con <code>Q_1, Q_2 ... Q_10.</code></p>
<p>Enrtonces tenemos que tener en cuenta que dado cualquier conjunto espec√≠fico de puntos <code>P_1‚Ä¶P_10</code> para los que puedas querer verificar combinaciones lineales, en realidad no puedes crear los puntos correspondientes <code>Q_1‚Ä¶Q_10</code> sin conocer el valor de <code>k</code>, y si conoces el valor de <code>k</code>, entonces puedes crear un par <code>(R, S)</code> donde <code>R * k = S</code> para cualquier <code>R</code> que desees, sin necesidad de crear una combinaci√≥n lineal.</p>
<p><strong>Por lo tanto, para que esto funcione, es absolutamente imperativo que quien cree esos puntos sea confiable y realmente elimine <code>k</code> una vez que haya creado los diez puntos.</strong></p>
<p>Se debe destacar la importancia de las ceremonias de ajuste inicial en ciertos casos, como en implementaciones de sistemas de votaci√≥n. En estos casos, es crucial tener en cuenta qui√©n ha sido el creador de los puntos y si existe alguna posibilidad de manipulaci√≥n o si se ha eliminado correctamente el valor de k. Esto es necesario para lograr transparencia y evitar depender de estas verificaciones. En este sentido, los STARKs se presentan como una soluci√≥n prometedora y <strong>EFICIENTE</strong>, ya que proporcionan una base s√≥lida que elimina la necesidad de confiar en dichas ceremonias de ajuste inicial.</p>
<h2 id="ark--argument-of-knowledge"><a class="header" href="#ark--argument-of-knowledge">ARK = Argument of Knowledge</a></h2>
<p>Los argumentos de conocimiento ‚ÄúARK‚Äù son llevados a cabo por el prover que opera fuera de la cadena principal. Este probador se encarga de ejecutar el c√°lculo requerido para la prueba, utilizando las entradas auxiliares necesarias, la realizaci√≥n de la prueba fuera de la cadena principal es clave, ya que debe garantizar la integridad y la confiabilidad del proceso.</p>
<p>La principal ventaja de esta metodolog√≠a es que permite una verificaci√≥n aut√©ntica y matem√°ticamente s√≥lida. Despu√©s de que el probador haya realizado el c√°lculo, puede proporcionar la prueba generada a cualquier computadora o entidad interesada para su verificaci√≥n, haciendo uso de ARK sto significa que cualquier sistema inform√°tico puede confirmar la validez de la prueba de manera independiente.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="starks-eficientes"><a class="header" href="#starks-eficientes">STARKS eficientes</a></h2>
<p>En este cap√≠tulo, lleg√≥ el momento de comprender c√≥mo los STARKs representan una versi√≥n m√°s eficiente de los <a href="https://en.wikipedia.org/wiki/Probabilistically_checkable_proof"><strong>(PCP)</strong></a>, un protocolo que permite establecer la exactitud de las declaraciones de <strong>CI</strong>, mediante una verificaci√≥n aleatoria local en una prueba larga. Este protocolo se lleva a cabo entre un prover <strong>PCP</strong> y un verificador <strong>PCP</strong>.</p>
<p>En esta versi√≥n, se han realizado ajustes para mejorar la cohesi√≥n y la fluidez del texto. Se ha utilizado un lenguaje m√°s claro y directo para explicar la relaci√≥n entre los STARKs y los PCP, as√≠ como su funci√≥n en la verificaci√≥n de declaraciones de informaci√≥n computacional.</p>
<p>El prover <strong>PCP</strong> produce una cadena de prueba <code>ùöø</code> que codifica el seguimiento de c√°lculo de la declaraci√≥n de <code>CI</code>, a pesar de que <code>ùöø</code> es m√°s larga que la traza de c√°lculo de pasos <code>T</code>. Sin embargo, la cadena de prueba <code>ùöø</code> tiene la propiedad especial de que puede ser validada a trav√©s de una prueba probabil√≠stica que lee solo una peque√±a parte de <code>ùöø</code>.</p>
<p>El verifier <strong>PCP</strong>, al recibir la misma declaraci√≥n de <strong>CI</strong> <code>(A, x, y, T)</code>, puede validar la cadena de prueba <code>ùöø</code> leyendo aleatoriamente unas pocas ubicaciones de <code>ùöø</code> y luego realizar una <strong>&quot;verificaci√≥n local&quot;</strong> econ√≥mica en los valores le√≠dos. El n√∫mero de ubicaciones de lectura puede ser una peque√±a constante, como 3, independientemente de la longitud de la traza de c√°lculo <code>T</code>.</p>
<p>Si la declaraci√≥n de CI es verdadera, el verifier siempre aceptar√°. Sin embargo, si la declaraci√≥n de CI es falsa, el verificador la rechazar√° con alta probabilidad, sin importar c√≥mo se haya elegido la cadena de prueba <code>ùöø</code>.</p>
<p><img src="./assets/Stark_Sudoku.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>En la imagen animada podemos ver un ejemplo de <strong>PCP</strong> con un conjunto de resticciones un sudoku y ahora veremos como los STARKs eficiente pueden mejorar la eficiencia de las <strong>PCP</strong> y <strong>MPCP</strong> con <strong>IOPs</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iops---interactive-oracle-proof"><a class="header" href="#iops---interactive-oracle-proof">IOPs - Interactive Oracle Proof</a></h1>
<p>Las Interactive Oracle Proof <a href="https://eprint.iacr.org/2016/116"><strong>(IOP)</strong></a> son un nuevo tipo de sistema de prueba que combina las propiedades clave de <strong>pruebas interactivas</strong> y <strong>PCP</strong>, las <strong>IOP</strong> permiten que un verifier est√© convencido de la exactitud de una declaraci√≥n al interactuar con un prover no confiable mientras lee solo algunos bits de los mensajes enviados por el prover. Las <strong>IOP</strong> se han vuelto muy prominentes en el dise√±o de sistemas de prueba eficientes en los √∫ltimos a√±os.</p>
<blockquote>
<p><strong>Las construcciones STARK eficientes se obtienen combinando IOP eficientes y funciones hash criptogr√°ficas. La IOP le confiere al STARK su escalabilidad, mientras que la funci√≥n hash le confiere al STARK su transparencia.</strong></p>
</blockquote>
<p>Las STARKs eficientes se basan en IOP, de manera informal, un prover y un verifier participan en un protocolo interactivo en el que, en cada ronda, el verifier env√≠a algo de aleatoriedad <code>ùõî·µ¢</code> al prover, y el prover responde con una proof larga <code>ùöø·µ¢</code>. Al final de la interacci√≥n, el verificador realiza una verificaci√≥n local aleatoria de todas las proof largas <code>(ùöø‚ÇÅ,ùöø‚ÇÇ,‚Ä¶)</code> enviadas por el prover a lo largo de la interacci√≥n.</p>
<p>Ahora, antes de sumergirnos en el mundo de los pasos de creaci√≥n de un STARKs y su eficiencia, es importante comprender qu√© es un polinomio, ya que desempe√±an un papel crucial en la construcci√≥n y verificaci√≥n de STARKs. Son utilizados para representar y manipular datos de manera eficiente, lo que permite lograr un alto nivel de compresi√≥n y optimizaci√≥n en el proceso de verificaci√≥n.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="polinomios"><a class="header" href="#polinomios">Polinomios</a></h2>
<p>Los polinomios son una poderosa herramienta algebraica que se utiliza en diversas ramas de las matem√°ticas y la f√≠sica. Estas expresiones algebraicas est√°n formadas por t√©rminos que contienen variables y coeficientes. Los t√©rminos son la suma o resta de monomios, que son productos de constantes y variables elevadas a exponentes enteros no negativos.</p>
<p>Un polinomio puede tener una o varias variables, y su grado est√° determinado por el exponente m√°s alto presente en los t√©rminos del polinomio. Por ejemplo, el polinomio <code>3x¬≤ - 2x + 1</code>  es un polinomio de grado 2, ya que el t√©rmino de mayor grado tiene un exponente de 2.</p>
<p>Los polinomios se pueden sumar, restar, multiplicar y dividir, y se emplean en ecuaciones algebraicas, c√°lculo, geometr√≠a y muchas otras ramas de las ciencias exactas.</p>
<p><strong>¬øPor qu√© no eval√∫a el verifier los propios polinomios?</strong></p>
<ul>
<li>Porque, en realidad, el prover no env√≠a todos los polinomios al verificador, si lo hiciera perder√≠amos la succintness, contienen m√°s informaci√≥n que nuestra declaraci√≥n original, por lo que el prover s√≥lo proporciona un compromiso con los polinomios.</li>
</ul>
<p><strong>¬øQu√© propiedades de los polinomios son importantes en este caso?</strong></p>
<ul>
<li>Los polinomios son buenos c√≥digos de correcci√≥n de errores.</li>
</ul>
<p>Si tenemos polinomios de grado <code>d</code> sobre un dominio de codificaci√≥n <code>D</code>, y dos mensajes <code>m‚ÇÅ</code> y <code>m‚ÇÇ</code>, entonces  <code>m‚ÇÅ</code> y <code>m‚ÇÇ</code> diferir√°n en <code>|D|-d</code> puntos. Esto es importante porque queremos que la diferencia entre una declaraci√≥n correcta y una incorrecta sea grande, de modo que sea f√°cil de encontrar.</p>
<p>Esto conduce a un buen muestreo, lo que ayuda a la sucintez, s√≥lo necesitamos muestrear unos pocos valores para estar seguros de que la probabilidad de error es lo suficientemente baja como para ser insignificante.</p>
<ul>
<li>Disponer de pruebas eficaces de lote cero mantiene la sucintez.</li>
</ul>
<p>Tener la capacidad de realizar pruebas de lote cero eficaces es fundamental. Esto nos permite demostrar de manera conjunta que un conjunto de elementos cumple con una determinada propiedad, en lugar de tener que probar cada elemento de forma individual, esta t√©cnica de prueba en lote nos permite lograr una mayor concisi√≥n y eficiencia en la verificaci√≥n.</p>
<p>Imaginemos que queremos demostrar que un polinomio de grado grande <code>P(x) (grado ~ 10 millones)</code> eval√∫a a <code>0</code> en los puntos <code>1...1 mill√≥n</code>, pero queremos hacerlo con una sola consulta.</p>
<p>Imaginemos que nuestra afirmaci√≥n es que <code>P</code> desaparece en estos puntos. Si el verifier s√≥lo utiliza el muestreo, el prover podr√≠a hacer trampas f√°cilmente proporcionando un punto que se eval√∫e como <code>0</code>, pero los otros <code>999.999</code> podr√≠an ser distintos de <code>0</code>.</p>
<h2 id="resolviendo-el-problema"><a class="header" href="#resolviendo-el-problema">Resolviendo el problema</a></h2>
<p>Consideremos un conjunto <code>S = 1...10‚Å∂</code></p>
<p>Definir <code>V</code> como el polinomio que se anula en estos puntos, es decir: <code>(x - 1)(x - 2)(x - 3)...</code> el grado de <code>V = tama√±o de S</code> y esto es beneficioso porque:</p>
<ol>
<li><code>P(x) = P'(x) ‚Ä¢ V(x)</code></li>
<li><code>Grado de P = Grado de P' - Tama√±o de S.</code></li>
</ol>
<p>La introducci√≥n de <code>V(x)</code> nos permite verificar en todo el dominio.</p>
<ul>
<li>Estos polinomios tienen una propiedad <strong>&quot;multiplicadora&quot;</strong>. Podemos <strong>&quot;envolver&quot;</strong> una restricci√≥n alrededor de un polinomio.</li>
</ul>
<p>Por ejemplo, si tenemos la restricci√≥n <strong>C</strong>, que indica que nuestra evaluaci√≥n siempre ser√° 0 o 1, podr√≠amos expresarla como <code>C(x) = x ‚Ä¢ (x - 1)</code>. Esto se podr√≠a interpretar como restringir una salida para que sea un booleano, lo cual es √∫til en t√©rminos de integridad computacional.</p>
<p>En lugar de tener <code>x</code> como un simple punto, podr√≠amos considerar la evaluaci√≥n de un  de un polinomio <code>P‚ÇÅ(x)</code> en un punto espec√≠fico, es decir, <code>C(P‚ÇÅ(x)) = P‚ÇÅ(x)‚Ä¢(P‚ÇÅ(x)-1)</code></p>
<p>Los grados de los polinomios resultantes de la multiplicaci√≥n son aditivos, por lo que el grado de <code>C(x) = 2 ‚Ä¢ grado de P‚ÇÅ(x)</code></p>
<p>Podemos afirmar que si <code>P‚ÇÅ(x)</code> cumple con esta restricci√≥n para nuestro conjunto <code>S</code>, entonces, como mencionamos anteriormente, existe un polinomio <code>P'(x)</code> tal que:</p>
<ul>
<li><code>C(P‚ÇÅ(x)) = P'(x) ‚Ä¢ V(x)</code></li>
</ul>
<p>Si <code>P‚ÇÅ(x)</code> no cumpliera con la restricci√≥n (por ejemplo, si para un valor de <code>x, P‚ÇÅ(x) = 93</code>), entonces no podr√≠amos encontrar esos polinomios, la igualdad no se cumplir√≠a y habr√≠a un residuo en la ecuaci√≥n anterior.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creando-un-stark"><a class="header" href="#creando-un-stark">Creando un STARK</a></h1>
<p>En los pr√≥ximos cap√≠tulos del Libro de L2 sobre StarkWare, despu√©s de haber explicado algunas propiedades importantes de los polinomios y su relevancia, exploraremos la creaci√≥n de un STARK desde sus fundamentos matem√°ticos m√°s profundos. Para obtener una comprensi√≥n completa de los procesos involucrados y c√≥mo se puede combinar un <code>PCP</code> con criptograf√≠a ligera para obtener un STARK, te recomendamos revisar la serie lanzada por Starkware, la cual ofrece una profundizaci√≥n m√°s detallada desde el inicio.</p>
<p>A continuaci√≥n os dejaremos los enlaces a cinco art√≠culos fundamentales traducidos al espa√±ol que complementar√°n tu aprendizaje:</p>
<ol>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Comienza%20el%20viaje.md">Comienza el Viaje</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Aritmetizaci%C3%B3n%20I.md">Aritmetizaci√≥n I</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Aritmetizaci%C3%B3n%20II.md">Aritmetizaci√≥n II</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Prueba%20de%20bajo%20grado.md">Pruebas de Bajo Grado</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Un%20marco%20para%20STARKs%20eficientes.md">Un Frameword para STARKs Eficientes</a></li>
</ol>
<p>Estos recursos adicionales te brindar√°n una visi√≥n m√°s completa y pr√°ctica del proceso de creaci√≥n de una STARK. Tambi√©n te recomendamos revisar los repositorios relacionados y los videos de creaci√≥n de una STARK en Pioneros Clases 3, un Basecamp descentralizado en Espa√±ol creado por Starknet, o el de ingl√©s impartido por Eli Ben-Sasson</p>
<p>Nos interesa la Integridad Computacional (CI), por ejemplo, saber que el programa de Cairo que escribiste se calcul√≥ correctamente.</p>
<ul>
<li>Tenemos que pasar por una serie de transformaciones desde el trazado de nuestro programa, hasta la prueba.</li>
<li>La primera parte de esto se llama aritmetizaci√≥n, y consiste en tomar nuestra traza y convertirla en un conjunto de polinomios.</li>
<li>Nuestro problema se convierte entonces en uno en el que el prover intenta convencer a un verificador de que el polinomio es de grado bajo.</li>
<li>El verificador est√° convencido de que el polinomio es de grado bajo si y s√≥lo si el c√°lculo original es correcto (salvo una probabilidad infinitesimalmente peque√±a).</li>
</ul>
<p><img src="./assets/Stark_5.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>El uso de la aletoriedad es muy importante para el prover y el verifier, mientras que el prover utiliza la aleatoriedad para alcanzar el conocimiento cero, el verificador utiliza la aleatoriedad al generar consultas al prover, para detectar trampas por parte del prover.</p>
<p>Gran parte del trabajo que se realiza al crear una prueba consiste en garantizar que sea sucinta y que pueda elaborarse y verificarse en un tiempo razonable. Por tanto, nuestro plan consistir√° en:</p>
<ul>
<li>Reformular la traza de ejecuci√≥n como un polinomio,</li>
<li>Extenderlo a un gran dominio,</li>
<li>Transformarlo, utilizando las restricciones polin√≥micas, en otro polinomio que se garantiza que es de grado bajo si y s√≥lo si la traza de ejecuci√≥n es v√°lida.</li>
<li>Queremos lograr una verificaci√≥n sucinta, en la que el verificador de la declaraci√≥n CI requiera exponencialmente menos recursos que los necesarios para la repetici√≥n ingenua.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aritmetizaci√≥n"><a class="header" href="#aritmetizaci√≥n">Aritmetizaci√≥n</a></h1>
<p>Tenemos dos pasos principales en este proceso:</p>
<ol>
<li>Generaci√≥n de una traza de ejecuci√≥n y restricciones polin√≥micas.</li>
<li>Transformar estos dos objetos en un √∫nico polinomio de bajo grado.</li>
</ol>
<p>En t√©rminos de interacci√≥n prover-verifier, realmente lo que ocurre es que entre ambos acuerdan de antemano cu√°les son las restricciones polin√≥micas.</p>
<p>A continuaci√≥n, el prover genera una traza de ejecuci√≥n y, en la interacci√≥n posterior, intenta convencer al verificador de que las restricciones polin√≥micas se cumplen en esta traza de ejecuci√≥n, sin que el verificador lo vea.</p>
<p>La traza de ejecuci√≥n es una tabla que representa los pasos del c√°lculo subyacente, donde cada fila representa un √∫nico paso y el tipo de traza de ejecuci√≥n que buscamos generar debe tener la caracter√≠stica especial de ser sucintamente comprobable:</p>
<ul>
<li>Cada fila puede ser verificada bas√°ndose s√≥lo en las filas que est√°n cerca de ella en la traza, y el mismo procedimiento de verificaci√≥n se aplica a cada par de filas.</li>
</ul>
<p>Por ejemplo, imaginemos que nuestra traza representa un total en ejecuci√≥n, con cada paso de la siguiente manera.</p>
<pre><code class="language-bash">                    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
                    ‚ïë  PASO  ‚ïë  IMPORTE  ‚ïë TOTAL ‚ïë
                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
                    ‚ïë   0    ‚ïë     0     ‚ïë   0   ‚ïë
                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
                    ‚ïë   1    ‚ïë     5     ‚ïë   5   ‚ïë
                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
                    ‚ïë   2    ‚ïë     2     ‚ïë   7   ‚ïë
                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
                    ‚ïë   3    ‚ïë     2     ‚ïë   9   ‚ïë
                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
                    ‚ïë   4    ‚ïë     3     ‚ïë   12  ‚ïë
                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
                    ‚ïë   5    ‚ïë     6     ‚ïë   18  ‚ïë
                    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
</code></pre>
<p>Si representamos la fila como <code>i</code> , y la columna como <code>j</code> , y los valores como <code>A·µ¢,‚±º</code> , podr√≠amos escribir algunas restricciones sobre esto de la siguiente manera:</p>
<ul>
<li><code>A‚ÇÄ,‚ÇÇ=0</code></li>
<li><code>‚àÄ1 &gt;= i &lt;= 5 : A·µ¢,‚ÇÇ ‚àí A·µ¢,‚ÇÅ ‚àí A·µ¢-‚ÇÅ,‚ÇÇ = 0</code></li>
<li><code>A‚ÇÖ,‚ÇÇ = 18</code></li>
</ul>
<p>Se trata de restricciones polin√≥micas lineales en <code>A·µ¢,‚±º</code></p>
<p>N√≥tese que aqu√≠ estamos consiguiendo cierta concisi√≥n porque podr√≠amos representar un n√∫mero mucho mayor de filas con s√≥lo estas 3 restricciones.</p>
<p>El sistema de restricciones aritm√©ticas define al menos dos tipos de restricciones sobre la traza de ejecuci√≥n algebraica:</p>
<ol>
<li><strong>Restricciones de contorno:</strong> al principio o al final del c√°lculo, un registro indicado tiene un valor determinado.</li>
<li><strong>Restricciones de transici√≥n:</strong> dos tuplas de estado consecutivas cualesquiera evolucionan de acuerdo con la funci√≥n de transici√≥n de estado. En conjunto, estas restricciones se conocen como representaci√≥n algebraica intermedia o AIR.</li>
</ol>
<p>Las STARKs avanzadas pueden definir m√°s tipos de restricciones para tratar con la memoria o con la consistencia de los registros dentro de un ciclo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polinomio-para-nuestra-traza"><a class="header" href="#polinomio-para-nuestra-traza">Polinomio para nuestra traza</a></h1>
<p>Siguiendo el cap√≠tulo anterior, en esta ocasi√≥n continuaremos definiendo un polinomio <code>f(x)</code> en el que los elementos de la traza de ejecuci√≥n se obtienen a trav√©s de  evaluaciones de <code>f</code> en potencias de alg√∫n generador <code>g</code>.</p>
<p>Recordemos que nuestro campo finito tiene generadores, los cuales utilizaremos para indexar los pasos de la traza. Para ello, consideraremos una secuencia de Fibonacci que nos permitir√° establecer restricciones espec√≠ficas, como la siguiente:</p>
<ul>
<li><code>‚àÄ x ‚àà {1,g¬≤,g¬≥...g‚Åµ‚Å∞‚Åπ}: f(g¬≤x) ‚Çã f(gx) ‚Çã f(x) = 0</code></li>
</ul>
<p>Esto restringe los valores entre las filas subsiguientes. Tambi√©n significa que los valores g son ra√≠ces de este polinomio.</p>
<p>Por lo tanto, podemos utilizar el enfoque que vimos anteriormente para proporcionar el polinomio de fuga utilizando el t√©rmino <code>(x - g‚Å±)</code> y a partir de √©l creamos la Composici√≥n Polinomial.</p>
<p>El hecho b√°sico sobre polinomios y sus ra√≠ces es que si <code>p(x)</code> es un polinomio, entonces <code>p(a)=0</code> para alg√∫n valor espec√≠fico a, si y s√≥lo si existe un polinomio <code>q(x)</code> tal que <code>(x-a)q(x)=p(x)</code>, y <code>deg(p)=deg(q)+1.</code></p>
<p>Esta expresi√≥n coincide con el polinomio de grado 2 como m√°ximo si nuestra traza de ejecuci√≥n ha sido correcta, es decir, ha obedecido a la restricci√≥n de paso que hemos definido.</p>
<p>Si la traza difiere de eso, entonces es poco probable que esta expresi√≥n produzca un polinomio de bajo grado.</p>
<h1 id="composici√≥n-polinomial"><a class="header" href="#composici√≥n-polinomial">Composici√≥n Polinomial</a></h1>
<p>El Polinomio de Composici√≥n en su traducci√≥n tambi√©n conocido como Composici√≥n Polinomial (CP), se realiza para demostrar eficazmente la validez del rastro de ejecuci√≥n, nos esforzamos por alcanzar los dos objetivos siguientes:</p>
<ol>
<li>Componer las restricciones sobre los polinomios de la traza para hacerlas cumplir en la traza.</li>
<li>Combinar las restricciones en un √∫nico polinomio (m√°s grande), denominado Composici√≥n Polinomial, de modo que se pueda utilizar una √∫nica prueba de grado bajo para atestiguar su grado bajo.</li>
</ol>
<h1 id="ampliando-el-polinomio"><a class="header" href="#ampliando-el-polinomio">Ampliando el polinomio</a></h1>
<p>Como hemos visto antes, los polinomios pueden utilizarse para construir buenos c√≥digos de correcci√≥n de errores, ya que dos polinomios de grado d, evaluados en un dominio considerablemente mayor que d, son diferentes en casi todas partes.</p>
<p>Observando esto, podemos extender la traza de ejecuci√≥n pensando en ella como una evaluaci√≥n de un polinomio en alg√∫n dominio, y evaluando este mismo polinomio en un dominio mucho mayor. Extendiendo de manera similar una traza de ejecuci√≥n incorrecta, se obtiene una cadena muy diferente, lo que a su vez hace posible que el verificador distinga entre estos casos utilizando un peque√±o n√∫mero de consultas.</p>
<h2 id="de-restricciones-polin√≥micas-al-problema-de-las-pruebas-de-bajo-grado"><a class="header" href="#de-restricciones-polin√≥micas-al-problema-de-las-pruebas-de-bajo-grado">De restricciones polin√≥micas al problema de las pruebas de bajo grado</a></h2>
<p>En general, si nuestro c√°lculo implica <code>N</code> pasos, la traza de ejecuci√≥n estar√° representada por polinomios de grado inferior a <code>N</code></p>
<ul>
<li><code>f(X) = c‚ÇÄ + c‚ÇÅX + c‚ÇÇX¬≤ +‚ãØ+ c…¥-‚ÇÅX·¥∫‚Åª¬π</code></li>
</ul>
<p>Los coeficientes <code>c·µ¢</code> est√°n en el campo <code>ùîΩ</code> y el l√≠mite <code>N</code> en el grado es t√≠picamente grande, quiz√° del orden de unos pocos millones. A pesar de ello, estos polinomios se denominan de bajo grado.</p>
<p>Esto se debe a que el punto de comparaci√≥n es el tama√±o del campo. Por interpolaci√≥n, toda funci√≥n sobre <code>ùîΩ</code> puede representarse mediante un polinomio.</p>
<p>La mayor√≠a de ellos tendr√°n un grado igual al tama√±o total del campo, por lo que, comparado con √©ste, <code>N</code> es realmente bajo.</p>
<p>Este tipo de funciones, coherentes con un polinomio de bajo grado, tambi√©n se conocen como c√≥digos <code>Reed-Solomon</code>.</p>
<p>Tras la generaci√≥n de la traza, el prover se compromete con ella. Recordemos que no queremos enviar los polinomios al verificador como un todo, pero necesitamos que el prover se comprometa con ellos.</p>
<p>En todo el sistema, los compromisos se ejecutan construyendo √°rboles de Merkle sobre las series de elementos de campo y enviando las ra√≠ces de Merkle al verificador.</p>
<p>Queremos que un verificador plantee al prover un n√∫mero muy reducido de preguntas y decida si acepta o rechaza la prueba con un alto nivel de precisi√≥n garantizado. Idealmente, al verificador le gustar√≠a pedir al prover que proporcione los valores en unos pocos lugares (aleatorios) en la traza de ejecuci√≥n, y comprobar que las restricciones polin√≥micas se mantienen para estos lugares.</p>
<p>Una traza de ejecuci√≥n correcta pasar√° naturalmente esta prueba.</p>
<p>Sin embargo, no es dif√≠cil construir una traza de ejecuci√≥n completamente err√≥nea (especialmente si sab√≠amos de antemano qu√© puntos se comprobar√≠an), que viole las restricciones s√≥lo en un punto de la traza √∫nico y, al hacerlo, llegar a un resultado completamente alejado y diferente. Identificar este fallo mediante un peque√±o n√∫mero de consultas aleatorias es altamente improbable.</p>
<p>Pero recuerda que los polinomios tienen algunas propiedades √∫tiles aqu√≠:</p>
<ul>
<li>Dos polinomios (diferentes) de grado <code>d</code> evaluados en un dominio considerablemente mayor que <code>d</code> son diferentes en casi todas partes.</li>
</ul>
<p>As√≠ que si tenemos un prover deshonesto, que crea un polinomio de bajo grado representando su traza (que es incorrecta en alg√∫n punto) y lo eval√∫a en un dominio grande, ser√° f√°cil ver que este es diferente al polinomio correcto.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pruebas-de-bajo-grado"><a class="header" href="#pruebas-de-bajo-grado">Pruebas de Bajo Grado</a></h1>
<p>Las pruebas de bajo grado son realmente el coraz√≥n del proceso de verificaci√≥n.</p>
<p>El supuesto de comprobaci√≥n de bajo grado establece la existencia de un verificador probabil√≠stico que comprueba si una funci√≥n f es de grado como m√°ximo d ‚â™ |ùîΩ|. El verificador debe distinguir entre los dos casos siguientes:</p>
<ol>
<li><strong>La funci√≥n <code>f</code> es igual a un polinomio de bajo grado:</strong> es decir, existe un polinomio <code>p(x)</code> sobre <code>ùîΩ</code>, de grado menor que <code>d</code>, que coincide con <code>f</code> en todas partes.</li>
<li><strong>La funci√≥n <code>f</code> est√° lejos de TODOS los polinomios de bajo grado:</strong> por ejemplo, necesitamos modificar al menos el <strong>10%</strong> de los valores de <code>f</code> antes de obtener una funci√≥n que concuerde con un polinomio de grado inferior a <code>d</code>.</li>
</ol>
<p>La aritmetizaci√≥n muestra que un prover honesto que trate con una afirmaci√≥n verdadera caer√° en el primer caso, mientras que un prover (posiblemente malicioso) que intente <strong>&quot;probar&quot;</strong> una afirmaci√≥n falsa caer√°, con alta probabilidad, en el segundo caso.</p>
<p>Otra forma de ver esto es que el polinomio de traza correcto combinado con las restricciones ser√° necesariamente de grado bajo, el grado proviene del n√∫mero de pasos en nuestra traza (probablemente unos pocos millones), y la combinaci√≥n de esto con los polinomios de restricci√≥n (probablemente &lt; 10).</p>
<p>En general, cabr√≠a esperar que los polinomios <strong>&quot;correctos&quot;</strong> tuvieran un grado de alrededor de <code>10‚Å∑</code> , mientras que un prover tramposo que eligiera puntos al azar del campo <code>ùîΩ</code> obtendr√≠a, tras la interpolaci√≥n, polinomios de grado comparable al tama√±o del campo, es decir, del orden de <code>2¬≤‚Åµ‚Å∂</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fri"><a class="header" href="#fri">FRI</a></h1>
<p>FRI son las siglas de <a href="https://eccc.weizmann.ac.il/report/2017/134/">Fast Reed-Solomon IOP of Proximity</a>, es un protocolo que establece que un polinomio comprometido tiene un grado limitado.</p>
<p>El <a href="https://book.starknet.io/chapter_10/fri.html"><strong>FRI</strong></a> es complejo y gran parte del procesamiento que lo compone est√° dise√±ado para que las pruebas sean factibles y sucintas. Tambi√©n hay mucho procesamiento involucrado con la protecci√≥n contra diversos tipos de ataques que podr√≠an ser realizados por el prover, y garantizar que todo se lleva a cabo en el conocimiento cero.</p>
<p>Su objetivo es encontrar si un conjunto de puntos se encuentran mayoritariamente en un polinomio de bajo grado y puede alcanzar una complejidad de prueba lineal y una complejidad de verificaci√≥n logar√≠tmica.</p>
<p>En general, hay 2 etapas : commit y query, contenidas en los siguientes pasos repetidos.</p>
<ol>
<li>El verifier env√≠a un n√∫mero aleatorio al prover.</li>
<li>El prover genera un nuevo polinomio.</li>
<li>El verifier genera los conjuntos puntuales de consultas y los env√≠a al prover.</li>
<li>El prover eval√∫a los valores polin√≥micos correspondientes.</li>
<li>El verifier realiza una comprobaci√≥n de validez.</li>
</ol>
<p>Aprendamos como FRI es un protocolo entre un probador y un verificador, que establece que una codeword dada pertenece a un polinomio de grado bajo.</p>
<p>El prover conoce expl√≠citamente este codeword, mientras que el verificador s√≥lo conoce su ra√≠z Merkle y las hojas de su elecci√≥n, suponiendo la validaci√≥n satisfactoria de las rutas de autenticaci√≥n que establecen la pertenencia de las hojas al Merkle Tree.</p>
<p>Una de las grandes ideas para los sistemas de pruebas de los √∫ltimos a√±os ha sido la t√©cnica de dividir y doblar. La idea es reducir una afirmaci√≥n a dos afirmaciones de la mitad de tama√±o. A continuaci√≥n, ambas afirmaciones se fusionan en una sola utilizando pesos aleatorios proporcionados por el verificador.</p>
<p>Despu√©s de muchos pasos, la afirmaci√≥n se ha reducido a una de tama√±o trivial que es verdadera si y s√≥lo si (modulo alguna degradaci√≥n de seguridad insignificante) la afirmaci√≥n original era verdadera.</p>
<p>El Verifier inspecciona los Merkle Tree (en concreto: pide al prover que proporcione las hojas indicadas con sus rutas de autenticaci√≥n) de rondas consecutivas para comprobar una relaci√≥n lineal simple.</p>
<p>Para los provers honestos, el grado de los polinomios representados tambi√©n se reduce a la mitad en cada ronda y, por tanto, es mucho menor que la longitud de la codeword. Sin embargo, para los provers maliciosos, este grado es uno menos que la longitud de la codeword. En el √∫ltimo paso, el prover env√≠a una codeword no trivial correspondiente a un polinomio constante.</p>
<p>Despu√©s de explorar los diferentes pasos en la creaci√≥n detr√°s de un STARKs y la importancia de las pruebas de integridad, es evidente que estas pruebas son fundamentales para garantizar la seguridad y confiabilidad de los sistemas del Futuro.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leve-introducci√≥n-cairo"><a class="header" href="#leve-introducci√≥n-cairo">Leve introducci√≥n Cairo</a></h1>
<p>Para concluir esta primera parte del L2 Book sobre Starkware, antes de adentrarnos en los pr√≥ximos temas sobre la arquitectura de Starknet y Cairo, haremos una breve introducci√≥n a Cairo y su relaci√≥n con la CVM (M√°quina Virtual de Cairo). En este contexto, es relevante comprender c√≥mo todos los pasos de un c√°lculo pueden ser representados mediante polinomios, utilizando lo que se conoce como la Representaci√≥n Algebraica Intermedia (AIR).</p>
<p>Los bloques de c√°lculo pueden ser representados como AIR y tienen la capacidad de combinarse entre s√≠, lo que se convierte en la base de Cairo. Para ilustrarlo mediante una analog√≠a con el hardware:</p>
<ul>
<li><strong>ASIC (AIR)</strong></li>
<li><strong>CPU (varias AIR)</strong></li>
</ul>
<p>El nombre <strong>Cairo</strong> deriva de una CPU construida a partir de AIRs:</p>
<ul>
<li><strong>(CPU-AIR, Oh genial -&gt; CAIRO)</strong></li>
</ul>
<p>Cairo es un lenguaje funcional de alto nivel, no determinista y Turing completo, que cuenta con un modelo de memoria basado en registros y un compilador que produce una tabla de pasos computacionales llamada traza.</p>
<blockquote>
<p>En los programas escritos en Cairo, se especifican los resultados que se consideran aceptables, no c√≥mo obtenerlos.</p>
</blockquote>
<p>En los cap√≠tulos anteriores, hemos visto c√≥mo, en el proceso de construcci√≥n de pruebas STARK, el prover utiliza esta traza para crear Representaciones Algebraicas Intermedias (AIRs). Posteriormente, estas AIRs se combinan y convierten en pruebas STARK.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusi√≥n"><a class="header" href="#conclusi√≥n">Conclusi√≥n</a></h1>
<p>Con esto, concluimos nuestro profundo viaje por el mundo de la criptograf√≠a, explorando la generaci√≥n de claves privadas y p√∫blicas, as√≠ como sus diversas implementaciones. Hemos aprendido c√≥mo Starknet y los esquemas de firmas pueden prevenir ataques criptoanal√≠ticos, y hemos visto c√≥mo las STARKs han sido dise√±adas desde su inicio para brindar seguridad matem√°tica frente a ataques cu√°nticos, siguiendo sus principios fundamentales.</p>
<p>Starknet est√° sentando las bases de la criptograf√≠a moderna y creando un ecosistema escalable, √≠ntegro y seguro por una de las mayores descentralizada como Ethereum, escalemos juntos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducci√≥n-parte-2"><a class="header" href="#introducci√≥n-parte-2">Introducci√≥n Parte 2</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arquitectura-starknet-y-cairo"><a class="header" href="#arquitectura-starknet-y-cairo">Arquitectura Starknet y Cairo</a></h1>
<p>Starknet es una soluci√≥n escalabilidad de de capa 2 para ETH que ofrece transacciones r√°pidas, seguras y de bajo costo. Funciona como un Validity Rollup (com√∫nmente conocido como Rollup de conocimiento cero) que utiliza sistemas criptogr√°ficos llamados STARKs para reducir los costos de computaci√≥n.</p>
<p>Starknet introduce una innovadora soluci√≥n de Capa 2 para ETH, que aprovecha la tecnolog√≠a de zk-STARKs para revolucionar la escalabilidad y seguridad. En este documento ofreceremos informaci√≥n sobre la estructura de Starknet y Cairo, en los primeros cap√≠tulos daremos una visi√≥n t√©cnica detallada de la arquitectura de la red Starknet y sus componentes clave <code>Sequencers</code>, <code>Provers</code> y <code>Nodes</code>. Estos actores trabajan en armon√≠a, impulsando el procesamiento eficiente de la red y asegurando la integridad de las transacciones. Aunque Starknet se encamina hacia la descentralizaci√≥n total, actualmente se enfoca en el desarrollo para alcanzar este objetivo final. </p>
<h2 id="caracter√≠sticas-generales-de-starknet"><a class="header" href="#caracter√≠sticas-generales-de-starknet">Caracter√≠sticas Generales de Starknet</a></h2>
<p>Veamos algunas car√°teristicas b√°sicas antes de pasar a componente y su arquitectura.</p>
<ul>
<li><strong>Bajos costos de transacci√≥n:</strong> Los costos de transacci√≥n en Starknet son significativamente inferiores a los de Ethereum. Con pr√≥ximas mejoras como Volition (disponibilidad de datos fuera de la cadena) y la implementaci√≥n de EIP 4844 en L1, se espera que estos costos disminuyan a√∫n m√°s.</li>
<li><strong>Plataforma amigable para desarrolladores:</strong> Starknet proporciona un entorno que empodera a los desarrolladores para construir aplicaciones descentralizadas utilizando STARKs y el lenguaje de programaci√≥n Cairo.</li>
<li><strong>Alto rendimiento y baja latencia:</strong> Las futuras versiones de Starknet tienen como objetivo aumentar el rendimiento de la red, reducir la latencia de las transacciones y disminuir los costos de las mismas.</li>
<li><strong>La Filosof√≠a de Starknet:</strong> La filosof√≠a de Starknet se centra en ser amigable para los desarrolladores. La red est√° dise√±ada con un claro enfoque en proporcionar a los desarrolladores una plataforma robusta, segura y poderosa para construir el futuro de la infraestructura y las aplicaciones descentralizadas.</li>
<li><strong>Rendimiento:</strong> Starknet ofrece mayor rendimiento, menor latencia y costos de transacci√≥n reducidos, facilitando as√≠ la creaci√≥n de aplicaciones intensivas en c√≥mputo.</li>
<li><strong>Cairo:</strong> El lenguaje de programaci√≥n central de Starknet, Cairo, se actualiza constantemente y se mejora para brindar a los desarrolladores las mejores herramientas para aprovechar las pruebas de validez y la tecnolog√≠a zk-STARKs.</li>
<li><strong>Enfoque en la comunidad:</strong> Starknet mantiene canales activos de comunicaci√≥n y retroalimentaci√≥n con la comunidad de desarrolladores a trav√©s de plataformas como Telegram y Discord.</li>
<li><strong>Creatividad:</strong> Starknet tiene como objetivo eliminar limitaciones y empoderar a los desarrolladores para construir el futuro de las aplicaciones descentralizadas. Permite crear cosas que nunca antes se pudieron construir debido a las limitaciones de la tecnolog√≠a subyacente.</li>
<li><strong>Herramientas:</strong> Starknet se compromete a proporcionar una amplia gama de herramientas de desarrollo, incluyendo SDKs para diversos lenguajes, un marco de pruebas e implementaci√≥n inspirado en Foundry (Protostar) y administradores de paquetes (Scarb).</li>
</ul>
<p>En la pr√≥xima secci√≥n, nos sumergiremos en la arquitectura de Starknet y sus componentes fundamentales para comprender c√≥mo construir aplicaciones web3 escalables. Te proporcionaremos un conocimiento profundo de los elementos clave de Starknet, lo que te permitir√° desarrollar e implementar dApps de manera eficiente. Comencemos con una breve descripci√≥n de los componentes fundamentales que desempe√±ar√°n un papel crucial en el funcionamiento de la red y asegurar√°n que el ciclo de las transacciones sea escalable, r√°pido y econ√≥mico.</p>
<h2 id="sequencers"><a class="header" href="#sequencers">Sequencers:</a></h2>
<p>Los Secuenciadores (Sequencers) son componentes esenciales de la red Starknet y juegan un papel central al actuar como puntos de entrada para las transacciones. Son comparables a los validadores en Ethereum, y los ZK Rollups tienen la capacidad √∫nica de delegar ciertas tareas de la red, como la agregaci√≥n y el procesamiento de transacciones, a entidades especializadas. Sin embargo, este proceso demanda recursos significativos debido a los altos requisitos de capacidad y continuidad.</p>
<p>En el ecosistema de Starknet y otras plataformas con ZK Rollups, se observa un paralelo similar. Estas redes externalizan el procesamiento de transacciones a estas entidades especializadas, denominadas <code>Sequencers</code>, quienes luego verifican su trabajo. La delegaci√≥n de tareas a los Sequencers es clave para que los ZK Rollups puedan manejar una gran cantidad de transacciones sin poner en riesgo la seguridad de la red subyacente, y as√≠ los Sequencers desempe√±an un papel esencial para lograr una mayor escalabilidad en Ethereum.</p>
<p>A diferencia de los mineros, cuya funci√≥n es brindar seguridad en otras redes, los Sequencers no aportan seguridad, sino que ofrecen capacidad de transacci√≥n. Su labor consiste en agrupar m√∫ltiples transacciones en un solo batch, procesarlas y generar un bloque. Este bloque ser√° luego verificado por el Verificador, al cual se le proporcionar√° una zk Proof que garantiza la <strong><code>Validez</code></strong> o <strong><code>Integridad</code></strong> de los datos, conocida como <code>Validity Proof</code>, y m√°s concretamente un <code>STARK</code> espec√≠fico de Starknet. El Prover es el encargado de generar este STARK y se asegura de que todos los datos de las transacciones sean correctos. Posteriormente, el Sequencer enviar√° todo a la red de Capa 1 como un <code>rollup</code>, una prueba √∫nica y compacta para que el Verificador compruebe que los datos son correctos y actualice el nuevo estado de la red.</p>
<p>Los Sequencers siguen un m√©todo sistem√°tico para el procesamiento de transacciones:</p>
<ol>
<li><strong>Agregaci√≥n:</strong> Recopilan transacciones de los usuarios.</li>
<li><strong>Procesamiento:</strong> Los Sequencers procesan estas transacciones de acuerdo con las reglas definidas por la red.</li>
<li><strong>Agrupaci√≥n:</strong> Las transacciones se agrupan en batchs o bloques para mayor eficiencia.</li>
<li><strong>Producci√≥n de Bloques:</strong> Los Sequencers producen bloques que contienen lotes de transacciones procesadas.</li>
</ol>
<p>Los Sequencers deben ser confiables y estar altamente disponibles, ya que su funci√≥n es fundamental para el buen funcionamiento de la red. Necesitan m√°quinas potentes y bien conectadas para desempe√±ar su papel de manera efectiva, ya que deben procesar transacciones de manera r√°pida y continua.</p>
<p>La hoja de ruta actual de Starknet incluye la descentralizaci√≥n del rol de secuenciador. Este cambio hacia la descentralizaci√≥n permitir√° que m√°s participantes se conviertan en Sequencers, contribuyendo a la robustez y seguridad de la red.</p>
<h2 id="provers"><a class="header" href="#provers">Provers:</a></h2>
<p>En Starknet, el SHARP (Shared Prover) desempe√±a un papel esencial al realizar m√∫ltiples tareas, incluida la generaci√≥n de la Validity Proof. Detallaremos estas diversas funciones en cap√≠tulos posteriores para comprender su importancia. Podemos entender al Prover como un componente que act√∫a en la segunda l√≠nea de verificaci√≥n del sistema, y una de sus tareas principales es validar el trabajo de los Sequencers, especialmente cuando estos reciben el bloque producido por el Sequencers. Adem√°s, los Provers tambi√©n tienen la responsabilidad de generar pruebas que demuestren que todos estos procesos se llevaron a cabo de manera correcta.</p>
<p>Los Provers necesitan incluso m√°s potencia computacional que los Sequencers, ya que deben calcular y generar pruebas, un proceso que es computacionalmente pesado. Sin embargo, el trabajo de los Provers se puede dividir en varias partes, lo que permite la paralelizaci√≥n y la generaci√≥n eficiente de pruebas. El proceso de generaci√≥n de pruebas es asincr√≥nico, lo que significa que no es necesario que ocurra de inmediato o en tiempo real. Esta flexibilidad permite distribuir la carga de trabajo entre varios Provers, cada uno trabajando en un bloque diferente, lo que facilita la paralelizaci√≥n y una generaci√≥n m√°s eficiente de pruebas.</p>
<p>El dise√±o de Starknet se basa en dos tipos de actores: los Sequencers y los Provers, que trabajan en conjunto para garantizar un procesamiento eficiente y una verificaci√≥n segura de las transacciones.</p>
<p>En cuanto a las funciones de un Prover, podemos destacar:</p>
<ol>
<li><strong>Recepci√≥n de Bloques:</strong> Los Provers obtienen bloques de transacciones procesadas de los Sequencers.</li>
<li><strong>Procesamiento:</strong> Los Provers vuelven a procesar estos bloques para asegurarse de que todas las transacciones dentro del bloque se hayan manejado correctamente.</li>
<li><strong>Generaci√≥n de Pruebas:</strong> Despu√©s del procesamiento, los Provers generan una Validity Proof que demuestra el correcto procesamiento de las transacciones.</li>
<li><strong>Env√≠o de Prueba a Ethereum:</strong> Finalmente, la Validity Proof se env√≠a a la red de Ethereum para su validaci√≥n. Si la Validity Proof es correcta, la red Ethereum acepta el bloque de transacciones.</li>
</ol>
<h2 id="nodos"><a class="header" href="#nodos">Nodos:</a></h2>
<p>Cuando se trata de definir qu√© hacen los nodos en Bitcoin o Ethereum, a menudo se interpreta err√≥neamente su papel como mantener un registro de cada transacci√≥n dentro de la red. Sin embargo, esto no es del todo preciso.</p>
<p>Los nodos act√∫an como auditores de la red, manteniendo el estado de la red, como cu√°nto Bitcoin posee cada participante o el estado actual de un contrato inteligente espec√≠fico. Logran esto procesando transacciones y conservando un registro de todas las transacciones, pero eso es un medio para un fin, no el fin en s√≠ mismo.</p>
<p>En el caso de Validity Rollup, espec√≠ficamente dentro de Starknet, este concepto se invierte en cierta medida. Los nodos no necesariamente tienen que procesar todas las transacciones para obtener el estado. A diferencia de Ethereum o Bitcoin, los nodos de Starknet no est√°n obligados a procesar cada transacci√≥n para mantener el estado de la red.</p>
<p>Existen dos formas principales de acceder a los datos del estado de la red:</p>
<ul>
<li>A trav√©s de una puerta de enlace de API.</li>
<li>Mediante el protocolo RPC para comunicarse con un nodo.</li>
</ul>
<p>Operar su propio nodo suele ser m√°s r√°pido que usar una arquitectura compartida, como la puerta de enlace. A medida que avanza el tiempo, Starknet planea descontinuar las API y reemplazarlas por un est√°ndar JSON RPC, lo que har√° que operar su propio nodo sea a√∫n m√°s beneficioso.</p>
<p>Vale la pena se√±alar que alentar a m√°s personas a ejecutar nodos aumenta la resistencia de la red y evita la sobrecarga del servidor, un problema que ha afectado a otras redes de Capa 2.</p>
<p>Actualmente, existen principalmente tres m√©todos principales para que un nodo lleve un registro del estado de la red: </p>
<ol>
<li><strong>Reproducci√≥n de Transacciones Antiguas:</strong> Al igual que en Ethereum o Bitcoin, un nodo puede tomar todas las transacciones y volver a ejecutarlas. Aunque este enfoque es preciso, no es escalable a menos que se tenga una m√°quina potente capaz de manejar la carga. Si se pueden volver a reproducir todas las transacciones, el nodo puede convertirse en un Sequencer, como puede ser el caso del nuevo enfoque adaptado a Madara con Substrate, actuando como un Sequencer, Full Node o mucho m√°s como veremos en su momento.</li>
<li><strong>Confiar en el Consenso de Capa 2:</strong> Los nodos pueden confiar en que los Secuencer ejecutan la red correctamente. Cuando el Secuencer actualiza el estado y agrega un nuevo bloque, los nodos aceptan la actualizaci√≥n como precisa.</li>
<li><strong>Verificaci√≥n de la Validaci√≥n de Pruebas en L1:</strong> Los nodos pueden monitorear el estado de la red observando L1 y asegur√°ndose de que cada vez que se env√≠a una prueba, reciben el estado actualizado. De esta manera, no tienen que confiar en nadie y solo necesitan realizar un seguimiento de la √∫ltima transacci√≥n v√°lida para Starknet.</li>
</ol>
<p>Podemos encontrarnos una variedad de tipos de nodos, cada uno desempe√±ando un papel esencial en el funcionamiento y cada tipo de configuraci√≥n de nodo presenta sus propios desaf√≠os y oportunidades, ya que vienen acompa√±ados de requisitos de hardware y suposiciones de confianza √∫nicas.</p>
<p>A medida que nos adentramos en este universo descentralizado, es crucial entender c√≥mo estos nodos interact√∫an y c√≥mo contribuyen a la eficiencia y seguridad de Starknet. Desde aquellos que reproducen transacciones con potencia de procesamiento masiva, hasta los que conf√≠an en el consenso de Capa 2 con menor carga computacional, y aquellos que verifican la validaci√≥n de pruebas en L1 con una huella m√°s liviana, cada nodo tiene su lugar y su relevancia en esta red en constante evoluci√≥n.</p>
<h3 id="nodos-que-reproducen-transacciones"><a class="header" href="#nodos-que-reproducen-transacciones">Nodos que Reproducen Transacciones:</a></h3>
<p>Los nodos que reproducen transacciones requieren m√°quinas potentes para rastrear y ejecutar todas las transacciones. Estos nodos no tienen suposiciones de confianza, √∫nicamente conf√≠an en las transacciones que ejecutan, garantizando que el estado en cualquier momento sea v√°lido.</p>
<h3 id="nodos-que-confian-en-el-consenso-de-capa-2"><a class="header" href="#nodos-que-confian-en-el-consenso-de-capa-2">Nodos que Confian en el Consenso de Capa 2:</a></h3>
<p>Los nodos que conf√≠an en el consenso de Capa 2 representan una opci√≥n de menor exigencia en cuanto a potencia computacional. Aunque necesitan un almacenamiento adecuado para mantener el estado, su carga de procesamiento de transacciones es m√°s liviana, dado que se basan en una suposici√≥n de confianza. Inicialmente, Starknet estuvo centrado en un solo secuenciador, pero ha evolucionado hacia una red m√°s descentralizada con la incorporaci√≥n de componentes como Madara y Secuencers de Rust mejorados por Lambda, entre otros, los cuales ser√°n detallados en la secci√≥n de Sequencers.</p>
<p>En este contexto, estos nodos depositan su confianza en que Starkware no interferir√° con la red. Sin embargo, a medida que se implemente un mecanismo de consenso y selecci√≥n de l√≠deres entre los Sequencers, el nivel de confianza se modificar√°. En ese futuro escenario, los nodos solo necesitar√°n confiar en que un Sequencer que ha comprometido su participaci√≥n para producir un bloque no estar√° dispuesto a perderla.</p>
<h3 id="nodos-que-verifican-la-validaci√≥n-de-pruebas-en-l1"><a class="header" href="#nodos-que-verifican-la-validaci√≥n-de-pruebas-en-l1">Nodos que Verifican la Validaci√≥n de Pruebas en L1:</a></h3>
<p>Los nodos que actualizan su estado bas√°ndose √∫nicamente en la validaci√≥n de pruebas en L1 requieren menos hardware y comparten los mismos requisitos que un nodo de Ethereum. Con la futura existencia de nodos ligeros de Ethereum, mantener un nodo de este tipo podr√≠a ser tan sencillo como usar un tel√©fono inteligente. No obstante, existe un compromiso a considerar <code>la latencia</code>. Las pruebas no se env√≠an a Ethereum en cada bloque de manera constante, sino de forma intermitente, lo que provoca actualizaciones de estado retrasadas.</p>
<p>Para aumentar la frecuencia de las pruebas, incluso si no se env√≠an a Ethereum de inmediato, se espera que un avance en el futuro permita que estos nodos reduzcan significativamente su latencia. Sin embargo, es importante tener en cuenta que este desarrollo a√∫n est√° lejos en la hoja de ruta de Starknet</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="componentes"><a class="header" href="#componentes">Componentes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secuenciadores"><a class="header" href="#secuenciadores">Secuenciadores</a></h1>
<p>Los secuenciadores desempe√±an un papel crucial en las soluciones blockchain y de Capa 2, ya que son responsables de gestionar el orden y la ejecuci√≥n de las transacciones. En Starknet, los secuenciadores garantizan que las transacciones se ejecuten en un orden espec√≠fico para prevenir el doble gasto y mantener la consistencia del estado de la red.</p>
<p>Los secuenciadores reciben transacciones, las procesan seg√∫n reglas predefinidas y producen una serie de acciones u cambios de estado ordenados. Estas acciones se agrupan en bloques y se incluyen en la cadena de bloques.</p>
<p>Los secuenciadores desempe√±an un papel vital en el rendimiento y la seguridad de Starknet al ejecutar transacciones y aplicar cambios de estado seg√∫n las reglas y requisitos del protocolo.</p>
<p>El secuenciador de Starknet es especialmente relevante debido al uso de pruebas de conocimiento cero (ZKPs, por sus siglas en ingl√©s). El correcto funcionamiento del secuenciador garantiza que las transacciones se ejecuten de manera compatible con la generaci√≥n de ZKPs, lo que contribuye a la escalabilidad y seguridad general de Starknet. Los usuarios interact√∫an con los secuenciadores al enviar transacciones a Starknet, siendo este el primer paso hacia el escalado de STARK. Una vez que un secuenciador ensambla un bloque, el protocolo de consenso lo aprueba y los probadores generan una prueba para la Capa 1 (L1).</p>
<p>En Ethereum, los mineros ordenan y ejecutan las transacciones, mientras que los secuenciadores cumplen un prop√≥sito similar en Starknet. Los secuenciadores procesan las transacciones, las agregan y producen bloques, lo que los convierte en una pieza fundamental de la infraestructura del ecosistema de Starknet.</p>
<p>A medida que Starknet evoluciona, es crucial mejorar el rendimiento de los secuenciadores. Aqu√≠ es donde se vuelve fundamental la transici√≥n a secuenciadores basados en Rust. Al reescribir los componentes principales del secuenciador en Rust, la red puede lograr un mejor rendimiento, mayor capacidad y mayor resistencia.</p>
<p>Algunos ejemplos de implementaciones de secuenciadores incluyen <a href="https://github.com/lambdaclass/starknet_tendermint_sequencer">Starknet Tendermint Sequencer de LambdaClass</a> y <a href="https://github.com/keep-starknet-strange/madara">Madara</a>, un secuenciador de Starknet impulsado por Rust utilizando Substrate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secuenciadores-basados-en-rust"><a class="header" href="#secuenciadores-basados-en-rust">Secuenciadores Basados en Rust</a></h1>
<p>Originalmente, los secuenciadores se escribieron en Python, que result√≥ ineficiente para operaciones a gran escala. A medida que la red alcanz√≥ su capacidad, los desarrolladores buscaron mejorar el rendimiento del secuenciador. El primer hito fue establecer una cadena de bloques en pleno funcionamiento, seguida de un enfoque en la optimizaci√≥n del rendimiento.</p>
<p>La mejora inicial del rendimiento implic√≥ la implementaci√≥n de una concurrencia optimista para la ejecuci√≥n de transacciones paralelas. Sin embargo, el avance m√°s significativo provino de la reescritura de secuenciadores en Rust, un lenguaje m√°s eficiente y m√°s r√°pido.</p>
<p>La reescritura de secuenciadores en Rust ha mostrado resultados prometedores en rendimiento y escalabilidad. Se espera que el rendimiento y la latencia de la red Starknet mejoren dram√°ticamente, beneficiando a la red y a aquellos que trabajan con infraestructura relacionada y herramientas de desarrollo.</p>
<p>Uno de los nuevos secuenciadores se basa en Papyrus, un nodo completo Starknet de c√≥digo abierto responsable de la gesti√≥n del estado. Los primeros puntos de referencia para proyectos como Madara revelan una notable transacci√≥n de 76 TPS ( por segundo ) para transferencias ERC20, mostrando las posibles mejoras que los secuenciadores basados en el √≥xido aportan al ecosistema Starknet.</p>
<p>La implementaci√≥n de concurrencia optimista tambi√©n contribuye a las mejoras en el rendimiento del secuenciador al ejecutar transacciones en paralelo, verificar conflictos en las celdas de almacenamiento tocadas e invalidar transacciones posteriores cuando sea necesario.</p>
<p>A medida que Starknet evoluciona, el desarrollo del secuenciador progresar√°, enfoc√°ndose en mejorar las capacidades y garantizar una integraci√≥n perfecta con la red. Los desarrolladores trabajar√°n en nuevas caracter√≠sticas, como los mecanismos de tarifas, que se implementar√°n en los pr√≥ximos lanzamientos como Memphis.</p>
<p>La mejora continua y la optimizaci√≥n de los secuenciadores son vitales para el crecimiento sostenido de Starknet. La transici√≥n a secuenciadores basados en Rust y los esfuerzos continuos para mejorar su desempe√±o indudablemente contribuir√°n.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="madara---bases-de-su-arquitectura"><a class="header" href="#madara---bases-de-su-arquitectura">Madara - Bases de su arquitectura</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="full-nodes---starknet-stack"><a class="header" href="#full-nodes---starknet-stack">Full Nodes - Starknet Stack</a></h1>
<p>En el contexto de Ethereum y blockchain, un nodo es una parte integral de la red que valida y retransmite transacciones. Los nodos descargan una copia de toda la cadena de bloques y est√°n interconectados con otros nodos para mantener y actualizar el estado de la cadena de bloques. Hay diferentes tipos de nodos, como nodos completos, nodos ligeros y nodos de miner√≠a, cada uno con roles y responsabilidades diferentes dentro de la red.</p>
<h2 id="starknet-stack"><a class="header" href="#starknet-stack">Starknet Stack</a></h2>
<p>La red de nodos de Starknet est√° compuesta por nodos que sincronizan y procesan transacciones, contribuyendo a la seguridad y descentralizaci√≥n general de la red.</p>
<p>La pila de Starknet se puede dividir en varias capas, al igual que los modelos OSI o TCP/IP. El modelo m√°s apropiado depende de tu comprensi√≥n y requisitos. Una versi√≥n simplificada de la pila modular de blockchain podr√≠a verse as√≠:</p>
<ul>
<li><strong>Capa 1 - Capa de Datos:</strong> La Capa 1 en la pila de Starknet es la Capa de Datos, que se refiere a la cadena de bloques subyacente en Ethereum. Esta capa proporciona la seguridad y la integridad de los datos subyacentes a Starknet. Aqu√≠ es donde se almacenan los contratos inteligentes y se realizan las transacciones en Ethereum.</li>
<li><strong>Capa 2 - Capa de Ejecuci√≥n:</strong> La Capa 2 en la pila de Starknet es la Capa de Ejecuci√≥n. Aqu√≠ es donde se lleva a cabo la ejecuci√≥n de los contratos inteligentes utilizando el entorno de ejecuci√≥n de Cairo. Cairo es un lenguaje de programaci√≥n espec√≠fico de Starknet que facilita la escritura y ejecuci√≥n de contratos inteligentes complejos. En esta capa, se procesan las transacciones y se realizan las operaciones computacionales necesarias para ejecutar los contratos inteligentes.</li>
<li><strong>Capa 3 - Capa de Aplicaci√≥n:</strong> La Capa 3 en la pila de Starknet es la Capa de Aplicaci√≥n. Aqu√≠ es donde se desarrollan y despliegan las aplicaciones descentralizadas (dApps) en Starknet. Las dApps pueden incluir una amplia gama de aplicaciones, como juegos, finanzas descentralizadas, intercambios descentralizados y m√°s. Esta capa permite a los desarrolladores aprovechar la escalabilidad y las capacidades de ejecuci√≥n de Starknet para construir aplicaciones m√°s r√°pidas y eficientes.</li>
<li><strong>Capa 4 - Capa de Transporte:</strong> La Capa 4 en la pila de Starknet es la Capa de Transporte. Esta capa se encarga de la comunicaci√≥n y el transporte de datos entre los diferentes nodos de Starknet. Proporciona la infraestructura necesaria para que los nodos se sincronicen y compartan informaci√≥n, lo que contribuye a la seguridad y descentralizaci√≥n general de la red.</li>
</ul>
<p>Estas son las cuatro capas principales en la pila de Starknet. Cada capa desempe√±a un papel crucial en el funcionamiento y la escalabilidad de Starknet, permitiendo a los desarrolladores aprovechar las capacidades de Capa 2 para construir aplicaciones m√°s r√°pidas y eficientes en Ethereum.</p>
<p>En cuanto a por qu√© el c√≥mputo verificable constituye un movimiento tecnol√≥gico con un impacto amplio, creemos en tres cualidades esenciales: inmutable, inalterable, componibilidad.</p>
<ul>
<li><strong>Nivel 8 - Interfaces de usuario:</strong> Las interfaces de usuario parecen fuera de lugar en la pila de c√≥mputo verificable a primera vista. La clave aqu√≠ es reconocer la ventaja poco explorada de ejecutar la generaci√≥n de pruebas en el lado del cliente.</li>
<li><strong>Nivel 7 - Hiperestructura y aplicaciones:</strong> Aqu√≠ es donde participar√°n directamente las pr√≥ximas olas de desarrolladores y creadores. Para una definici√≥n, consulta las <a href="https://jacob.energy/hyperstructures.html">Hiperestructuras</a>.</li>
<li><strong>Nivel 6 - Bibliotecas de bajo nivel:</strong> Aqu√≠ es donde se encuentran bibliotecas como numpy, scipy, onnx. Por ejemplo, consulta <a href="https://twitter.com/gizatechxyz">Giza</a>.</li>
<li><strong>Nivel 5 - Lenguaje de programaci√≥n y compilador:</strong> Aqu√≠ es donde los programas / intenciones de dise√±o escritos en notaciones accesibles y ergon√≥micas en los niveles 5-7 se transforman en objetos estandarizados (por ejemplo, con respecto a algunas arquitecturas de conjuntos de instrucciones) que son susceptibles a aritmetizaci√≥n. Por ejemplo, consulta <a href="https://eprint.iacr.org/2021/1063.pdf">Cairo</a> y <a href="https://github.com/risc0/risc0">Risc0</a>.</li>
<li><strong>Nivel 4 - Aritm√©tica y arquitectura:</strong> Aqu√≠ es donde los objetos estandarizados del nivel 5 se transforman en restricciones polinomiales. Por ejemplo, consulta <a href="https://eprint.iacr.org/2021/582.pdf">ethSTARK</a>.</li>
<li><strong>Nivel 3 - Generaci√≥n y verificaci√≥n de pruebas:</strong> Aqu√≠ es donde las restricciones polinomiales se transforman en pruebas (sucintas, de conocimiento cero) que pueden ser verificadas (de manera eficiente y recursiva), donde los calificadores entre par√©ntesis son m√©tricas a las que se aspira. Por ejemplo, consulta <a href="https://arxiv.org/pdf/1903.12243.pdf">DEEP-FRI</a> y <a href="https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf">KZG</a>.</li>
<li><strong>Nivel 2 - Sistema distribuido:</strong> Aqu√≠ es donde pertenece el dise√±o de la arquitectura del sistema de blockchain o rollup. Por ejemplo, consulta <a href="https://community.starknet.io/t/starknet-decentralization-tendermint-based-suggestion/998">Descentralizaci√≥n de Starknet</a>.</li>
<li><strong>Nivel 1 - Aceleraci√≥n de hardware:</strong> Autoexplicativo. Por ejemplo, consulta <a href="https://www.ingonyama.com/">Ingonyama</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pathfinder"><a class="header" href="#pathfinder">Pathfinder</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="juno"><a class="header" href="#juno">Juno</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deoxys"><a class="header" href="#deoxys">Deoxys</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="papyrus"><a class="header" href="#papyrus">Papyrus</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sharp"><a class="header" href="#sharp">SHARP</a></h1>
<p>SHARP es como el transporte p√∫blico para las pruebas en Starknet, que agrega m√∫ltiples programas Cairo para ahorrar costos y aumentar la eficiencia. Utiliza pruebas recursivas que permiten la paralelizaci√≥n y optimizaci√≥n, lo que lo hace m√°s asequible para todos los usuarios. Los servicios cr√≠ticos como la gateway, el validator y el Prover trabajan juntos con un dise√±o sin estado para mayor flexibilidad. La adopci√≥n de SHARP por parte de StarkEx, Starknet y usuarios externos (a trav√©s de Cairo Playground) resalta su importancia y potencial para la optimizaci√≥n futura.</p>
<p>Ve√°mos c√≥mo SHARP, ha evolucionado para incorporar pruebas recursivas y su papel en la reducci√≥n de costos y mejora de la eficiencia dentro de la red Starknet.</p>
<p>SHARP, que significa Shared Prover (Proveedor Compartido), es un mecanismo utilizado en Starknet que agrupa m√∫ltiples programas Cairo de diferentes usuarios, cada uno con una l√≥gica diferente. Estos programas Cairo se ejecutan juntos, generando una prueba √∫nica com√∫n a todos los programas. En lugar de enviar la prueba directamente al verificador de Solidity en Ethereum, se env√≠a inicialmente a un programa Verificador STARK escrito en Cairo. El Verificador STARK genera una nueva prueba para confirmar que las pruebas iniciales fueron verificadas, que luego puede enviarse de vuelta a SHARP y al Verificador STARK usando el proceso de prueba recursiva que se discutir√° en m√°s detalle m√°s adelante en este cap√≠tulo. En √∫ltima instancia, la √∫ltima prueba de la serie se env√≠a al Verificador de Solidity en Ethereum. En otras palabras, se generan muchas pruebas hasta llegar a Ethereum y al Verificador de Solidity.</p>
<p>El principal beneficio del sistema SHARP radica en su capacidad para reducir costos y mejorar la eficiencia dentro de la red de Starknet. Esto se logra al agrupar m√∫ltiples trabajos de Cairo, que son conjuntos individuales de c√°lculos. Esta agregaci√≥n permite que el protocolo aproveche la amortizaci√≥n exponencial ofrecida por las pruebas STARK.</p>
<p>La amortizaci√≥n exponencial significa que a medida que aumenta la carga computacional de las pruebas, el costo de verificar esas pruebas aumenta a una tasa logar√≠tmica m√°s lenta que el aumento de la computaci√≥n. En otras palabras, la computaci√≥n en s√≠ crece m√°s lentamente que el costo de verificaci√≥n. Como resultado, el costo de cada transacci√≥n dentro del conjunto agregado se reduce significativamente, lo que hace que el proceso general sea m√°s rentable y accesible para los usuarios.</p>
<p>En el contexto de SHARP y Cairo, jobs se refiere a los programas Cairo individuales o tareas presentados por diferentes usuarios. Estos trabajos contienen l√≥gica o c√°lculos espec√≠ficos que deben ejecutarse en la red de Starknet.</p>
<p>Adem√°s, SHARP permite que usuarios m√°s peque√±os con recursos limitados se beneficien al unirse a otros trabajos y compartir el costo de generar las pruebas. Este enfoque colaborativo es similar a usar el transporte p√∫blico en lugar de un autom√≥vil privado, donde el costo se distribuye entre todos los participantes, lo que lo hace m√°s asequible para todos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursividad---sharp"><a class="header" href="#recursividad---sharp">Recursividad - SHARP</a></h1>
<p>Una de las caracter√≠sticas m√°s poderosas de SHARP es su uso de pruebas recursivas. En lugar de enviar directamente las pruebas generadas al Verificador de Solidity, primero se env√≠an a un programa Verificador STARK escrito en Cairo. Este Verificador, que tambi√©n es un Programa Cairo, recibe la prueba y crea un nuevo trabajo de Cairo que se env√≠a al Proveedor. El Proveedor luego genera una nueva prueba para confirmar que las pruebas iniciales fueron verificadas. Estas nuevas pruebas se pueden enviar de vuelta a SHARP y al Verificador STARK, reiniciando el proceso.</p>
<p>Este proceso contin√∫a de forma recursiva, enviando cada nueva prueba al Verificador de Cairo hasta que se alcanza un disparador. En este punto, la √∫ltima prueba de la serie se env√≠a al Verificador de Solidity en Ethereum. Este enfoque permite una mayor paralelizaci√≥n de la computaci√≥n y reduce el tiempo y los costos asociados con la generaci√≥n y verificaci√≥n de pruebas.</p>
<p>A primera vista, las pruebas recursivas pueden parecer m√°s complejas y consumir m√°s tiempo. Sin embargo, hay varios beneficios en este enfoque:</p>
<ul>
<li><strong>Paralelizaci√≥n:</strong> Las pruebas recursivas permiten la paralelizaci√≥n del trabajo, reduciendo la latencia del usuario y mejorando la eficiencia de SHARP.</li>
<li><strong>Menores costos en la cadena:</strong> La paralelizaci√≥n permite que SHARP cree pruebas m√°s grandes, que anteriormente se limitar√≠an por la disponibilidad de m√°quinas en la nube grandes (que son escasas y limitadas). Como resultado, los costos en la cadena se reducen.</li>
<li><strong>Menores costos en la nube:</strong> Dado que cada trabajo es m√°s corto, se reduce la memoria requerida para el procesamiento, lo que resulta en menores costos en la nube.</li>
<li><strong>Optimizaci√≥n:</strong> Las pruebas recursivas permiten que SHARP se optimice para varios factores, incluyendo la latencia, los costos en la cadena y el tiempo de prueba.</li>
<li><strong>Compatibilidad con Cairo:</strong> Las pruebas recursivas solo requieren soporte en Cairo, sin necesidad de agregar soporte en el Verificador de Solidity.</li>
</ul>
<p>La latencia en Starknet abarca el tiempo que lleva procesar, confirmar e incluir transacciones en un bloque. Est√° afectada por factores como la congesti√≥n de la red, las tarifas de transacci√≥n y la eficiencia del sistema. Minimizar la latencia garantiza un procesamiento de transacciones m√°s r√°pido y una retroalimentaci√≥n del usuario m√°s r√°pida.</p>
<p>El tiempo de prueba, por otro lado, se refiere espec√≠ficamente a la duraci√≥n requerida para generar y verificar pruebas criptogr√°ficas para transacciones u operaciones.</p>
<p>Desde SHARP 4.0 se agregaron dos nuevos componentes importantes: keccack y Poseid√≥n.</p>
<p>Keccack es importante para las aplicaciones y Poseidon tambi√©n se usa en el propio estado de Starknet (para el nuevo c√°lculo de hash de clases de Cairo 1 y para el nuevo estado de clases).</p>
<p>La arquitectura del backend de SHARP consiste en varios servicios que trabajan en conjunto para procesar trabajos de Cairo y generar pruebas. Estos servicios incluyen:</p>
<ul>
<li><strong>Gateway:</strong> Los trabajos de Cairo ingresan a SHARP a trav√©s del gateway.</li>
<li><strong>Job Creator:</strong> Evita la duplicaci√≥n de trabajos y garantiza que el sistema funcione de manera consistente, independientemente de las solicitudes m√∫ltiples id√©nticas.</li>
<li><strong>Validator:</strong> Este es el primer paso importante. El servicio de validaci√≥n realiza verificaciones en cada trabajo para asegurarse de que cumplan con los requisitos y puedan adaptarse a las m√°quinas probadoras. Los trabajos inv√°lidos se etiquetan como tales y no contin√∫an hacia el Prover.</li>
<li><strong>Scheduler:</strong> El servicio de planificaci√≥n crea &quot;trains&quot; que agregan trabajos y los env√≠an al Prover. Los trabajos recursivos se emparejan y se env√≠an juntos al Prover.</li>
<li><strong>Cairo Runner:</strong> Este servicio ejecuta Cairo para las necesidades del Prover. El servicio Cairo Runner ejecuta programas de Cairo, realizando los c√°lculos necesarios y generando el rastro de ejecuci√≥n como resultado intermedio. El Prover luego utiliza este rastro de ejecuci√≥n.</li>
<li><strong>Prover:</strong> El Prover calcula las pruebas para cada trains (que contiene varios trabajos).</li>
<li><strong>Dispatcher:</strong> El Dispatcher cumple dos funciones en el sistema SHARP.
<ul>
<li>
<p>En el caso de una prueba recursiva, el Dispatcher ejecuta el programa Cairo Verifier en la prueba que ha recibido del Prover, lo que resulta en un nuevo trabajo de Cairo que vuelve al Validador.</p>
</li>
<li>
<p>En el caso de una prueba que debe ir a la cadena (por ejemplo, a Ethereum), el Dispatcher crea &quot;paquetes&quot; a partir de la prueba, que luego se pueden enviar al Escritor de la Cadena de Bloques.</p>
</li>
</ul>
</li>
<li><strong>Blockchain Writer:</strong> Una vez que el Dispatcher ha creado los paquetes, los env√≠a al Escritor de la Cadena de Bloques. El Escritor de la Cadena de Bloques se encarga de enviar los paquetes a la cadena de bloques correspondiente (por ejemplo, Ethereum) para su verificaci√≥n. Este es un paso importante en el sistema SHARP, ya que garantiza que las pruebas se verifiquen correctamente y que las transacciones se registren de forma segura en la cadena de bloques.</li>
<li><strong>Catcher:</strong> El Catcher monitorea las transacciones de la cadena de bloques (por ejemplo, Ethereum) para asegurarse de que hayan sido aceptadas. Si bien el Catcher es relevante para fines de monitoreo interno, es importante tener en cuenta que si una transacci√≥n falla, el hecho no se registrar√° en el registro de hechos de la cadena. Como resultado, la integridad del sistema se mantiene incluso sin el Catcher.</li>
</ul>
<p>SHARP est√° dise√±ado para ser sin estado (cada trabajo de Cairo se ejecuta en su propio contexto y no depende de otros trabajos), lo que permite una mayor flexibilidad en el procesamiento de trabajos.</p>
<p>Actualmente, los principales usuarios de SHARP incluyen:</p>
<ul>
<li>StarkEx</li>
<li>Starknet</li>
<li>Usuarios externos que utilizan el Cairo Playground</li>
</ul>
<p>Optimizar el Proveedor implica numerosos desaf√≠os y proyectos potenciales en los que el equipo de Starkware y la comunidad est√°n trabajando actualmente:</p>
<ul>
<li><strong>Exploraci√≥n de funciones hash m√°s eficientes:</strong> SHARP est√° constantemente explorando funciones hash m√°s eficientes para Cairo, el Proveedor y Solidity.</li>
<li><strong>Investigaci√≥n de campos m√°s peque√±os:</strong> La investigaci√≥n de campos m√°s peque√±os para los pasos de prueba recursiva podr√≠a conducir a c√°lculos m√°s eficientes.</li>
<li><strong>Ajuste de varios par√°metros:</strong> SHARP est√° ajustando constantemente varios par√°metros del protocolo STARK, como los par√°metros FRI y los factores de bloque.</li>
<li><strong>Optimizaci√≥n del c√≥digo de Cairo:</strong> SHARP est√° optimizando el c√≥digo de Cairo para hacerlo m√°s r√°pido, lo que resulta en un Proveedor recursivo m√°s r√°pido.</li>
<li><strong>Desarrollo de dise√±os din√°micos:</strong> Esto permitir√° a los programas de Cairo adaptar los recursos seg√∫n sus necesidades.</li>
</ul>
<p>Mejora del algoritmo de programaci√≥n: Este es otro camino de optimizaci√≥n que se puede tomar. No est√° dentro del Proveedor en s√≠.</p>
<p>En particular, los Dynamic Layouts o dise√±os din√°micos, permitir√°n que los programas de Cairo adapten los recursos seg√∫n sus necesidades. Esto puede llevar a una computaci√≥n m√°s eficiente y a una mejor utilizaci√≥n de los recursos. Los dise√±os din√°micos permiten a SHARP determinar los recursos necesarios para un trabajo espec√≠fico y ajustar el dise√±o en consecuencia en lugar de depender de dise√±os predefinidos con recursos fijos. Este enfoque puede proporcionar soluciones personalizadas para cada trabajo, mejorando la eficiencia general.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="componentes---sharp"><a class="header" href="#componentes---sharp">Componentes - SHARP</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="playground"><a class="header" href="#playground">Playground</a></h1>
<p>El Playground de Cairo es una herramienta que te permite crear y probar c√≥digos de Cairo de manera interactiva. Con esta plataforma, puedes desarrollar y probar tus programas de Cairo antes de implementarlos en una cadena de bloques.</p>
<p>El proceso de prueba en el Playground de Cairo consta de varios pasos. Primero, cuando escribes tu c√≥digo en Cairo, el Playground lo compila y ejecuta para crear un rastro de ejecuci√≥n. Este rastro se env√≠a a la red de Cairo para su evaluaci√≥n.</p>
<p>En la etapa de prueba, el sistema de Cairo, conocido como SHARP, recopila m√∫ltiples trazas de ejecuci√≥n de programas (incluso programas no relacionados) y los combina en un lote llamado &quot;tren&quot;. Al igual que un tren no sale de la estaci√≥n a pedido, el tren de Cairo puede tardar un tiempo en ser enviado al probador. SHARP esperar√° hasta acumular un lote lo suficientemente grande de trazas de programas o hasta que haya transcurrido cierto tiempo, lo que ocurra primero.</p>
<p>Una vez que se ha formado el tren de pruebas, SHARP env√≠a este conjunto al verificador en cadena (actualmente en Goerli). Para cada programa en el tren, el contrato SHARP registra un hecho en el Registro de hechos que certifica la validez de la ejecuci√≥n y su salida particular. Con esto, se cierra el ciclo y tu aplicaci√≥n en la cadena de bloques puede utilizar la salida del programa.</p>
<p>Durante todo este proceso, puedes monitorear el estado de tu trabajo haciendo clic en el enlace en el panel de salida del Playground. Se abrir√° una nueva pesta√±a que se actualizar√° autom√°ticamente y te mostrar√° en qu√© etapa se encuentra tu trabajo.</p>
<p>Adem√°s, puedes acceder al contrato compartido para ver el hecho de tu trabajo utilizando el m√©todo isValid().</p>
<div style="break-before: page; page-break-before: always;"></div><p>https://github.com/patrickbiel01/Cairo_Verifier</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quantum-leap"><a class="header" href="#quantum-leap">Quantum Leap</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="versiones"><a class="header" href="#versiones">Versiones</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-stack-1"><a class="header" href="#starknet-stack-1">Starknet Stack</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>https://starkware.co/resource/paradex-starknets-first-appchain/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-avalability"><a class="header" href="#data-avalability">Data Avalability</a></h1>
<p>En la etapa actual de Alpha, Starknet opera en modo ZK-Rollup. Esto significa que al aceptar una actualizaci√≥n de estado en la cadena, la diferencia de estado entre el estado anterior y el nuevo se env√≠a como datos de llamada (calldata) a Ethereum.</p>
<p>Estos datos permiten a cualquiera que observe Ethereum reconstruir el estado actual de Starknet.</p>
<p>Para actualizar el estado de Starknet en L1, es suficiente enviar una prueba v√°lida, sin informaci√≥n sobre las transacciones o los cambios particulares que caus√≥ esta actualizaci√≥n.</p>
<p>Consecuentemente, se debe proporcionar m√°s informaci√≥n para permitir que otras partes rastreen localmente el estado de Starknet.</p>
<p>Datos en la cadena: despu√©s de v0.11.0 Formato v0.11.0 Las diferencias de estado contienen informaci√≥n sobre cada contrato cuyo almacenamiento se ha actualizado, as√≠ como informaci√≥n adicional sobre los despliegues de contratos.</p>
<p>Para cada contrato afectado, tenemos:</p>
<ul>
<li><strong>La direcci√≥n del contrato</strong></li>
<li><strong>Una sola palabra que codifica:</strong>
<ul>
<li>Un indicador de informaci√≥n de clase (0 = solo actualizaciones de almacenamiento / 1 = el contrato fue desplegado o reemplazado en esta actualizaci√≥n de estado). Cuando este indicador est√° activado, habr√° una palabra adicional antes de la secci√≥n de actualizaciones de almacenamiento, que contiene el nuevo hash de clase.</li>
</ul>
</li>
<li><strong>Nonce</strong></li>
<li><strong>num_of_storage_updates</strong> (n√∫mero de actualizaciones de almacenamiento).</li>
</ul>
<p>A continuaci√≥n se muestra </p>
<p><img src="./assets/state.png" alt="graph" /></p>
<div align="center">
<em>As√≠ debe de ser el formato esperado</em>
</div>
<p>Para cada actualizaci√≥n de almacenamiento:</p>
<ul>
<li><strong>clave:</strong> la direcci√≥n dentro del almacenamiento del contrato donde se actualiza el valor</li>
<li><strong>valor:</strong> el nuevo valor</li>
</ul>
<p>A continuaci√≥n, se proporciona informaci√≥n sobre las clases declaradas y el n√∫mero de clases (Cairo 1.0) presentes en el bloque.</p>
<p>Para cada clase, se incluyen los siguientes detalles:</p>
<ol>
<li>Hash de la clase.</li>
<li>Hash de la clase compilada.</li>
</ol>
<h2 id="ejemplos-despu√©s-la-v0110"><a class="header" href="#ejemplos-despu√©s-la-v0110">Ejemplos despu√©s la v0.11.0</a></h2>
<p>A continuaci√≥n, mostramos un ejemplo de datos en la cadena que se extrajeron de L1 y procedemos a decodificarlo seg√∫n el formato mencionado anteriormente.</p>
<pre><code class="language-bash">[
1,
2019172390095051323869047481075102003731246132997057518965927979101413600827,
18446744073709551617,
100,
200,
1,
1351148242645005540004162531550805076995747746087542030095186557536641755046,
558404273560404778508455254030458021013656352466216690688595011803280448032
]
</code></pre>
<ul>
<li>El primer elemento <code>1</code>, es el n√∫mero de contratos cuyo estado se actualiz√≥.</li>
<li>El segundo elemento, <code>2019172390095051323869047481075102003731246132997057518965927979101413600827</code>, es la direcci√≥n del primer (y √∫nico) contrato cuyo estado cambi√≥, recordamos que es un felt su expresi√≥n hexadecimal ser√≠a <code>0x0476cfa27c83ea2498c4fb61972c2b80d2b1cd500986a881ec3c4e5b4f726e3b</code>.</li>
<li>El tercer elemento, 18446744073709551617, que es 2^64+1, codifica lo siguiente:
<ul>
<li>El indicador de informaci√≥n de clase es 0, es decir, el contrato no se despleg√≥ ni se reemplaz√≥, por lo que no debemos tratar la siguiente palabra como el hash de clase.</li>
<li>El nuevo nonce es 1.</li>
<li>Se actualiz√≥ una celda de almacenamiento.</li>
</ul>
</li>
<li>Los dos elementos siguientes, <code>100</code> y <code>200</code>, codifican la actualizaci√≥n de almacenamiento (el valor de la clave 100 se estableci√≥ en 200).</li>
<li>A continuaci√≥n, tenemos la secci√≥n de declaraciones nuevas: <code>1</code> significa que tuvimos una √∫nica declaraci√≥n v2 en esta actualizaci√≥n de estado, y los dos elementos siguientes, codifican el <code>class hash</code> y el <code>class hash compile</code> del <code>class declare</code>.</li>
</ul>
<h2 id="formato-anterior-a-la-011"><a class="header" href="#formato-anterior-a-la-011">Formato Anterior a la 0.11</a></h2>
<p>Las state diffs contienen informaci√≥n sobre cada contrato cuyo storage se ha actualizado, as√≠ como informaci√≥n adicional sobre los despliegues de contratos. Esas diferencias se env√≠an como un arreglo uint256[] como parte de los datos de llamada (calldata), y se codifican de la siguiente manera:</p>
<ul>
<li>N√∫mero de celdas que codifican los despliegues de contratos.</li>
<li>Para cada contrato desplegado, tenemos:
<ul>
<li>contract_address: la direcci√≥n del contrato desplegado.</li>
<li>contract_hash: el hash de la clase.</li>
</ul>
</li>
<li>N√∫mero de contratos cuyo almacenamiento se actualiza.</li>
<li>Para cada contrato de ese tipo, tenemos:
<ul>
<li>contract_address: la direcci√≥n del contrato.</li>
<li>num_of_storage_updates: el n√∫mero de actualizaciones de almacenamiento.</li>
<li>nonce,ŒΩmofs‚Üíra‚â•actualizaciones: un valor uint256 que codifica tanto el n√∫mero de actualizaciones de almacenamiento para ese contrato como el nonce actualizado:</li>
</ul>
</li>
</ul>
<p><img src="./assets/state1.png" alt="graph" /></p>
<div align="center">
<em>As√≠ era el formato esperado antes de 0.11</em>
</div>
<ul>
<li>Para cada actualizaci√≥n de almacenamiento:
<ul>
<li>clave: la direcci√≥n dentro del almacenamiento del contrato donde se actualiza el valor</li>
<li>valor: el nuevo valor</li>
</ul>
</li>
</ul>
<h2 id="ejemplos-antes-la-v0110"><a class="header" href="#ejemplos-antes-la-v0110">Ejemplos antes la v0.11.0</a></h2>
<p>A continuaci√≥n, mostramos un ejemplo de datos en cadena que se extrajeron de L1 y se decodificaron seg√∫n el formato anterior.</p>
<pre><code class="language-bash">[
2,
2472939307328371039455977650994226407024607754063562993856224077254594995194,
1336043477925910602175429627555369551262229712266217887481529642650907574765,
5,
2019172390095051323869047481075102003731246132997057518965927979101413600827,
18446744073709551617,
5,
102,
2111158214429736260101797453815341265658516118421387314850625535905115418634,
2,
619473939880410191267127038055308002651079521370507951329266275707625062498,
1471584055184889701471507129567376607666785522455476394130774434754411633091,
619473939880410191267127038055308002651079521370507951329266275707625062499,
541081937647750334353499719661793404023294520617957763260656728924567461866,
2472939307328371039455977650994226407024607754063562993856224077254594995194,
1,
955723665991825982403667749532843665052270105995360175183368988948217233556,
2439272289032330041885427773916021390926903450917097317807468082958581062272,
3429319713503054399243751728532349500489096444181867640228809233993992987070,
1,
5,
1110,
3476138891838001128614704553731964710634238587541803499001822322602421164873,
6,
59664015286291125586727181187045849528930298741728639958614076589374875456,
600,
221246409693049874911156614478125967098431447433028390043893900771521609973,
400,
558404273560404778508455254030458021013656352466216690688595011803280448030,
100,
558404273560404778508455254030458021013656352466216690688595011803280448031,
200,
558404273560404778508455254030458021013656352466216690688595011803280448032,
300,
1351148242645005540004162531550805076995747746087542030095186557536641755046,
500
]
</code></pre>
<ul>
<li>El primer elemento <code>2</code>, es el n√∫mero de celdas que codifican la implementaci√≥n de contratos.</li>
<li>Los dos siguientes elementos describen una √∫nica implementaci√≥n de contrato con los siguientes par√°metros:
<ul>
<li>direcci√≥n_contrato:</li>
</ul>
</li>
</ul>
<pre><code class="language-bash">2472939307328371039455977650994226407024607754063562993856224077254594995194
</code></pre>
<ul>
<li>hash_contrato:</li>
</ul>
<pre><code class="language-bash">2472939307328371039455977650994226407024607754063562993856224077254594995194
</code></pre>
<ul>
<li>El siguiente elemento <code>5</code> (√≠ndice 3 en el array), es el n√∫mero de contratos cuyo almacenamiento se actualiz√≥. Tomaremos solo el primer contrato como ejemplo.
<ul>
<li>direcci√≥n_contrato:</li>
</ul>
</li>
</ul>
<pre><code class="language-bash">2019172390095051323869047481075102003731246132997057518965927979101413600827
</code></pre>
<ul>
<li>Despu√©s de la direcci√≥n de contrato mencionada anteriormente, tenemos <code>18446744073709551617</code> (√≠ndice 8 en el array), que es <code>2^64+1</code> , por lo tanto:
<ul>
<li>El nuevo nonce del contrato es 1.</li>
<li>Se actualiza una clave de almacenamiento.</li>
<li>El valor en la clave 5 se cambi√≥ a 102.</li>
</ul>
</li>
</ul>
<p>Las siguientes 4 actualizaciones de almacenamiento de contratos se interpretan de la misma manera.</p>
<p>Extracci√≥n desde Ethereum Los datos descritos anteriormente se env√≠an a trav√©s de varias transacciones de Ethereum, cada una de las cuales contiene una parte de esta matriz como calldata. Cada nuevo bloque de Starknet tiene sus transacciones de difusi√≥n de estado asociadas.</p>
<p>Puede encontrar <a href="https://github.com/eqlabs/pathfinder/blob/2fe6f549a0b8b9923ed7a21cd1a588bc571657d6/crates/pathfinder/src/ethereum/state_update/retrieve.rs">el c√≥digo para extraer estos datos</a> de Ethereum en el repositorio de Pathfinder.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evm-vs-zkevm"><a class="header" href="#evm-vs-zkevm">EVM vs zkEVM</a></h1>
<p>El desaf√≠o central con el enfoque zkEVM est√° enraizado en el plan original de EVM, este no fue dise√±ado para funcionar dentro de un contexto de prueba de validez. En consecuencia, los esfuerzos para reflejar su funcionalidad no logran desbloquear todo el potencial de las pruebas de validez, lo que resulta en una eficiencia menos que √≥ptima. Tal ineficiencia finalmente pesa el rendimiento general del sistema. </p>
<p>La compatibilidad del EVM con las pruebas de validez se ve obstaculizada por los siguientes factores:</p>
<ul>
<li>
<p>El EVM emplea un modelo basado en apilamiento, mientras que las pruebas de validez se emplean de manera m√°s efectiva con un modelo basado en registros. La naturaleza basada en la pila del EVM hace que sea inherentemente m√°s dif√≠cil demostrar la exactitud de su ejecuci√≥n y proporcionar soporte directo para su cadena de herramientas nativa.</p>
</li>
<li>
<p>El dise√±o de almacenamiento Ethereum depende en gran medida de Keccak y un gran √°rbol Merkle Patricia, que no son amigables con Validity Proof e imponen una carga de prueba sustancial. Por ejemplo, Keccak es muy r√°pido para las arquitecturas x86 ( sobre las cuales generalmente ejecutamos el EVM ), pero toma 90k pasos para probar ( con una construcci√≥n especial incorporada ). Mientras que Pedersen ( una funci√≥n hash amigable con zk ) da 32 pasos. Incluso con compresi√≥n recursiva, el uso de Keccak en un zkEVM significa altos recursos de prover que terminan siendo pagados por el usuario.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kakarot---bases-de-su-arquitectura"><a class="header" href="#kakarot---bases-de-su-arquitectura">Kakarot - Bases de su arquitectura</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vm-de-cairo"><a class="header" href="#vm-de-cairo">VM de Cairo</a></h1>
<p>Profundizaremos en la arquitecura de CVM y como es su funcionamiento a nivel de ejecutar AIR, optimizaciones usando built, instrucciones y sus dise√±os para mejorar pasos y potenicar sus funciones, en ellos estaran como se organizan los dise√±os lineales o dynamicos para optimizar el rendimiento de un progrma de Cairo, el cual revisaremos las trace celd.</p>
<p>Este conjunto minimalista de instrucciones se denomina <code>RISC algebraico</code> (Computadora de conjunto de instrucciones reducidas); <code>Algebraico</code> se refiere al hecho de que las operaciones admitidas son operaciones de field. El uso de un <code>RISC algebraico</code> nos permite construir un AIR para Cairo con solo 51 celdas traza por paso. </p>
<p>Un de los mejores ejemplos es <a href="https://www.risczero.com/">RISC Zero</a>, que detallaremos m√°s en otras arquitecturas pero b√°sicamente <code>RISC Zero zkVM</code> es un ordenador verificable que funciona como un microprocesador <code>RISC-V</code> real integrado, lo que permite a los programadores escribir pruebas ZK como si escribieran cualquier otro c√≥digo. Tambi√©n destacamos que soporta Rust para escribir pruebas ZK y puede admitir cualquier lenguaje que compile en RISC-V.</p>
<h2 id="builtin"><a class="header" href="#builtin">Builtin</a></h2>
<p>Los builtins son unidades de ejecuci√≥n de bajo nivel optimizadas predefinidas que se agregan a la placa de la CPU de Cairo para realizar c√°lculos predefinidos que son caros de realizar en vainilla Cairo (por ejemplo, verificaciones de rango, hash de Pedersen, ECDSA, ... ).</p>
<p>Poseid√≥n es una familia de funciones hash dise√±adas para ser muy eficientes como circuitos algebraicos. Como tales, pueden ser muy √∫tiles en sistemas de prueba ZK como STARK y otros</p>
<p>La comunicaci√≥n entre la CPU y los builds se realiza a trav√©s de la memoria: a cada incorporado se le asigna un √°rea continua en la memoria y aplica algunas restricciones (dependiendo de la definici√≥n incorporada) en las celdas de memoria en esa √°rea. En t√©rminos de construcci√≥n del AIR, significa que agregar incorporaciones no afecta las restricciones de la CPU. Simplemente significa que la misma memoria se comparte entre la CPU y las incorporaciones.</p>
<p>Para <code>invocar</code> un incorporado, el programa de El Cairo <code>se comunica</code> con ciertas celdas de memoria, y el incorporado impone algunas restricciones en esas celdas de memoria.</p>
<p>Gas por built = https://docs.starknet.io/documentation/architecture_and_concepts/Fees/fee-mechanism/#general_case</p>
<p>VM cpu AIR = circuitos integrados en cairo, no hace falta circom, aritmet se hace nativo, builtin, Dynamic layout (bosque oscuro....)</p>
<p>Desde Lambda se hicieron pruebas para exportar Circom, Snark, Groth16, Plonk</p>
<p>Circom = https://github.com/lambdaclass/circom_export_to_cairo</p>
<p>Vm en rust con sequencer en rust, mejoras de 10 x (lanzado en v.0.12 haremos pruebas tps y mps en explorador) posible consenso BFT</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sierra---ir"><a class="header" href="#sierra---ir">Sierra - IR</a></h1>
<p>En este apartadao detallaremos m√°s la sint√°xis del lenguague que su de finici√≥n de IR, que podra revisar en la <a href="">secci√≥n</a></p>
<ul>
<li><strong>Variables mutables:</strong> En un lenguaje de programaci√≥n tradicional, cada variable est√° asociada con una celda de memoria espec√≠fica, una ubicaci√≥n en la memoria de la computadora donde se almacenan los datos de la variable. Cuando a una variable se le asigna un valor, el valor se almacena en la celda de memoria asociada con esa variable. La variable puede acceder o modificar el valor almacenado en esa celda de memoria durante la ejecuci√≥n del programa.</li>
</ul>
<p>Sin embargo, en Cairo, es imposible modificar el contenido de una celda de memoria a la que ya se ha escrito.</p>
<p>Las variables mutables son el az√∫car sint√°ctico que permite a los desarrolladores de El Cairo modificar y actualizar sin esfuerzo los valores de datos a lo largo de la ejecuci√≥n de un programa sin tener que seguir manualmente la variable declarada anteriormente. Cuando modificamos nuestra variable mutable x, la variable Sierra correspondiente que almacena su valor se descarta primero ya que ya no se usa, y luego se crea una nueva variable con el valor actualizado</p>
<p>Del mismo modo, para una variable no mutable y, cuyo valor est√© sombreado, el procedimiento en Sierra es exactamente el mismo: el valor anterior se cae y uno nuevo se instancia con el valor actualizado asociado con y. Sin embargo, se recomienda usar variables mutables en lugar de sombrear donde sea posible, ya que garantiza la consistencia en los tipos.</p>
<ul>
<li>
<p><strong>Referencias:</strong> En los idiomas tradicionales, ‚Äúpass-by-reference‚Äù es un m√©todo para pasar variables a funciones donde la funci√≥n recibe una referencia a la ubicaci√≥n de memoria de la variable. Esto permite que la funci√≥n modifique el valor de la variable directamente. En Cairo, el equivalente se logra utilizando el ref modificador al definir el par√°metro de funci√≥n. Sin embargo, como se dijo anteriormente, es esencial tener en cuenta que una vez que los valores variables asignados no se pueden modificar directamente en Cairo, a diferencia de otros idiomas.</p>
</li>
<li>
<p><strong>Snapshot:</strong> En el lenguaje de programaci√≥n de Cairo, las instant√°neas se introducen como un tipo de envoltura que crea una vista inmutable de un objeto en un momento dado. Las instant√°neas son √∫tiles cuando necesitamos realizar en tipos no duplicables como matrices. En la implementaci√≥n del tiempo de ejecuci√≥n, las instant√°neas son abstracci√≥n de costo cero debido al modelo de memoria escrita de la Asamblea de Cairo.</p>
</li>
</ul>
<p>En el <a href="https://github.com/starkware-libs/cairo/blob/main/crates/cairo-lang-sierra/src/extensions/modules/snapshot.rs#L37">crates cairo-lang-sierra</a>, aprendemos que una instant√°nea es solo una envoltura alrededor de un objeto que garantiza que el objeto original no se modifique. los snapshot_take libfunc solo devuelve una instant√°nea al tipo si el tipo no se puede copiar. Los tipos duplicables son su propia instant√°nea, ya que la instant√°nea en s√≠ misma es in√∫til si podemos duplicar el valor. Este concepto de instant√°neas solo existe en el nivel Sierra y hace que el sistema de tipo lineal sea efectivo al garantizar que el objeto envuelto en una instant√°nea no pueda modificarse.</p>
<p>Pero, ¬øcu√°ndo encontramos instant√°neas particularmente √∫tiles? Espec√≠ficamente cuando se trabaja con tipos no duplicables como Arrays. En el siguiente c√≥digo, una funci√≥n foo toma como par√°metro una matriz a. Una instant√°nea de esta matriz se pasa a dos funciones, y luego se devuelve la matriz.</p>
<p>Cuando una funci√≥n lleva una instant√°nea a un valor usando @, solo puede leer el valor y no modificarlo. Se comporta como un pr√©stamo inmutable usando &amp; en Rust, que permite que varias partes del programa lean el mismo valor simult√°neamente y se asegura de que no se modifique. Cuando trabaja con objetos no copiables, el uso de instant√°neas le permite retener la propiedad del objeto en el contexto de llamada y garantizar que el objeto permanezca inalterado.</p>
<ul>
<li><strong>Function inlining:</strong> La combinaci√≥n de funciones es una t√©cnica de optimizaci√≥n del compilador que sustituye una llamada de funci√≥n con el c√≥digo real de la funci√≥n que se llama. Elimina la sobrecarga de una llamada de funci√≥n integrando el c√≥digo de la funci√≥n directamente en la funci√≥n de llamada.</li>
</ul>
<p>El compilador de El Cairo reemplazar√° autom√°ticamente las llamadas a funciones marcadas como en l√≠nea directamente con su c√≥digo Sierra. Esta optimizaci√≥n es especialmente √∫til para funciones peque√±as frecuentemente llamadas. Inlining puede reducir la sobrecarga de las llamadas a funciones y conducir a ejecuciones m√°s r√°pidas y optimizadas, ya que los valores no necesitan ser recordados.</p>
<p>Resumen: Hemos explorado algunos conceptos centrales de El Cairo 1, como variables mutables, referencias e instant√°neas. Hemos visto c√≥mo las variables mutables en El Cairo son equivalentes a las variables sombreadas en Sierra y c√≥mo las referencias en El Cairo usan el ref prefijo para pasar variables e impl√≠citamente devolverlas. Adem√°s, hemos visto c√≥mo las instant√°neas en El Cairo son un concepto √∫nico que permite a los desarrolladores mantener la propiedad de los objetos al tiempo que garantiza que el valor original permanezca sin modificar. Finalmente, exploramos c√≥mo los desarrolladores pueden usar la funci√≥n como una t√©cnica de optimizaci√≥n.</p>
<p>Cairo = Mejoras unicas en cairo?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cairo-native---mlir"><a class="header" href="#cairo-native---mlir">Cairo Native - MLIR</a></h1>
<p>MLIR significa <code>(Intermediate Representation for Multi-Level Intermediate Representations)</code>, (Representaci√≥n Intermedia M√∫ltiNivel). Se refiere a un lenguaje de representaci√≥n intermedia dise√±ado para ser flexible y adaptable a diferentes requisitos en una infraestructura unificada.</p>
<p>A diferencia de <a href="https://llvm.org/docs/LangRef.html#introduction">LLVM IR</a>, que tiene una √∫nica representaci√≥n intermedia central que abarca un conjunto completo de instrucciones para representar programas de CPU/GPU, MLIR adopta un enfoque diferente. En MLIR, no existe una √∫nica representaci√≥n intermedia unificada.</p>
<blockquote>
<p>MLIR tiene como objetivo abordar la fragmentaci√≥n del software, mejorar la compilaci√≥n de hardware heterog√©neo, reducir significativamente el costo de construir compiladores espec√≠ficos de dominio y ayudar a conectar compiladores existentes.</p>
</blockquote>
<p>En su lugar, MLIR introduce conceptos abstractos como dialectos, operaciones y regiones. Estos conceptos permiten la definici√≥n de diferentes dialectos o lenguajes especializados, cada uno con su propio conjunto de operaciones y reglas sem√°nticas espec√≠ficas.</p>
<p>La idea detr√°s de MLIR es brindar una infraestructura flexible que pueda adaptarse a m√∫ltiples requisitos y necesidades en el √°mbito de la representaci√≥n intermedia. Esto significa que se pueden definir dialectos espec√≠ficos para diferentes dominios, como procesadores espec√≠ficos, aceleradores o incluso lenguajes de programaci√≥n espec√≠ficos.</p>
<p>En resumen, MLIR busca proporcionar una forma flexible y modular de representar programas en un nivel intermedio, permitiendo la adaptabilidad a diferentes requisitos y escenarios mediante el uso de dialectos y operaciones espec√≠ficas de cada dominio.</p>
<blockquote>
<p>En otras palabras, si LLVM IR est√° centralizado por la naturaleza y favorece los flujos unificados del compilador, la infraestructura MLIR y su ecosistema de dialecto est√°n descentralizados por la naturaleza y favorecen los diversos flujos del compilador. Lo que es bastante poderoso es que MLIR permite representar diferentes niveles utilizando la misma infraestructura, para que el flujo entre diferentes niveles pueda ser continuo.</p>
</blockquote>
<p>La mayor√≠a de los protocolos ZKP implican aritmetizaci√≥n, que es el proceso de representar el c√°lculo en un formato num√©rico que puede utilizar el sistema de prueba, generalmente tomando las instrucciones en el c√°lculo y construyendo un gr√°fico de expresi√≥n de operaciones en bits llamado circuito aritm√©tico y luego generando un seguimiento de ejecuci√≥n, que muy brevemente es una matriz de elementos de campo que representan la evoluci√≥n del c√°lculo a lo largo del tiempo. Este rastro de ejecuci√≥n se alimenta al probador.</p>
<p>Para encapsular estos procesos, las m√°quinas virtuales se han dise√±ado e implementado para generar estos rastros de ejecuci√≥n num√©ricos y proporcionar garant√≠as computacionales, como <a href="https://github.com/0xPolygonMiden/miden-vm?ref=notamonadtutorial.com">Miden</a> y <a href="https://github.com/lambdaclass/cairo-rs/pulls?ref=notamonadtutorial.com">cairo-rs</a>. Una vez que tenga una m√°quina virtual, necesita un compilador y una representaci√≥n intermedia.</p>
<p>Tampoco puede aceptar ning√∫n programa, ya que necesita saber que su ejecuci√≥n es demostrable a menos que est√© dispuesto a asumir la posibilidad de programas no terminales, transacciones inv√°lidas que consumen gas excesivo, la producci√≥n de trazas inv√°lidas o incompletas, y que el probador simplemente renuncie en el medio. La teor√≠a de tipos y las representaciones intermedias dentro de los compiladores se han convertido en una de las herramientas m√°s potentes para producir c√≥digo que tiene propiedades que podemos razonar y verificar mec√°nicamente.</p>
<p>En resumen, la necesidad de ejecutar hardware m√°s diverso, incorporar tecnolog√≠a de lenguaje de programaci√≥n, para permitir el uso f√°cil de primitivas criptogr√°ficas complejas, Para transportar garant√≠as de herramientas de desarrolladores a capas de ejecuci√≥n, todos se han unido para lograr un peque√±o renacimiento de la implementaci√≥n del lenguaje en el mundo criptogr√°fico.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="herodotus---storage-proof"><a class="header" href="#herodotus---storage-proof">Herodotus - Storage Proof</a></h1>
<p>En el mundo de los sistemas descentralizados y la tecnolog√≠a blockchain, garantizar la precisi√≥n y autenticidad de los datos es de suma importancia. A medida que el ecosistema evoluciona, se hace cada vez m√°s necesario compartir informaci√≥n a trav√©s de diferentes cadenas, lo que lleva al desarrollo de soluciones innovadoras para verificar la integridad de los datos sin sacrificar la seguridad o la eficiencia. Una de esas soluciones es el uso de Storage Proof .</p>
<p>Las Storage Proof  ofrecen un m√©todo criptogr√°fico para rastrear y compartir informaci√≥n de blockchain a trav√©s de cadenas, similar a los or√°culos. Sin embargo, la diferencia clave radica en el modelo de confianza.</p>
<p>Las Storage Proof  proporcionan inherentemente una prueba de autenticidad sin depender de la confianza de terceros. En algunas situaciones, incluso pueden reemplazar o complementar los or√°culos, allanando el camino para nuevos casos de uso y aplicaciones en el ecosistema blockchain.</p>
<p>Imagina que tienes un libro gigante lleno de informaci√≥n y quieres demostrar que un dato concreto est√° en ese libro, en lugar de pedir a alguien que revise todo el libro para encontrar la informaci√≥n, se utiliza un sistema inteligente (en nuestro caso, la criptograf√≠a) para crear una peque√±a prueba que pueda demostrar f√°cilmente la presencia de la informaci√≥n en el libro. Esta prueba es lo que llamamos una Storage Proof.</p>
<p>En el contexto de las cadenas de bloques, estos libros gigantes son las bases de datos que almacenan todas las transacciones y datos de la red. Las Storage Proof permiten crear una prueba peque√±a y verificable de que ciertos datos existen dentro del estado del blockchain en un momento determinado. Para ello se utilizan t√©cnicas criptogr√°ficas incorporadas al propio almacenamiento.</p>
<p>Las cadenas de bloques utilizan varias estructuras de datos, como los √°rboles Merkle, los √°rboles Merkle Patricia y los √°rboles Verkle, para comprometer criptogr√°ficamente sus datos. Utilizando estas estructuras de datos, se pueden generar Storage Proof  para demostrar que una informaci√≥n espec√≠fica forma parte de un estado determinado. Sin embargo, cuando se utilizan solas, estas pruebas pueden llegar a ser bastante grandes, lo que las hace poco pr√°cticas para la verificaci√≥n en cadena. Para superar este problema, las Storage Proof  suelen combinarse con t√©cnicas criptogr√°ficas avanzadas, como STARK o SNARK, para crear pruebas m√°s peque√±as y eficientes que puedan verificarse en cualquier dominio sin confiar en terceros. En su lugar, la seguridad y la confianza proceden de la propia blockchain subyacente.</p>
<p>Las Storage Proof  le permiten abrir compromisos criptogr√°ficos de estado. Se pueden optimizar al unirlos con S [ N / T ] ARKS. . Estas pruebas de validez prueban que exist√≠a un estado en particular y que era v√°lido en un bloque en particular en el pasado.</p>
<p>Fundamentalmente, las cadenas de bloques son bases de datos que contienen datos comprometidos criptogr√°ficamente utilizando (√°rboles Merkle, √°rboles Merkle Patricia, √°rboles Verkle, etc. ). Como todos los datos est√°n comprometidos, podemos demostrar que cierta informaci√≥n est√° encapsulada en un estado dado. Sin embargo, con esquemas de compromiso simples, el tama√±o de esta prueba se vuelve m√°s prominente a medida que el tama√±o de los datos que incluye se hace m√°s grande. Verificar tales pruebas en cadena se vuelve demasiado costoso para ser pr√°ctico.</p>
<p>Las Storage Proof , por otro lado, cuando se usan junto con <code>STARK</code> o <code>SNARK</code>, pueden ser relativamente peque√±as y le permiten verificar un estado espec√≠fico, en un momento espec√≠fico y en cualquier dominio,  <code>sin confiar en un tercero</code>. En su lugar, conf√≠an en la seguridad de la cadena subyacente.</p>
<p>¬øPor qu√© es esto importante? Ethereum hoy no es la cadena monol√≠tica simple (L1) que era hace varios a√±os. Con el advenimiento de las soluciones L2, los datos ahora se distribuyen en m√∫ltiples cadenas.</p>
<p>Ya no se pueden hacer suposiciones sincr√≥nicas sobre el estado de la cadena. Muchas soluciones para compartir datos ahora est√°n en vivo, como los sistemas de mensajer√≠a <code>L1 -&gt; L2</code>, puentes entre cadenas y or√°culos. Pero el problema con estas soluciones actuales es que incluyen la confianza en un tercero, como los relevistas, los firmantes multisig y los comit√©s. Las Storage Proof  nos permiten validar el estado de una cadena de bloques en cualquier momento utilizando compromisos criptogr√°ficos sin asumir la confianza de un tercero.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arquitectura-herodotus"><a class="header" href="#arquitectura-herodotus">Arquitectura Herodotus</a></h1>
<p>Cada despliegue de contratos inteligentes de Her√≥doto que admite una cadena espec√≠fica consta de los siguientes contratos:</p>
<ol>
<li><strong>Commitments inbox:</strong>  Este contrato es responsable de procesar y verificar la validez de otros compromisos de la cadena, como bloqueos o ra√≠ces estatales.</li>
<li><strong>Headers store:</strong>  Esto contrata almacena y permite procesar encabezados desde un punto dado hasta la g√©nesis al afirmar que <code>blockhash(x - 1) = parenthash(x)</code>.</li>
<li><strong>Facts registry:</strong> Este contrato realiza la verificaci√≥n de Storage Proof  y almacena los valores solicitados en su estado.</li>
</ol>
<p><img src="./assets/Herodotus.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commitments-inbox"><a class="header" href="#commitments-inbox">Commitments Inbox</a></h1>
<p>Cada vez que se accede a datos provenientes de un dominio diferente en otro dominio, se requiere un compromiso para asegurar su correcci√≥n criptogr√°fica. Estos compromisos pueden ser:</p>
<ol>
<li>State root</li>
<li>Block hash</li>
<li>Transactions root</li>
<li>Receipts root</li>
</ol>
<p>El contrato <code>CommitmentsInbox</code> se encarga de recibir y gestionar estos compromisos. Los compromisos pueden entregarse de diversas formas, como:</p>
<ol>
<li>Recibir mensajes as√≠ncronos.</li>
<li>Validar el consenso de la red de manera verificable (disponible solo para L2 descentralizados).</li>
<li>Utilizar relayers optimistas.</li>
</ol>
<p>Una vez que un compromiso es aceptado por el <code>CommitmentsInbox</code>, se pasa al <code>HeadersStore</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="headers-store"><a class="header" href="#headers-store">Headers Store</a></h1>
<p>El contrato HeadersStore refleja los encabezados de las cadenas admitidas en el almacenamiento del state de este contrato. Estos encabezados solo pueden agregarse si el del encabezado <code>parentHash</code> ya ha sido pasado al <code>CommitmentsInbox</code>.</p>
<p>Cualquier persona puede enviar encabezados, pero un encabezado solo es v√°lido si su hash calculado en la cadena coincide con el hash certificado previamente por el <code>CommitmentsInbox</code>.</p>
<p>Cada vez que se procesa un encabezado, se guarda el hash de su encabezado padre en el estado del contrato para permitir que el encabezado anterior en la cadena se procese de la misma manera.</p>
<p>Al procesar un bloque, sus par√°metros pueden guardarse en el estado inteligente de los contratos. Cada cadena blockchain contiene diferentes par√°metros en su encabezado. Por ejemplo, un encabezado de EVM en Ethereum L1 contiene las siguientes propiedades:</p>
<ul>
<li><a href="https://ethereum.org/en/developers/docs/gas/#base-fee"><strong>baseFeePerGas</strong></a></li>
<li><a href="https://ethereum.org/en/glossary/#difficulty"><strong>difficulty</strong></a></li>
<li><a href=""><strong>extraData</strong></a></li>
<li><a href="https://ethereum.org/en/glossary/#gas-limit"><strong>gasLimit</strong></a></li>
<li><a href=""><strong>gasUsed</strong></a></li>
<li><a href=""><strong>parentHash</strong></a></li>
<li><a href=""><strong>receiptsRoot</strong></a></li>
<li><a href=""><strong>transactionsRoot</strong></a></li>
<li><a href=""><strong>stateRoot</strong></a></li>
<li><a href=""><strong>timestamp</strong></a></li>
<li><a href=""><strong>logsBloom</strong></a></li>
<li><a href=""><strong>nonce</strong></a></li>
<li><a href=""><strong>miner</strong></a></li>
<li><a href=""><strong>mixHash</strong></a></li>
<li><a href=""><strong>sha3Uncles</strong></a></li>
<li><a href=""><strong>number</strong></a></li>
<li><a href=""><strong>extraData</strong></a></li>
</ul>
<p>La especificaci√≥n de los par√°metros que deben guardarse se realiza mediante un valor entero que codifica un mapa desde el √≠ndice del par√°metro hasta si debe guardarse o no. Los √≠ndices para cada par√°metro son:</p>
<ul>
<li><code>PARENT_HASH = 0</code></li>
<li><code>UNCLES_HASH = 1</code></li>
<li><code>MINER = 2</code></li>
<li><code>STATE_ROOT = 3</code></li>
<li><code>TRANSACTION_ROOT = 4</code></li>
<li><code>RECEIPTS_ROOT = 5</code></li>
<li><code>LOGS_BLOOM = 6</code></li>
<li><code>DIFFICULTY = 7</code></li>
<li><code>BLOCK_NUMBER = 8</code></li>
<li><code>GAS_LIMIT = 9</code></li>
<li><code>GAS_USED = 10</code></li>
<li><code>TIMESTAMP = 11</code></li>
<li><code>EXTRA_DATA = 12</code></li>
<li><code>MIX_HASH = 13</code></li>
<li><code>NONCE = 14</code></li>
<li><code>BASE_FEE = 15</code></li>
</ul>
<p>Por ejemplo, para establecer solo la <code>STATE_ROOT</code>, el valor para ese par√°metro ser√≠a 8, ya que su representaci√≥n binaria es <code>000000000001000</code>, lo cual es igual a <code>2^3</code>, donde <code>3</code> es el √≠ndice de la <code>STATE_ROOT</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="facts-registry"><a class="header" href="#facts-registry">Facts Registry</a></h1>
<p>Este es el √∫ltimo contrato en la pila b√°sica de Herodotus y optimiza el proceso de acceso a las propiedades de una cuenta, como:</p>
<p>Nonces (si est√°n disponibles).</p>
<p>Saldos (si est√°n disponibles).</p>
<p>Storage hash.</p>
<p>Code hash.</p>
<p>El primer nivel de almacenamiento en las blockchains basadas en cuentas son las propias cuentas. Para probarlas, es necesario tener acceso a la stateRoot, cuya correcci√≥n se verifica mediante el contrato HeadersStore. Con dicha ra√≠z del estado, se puede verificar una prueba de MPT que demuestra las propiedades mencionadas de una cuenta.</p>
<p>Estas propiedades, de manera similar a HeadersStore, se pueden guardar en el estado para reducir la cantidad de c√°lculos necesarios cada vez que se accede al almacenamiento del contrato inteligente.</p>
<p>Acceso al almacenamiento del contrato</p>
<p>Como se mencion√≥ anteriormente, el primer nivel de almacenamiento son las cuentas. El segundo nivel es el almacenamiento real del contrato. Este almacenamiento se guarda en un √°rbol Merkle Patricia Tree, donde la ra√≠z es el StorageHash de la cuenta. Al ser un √°rbol Merkle Patricia, se puede probar cualquier cosa incluida en √©l.</p>
<p>Esto permite que Herodotus habilite el acceso al almacenamiento de los contratos inteligentes. El almacenamiento de los contratos inteligentes es una base de datos de clave-valor donde cada clave corresponde a 32 bytes de datos.</p>
<p>Para obtener m√°s informaci√≥n sobre c√≥mo asignar un nombre de variable a su clave de almacenamiento, consulte la documentaci√≥n de Solidity. Recomendamos encarecidamente utilizar esta gu√≠a cuando se trabaja con el dise√±o del almacenamiento de contratos inteligentes en Solidity.</p>
<div style="break-before: page; page-break-before: always;"></div><p>El uso de una API para solicitar Storage Proof  es sencillo, pero creemos que todav√≠a no es lo suficientemente simple. Hoy anunciamos Herodotus Turbo üõ∞</p>
<p>Turbo permitir√° una interoperabilidad 100% sin confianza entre las capas 2 de Ethereum con solo escribir una l√≠nea de c√≥digo.</p>
<p>https://twitter.com/HerodotusDev/status/1682400907969822722</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="casos-de-usos"><a class="header" href="#casos-de-usos">Casos de Usos</a></h1>
<p>Dado que las Storage Proof  nos permiten comprimir eficientemente ‚Äú ‚Äù una cadena de bloques y transmitir los datos a otra parte, tienen bastantes aplicaciones. El costo de verificaci√≥n asequible, una propiedad integral de las Storage Proof , permite validar la prueba en el destino cadena, minimizando la necesidad de desarrollar sistemas de mensajer√≠a entre cadenas.</p>
<p>Los casos de uso potencial incluyen:</p>
<ul>
<li><strong>Acceso a informaci√≥n general</strong> de una cadena de otra sobre el estado y las transacciones en la cadena de bloques.</li>
<li><strong>Sistemas de votaci√≥n entre cadenas simplificados</strong> Con frecuencia, los usuarios mantienen sus activos en una cadena A lenta pero m√°s segura, pero se produce una votaci√≥n basada en tokens en una cadena B con transacciones m√°s baratas. Esto obliga al usuario a omitir su voto o pagar enormes tarifas de transacci√≥n para unir sus activos de la A a la B, emitir su voto y luego obligarlos a la A. En tales casos, las Storage Proof  permiten a los usuarios probar su equilibrio de fichas en la cadena A en un bloque dado y emitir su voto a la perfecci√≥n en la cadena B.</li>
<li><strong>Alternativa a los puentes entre cadenas.</strong> Actualmente, los puentes entre cadenas asumen un nivel de confianza en un tercero porque generalmente involucran a un intermediario, como un custodio o una organizaci√≥n aut√≥noma descentralizada ( DAO ). Este intermediario es responsable de garantizar que el intermediario reciba una cierta cantidad de tokens en la cadena de origen y de mantener los activos en la cadena de origen. Posteriormente, las fichas correspondientes se acu√±an en la cadena de destino. Las Storage Proof  pueden permitir puentes sin confianza entre cadenas, ya que una aplicaci√≥n de contrato inteligente en la cadena de destino podr√≠a validar una transacci√≥n en la que los activos se transfirieron al contrato inteligente del puente en la cadena de origen y acu√±ar los activos puenteados. Sin embargo,en muchos casos, la necesidad de transferir activos entre cadenas puede eliminarse ya que la propiedad de los activos en otra cadena podr√≠a demostrarse simplemente con Storage Proof .</li>
<li><strong>UX mejorado para la abstracci√≥n de la cuenta ( AA ) casos de uso.</strong> AA se ha implementado en diferentes cadenas y se considera una innovaci√≥n crucial para incorporar a los primeros mil millones de usuarios al espacio blockchain. Con Storage Proof , las billeteras podr√≠an incluir la funcionalidad adicional de restaurar el acceso solo si la billetera no envi√≥ ninguna transacci√≥n durante una larga duraci√≥n. Tambi√©n se podr√≠an hacer cumplir verificaciones adicionales que requieren que algunos datos se utilicen de otras cadenas.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ejemplos-storage-proof"><a class="header" href="#ejemplos-storage-proof">Ejemplos Storage Proof</a></h1>
<p>Generar Storage Proof en cadenas compatibles con EVM es sencillo. Por ejemplo, la biblioteca Web3.js tiene la funci√≥n <code>getProof</code> que puede generar pruebas del estado de un contrato en Ethereum (y otras cadenas compatibles con EVM como Polygon, BSC, L2 Optimism...). Una direcci√≥n de contrato y la ranura de almacenamiento para el contrato deben ser pasados a la funci√≥n.</p>
<p>En Ethereum, los contratos inteligentes utilizan un almac√©n de clave-valor para almacenar los datos en su almac√©n. Cada dato se almacena en una ubicaci√≥n espec√≠fica conocida como <code>ranura de almacenamiento</code>. Las ranuras de almacenamiento son ubicaciones de memoria dentro del almacenamiento del contrato y se identifican mediante un √≠ndice √∫nico. Veamos un ejemplo de contrato inteligente con el siguiente c√≥digo desplegado en la mainnet de Ethereum.</p>
<p><img src="./assets/storage.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>La variable owner se almacenar√≠a en la ranura <code>0</code>. Ahora, para generar la prueba de que el owner de este contrato era una <code>direcci√≥n A</code>, podemos utilizar la funci√≥n <code>getProof</code> de la siguiente manera:</p>
<p><img src="./assets/storage1.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>El resultado del c√≥digo anterior es algo parecido a esto:</p>
<p><img src="./assets/storage2.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>El <code>storageProof</code> devuelto contiene la prueba de almacenamiento para la variable <code>owner</code>. Dado que Ethereum utiliza Merkle Patricia Trees para comprometer su estado, el estado de las cuentas y su almacenamiento, el almacenamiento generado puede ser utilizado para probar una ranura de almacenamiento (o estado de la cuenta). Sin embargo, como se ha indicado anteriormente, estas pruebas no son lo suficientemente escalables como para discutir las transferencias de mensajes entre cadenas, para ello el uso de complejas matem√°ticas ZK sobre esto puede disminuir el c√°lculo necesario para verificar la prueba.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proyectos-shh-y-hackaton"><a class="header" href="#proyectos-shh-y-hackaton">Proyectos SHH y Hackaton</a></h1>
<ul>
<li><a href="https://devfolio.co/projects/starksight-5d82"><strong>StarkSight:</strong></a> Use Worldcoin (Polygon) on Starknet. Storage proof of storage slot.</li>
<li><a href="https://643b0387a7ab7800083bb427--cosmic-unicorn-126e1a.netlify.app/"><strong>MAID:</strong></a> Proof of OG (Are you a long-time holder of this coin?). Historical storage proof of storage slot</li>
<li><a href="https://www.mergeswap.xyz/"><strong>Merge Swap:</strong></a> Use storage proof on PoW to PoS chain.</li>
</ul>
<h2 id="shh"><a class="header" href="#shh">SHH</a></h2>
<ul>
<li><a href="https://twitter.com/piapark_eth/status/1681312309032128515"><strong>Chess Dojo</strong></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merkle-mountain-ranges-en-cairo"><a class="header" href="#merkle-mountain-ranges-en-cairo">Merkle Mountain Ranges en Cairo</a></h1>
<p>Herodotus ha implementado una nueva estructura de datos criptogr√°fica llamada Merkle Mountain Ranges (MMR) en Cairo. Las MMR son una lista de √Årboles de Merkle, donde cada √°rbol se representa como una monta√±a y la lista completa forma el rango.</p>
<p>Las MMR comparten las propiedades comunes de los √Årboles de Merkle, como el almacenamiento eficiente de datos y la capacidad de generar pruebas de Merkle para demostrar la existencia de un elemento en el √°rbol. Sin embargo, tambi√©n ofrecen ventajas adicionales, como la eficiencia en la adici√≥n y actualizaci√≥n de elementos, detallemos algunas:</p>
<ul>
<li>La adici√≥n de un elemento a un MMR es mucho m√°s eficiente, ya que en la mayor√≠a de los casos no es necesario recorrer todo el √°rbol. La complejidad subyacente es log2(n) <code>puntas de monta√±a</code>.</li>
<li>Las pruebas de Merkle en un MMR se realizan mediante pruebas de tama√±o log2(n) que consisten en una ruta Merkle hasta la punta del √°rbol.</li>
<li>La actualizaci√≥n de un elemento tambi√©n se puede realizar de manera eficiente.</li>
<li>Es posible optimizar a√∫n m√°s al comparar inserciones y actualizaciones.</li>
<li>Tanto las inserciones como las actualizaciones se pueden implementar en cadena, lo que garantiza una total transparencia sobre c√≥mo se actualiza el √°rbol.</li>
</ul>
<p>Con esta nueva estructura de datos en Cairo, buscamos mejorar la eficiencia y verificabilidad del almacenamiento de datos en la plataforma, haci√©ndola √∫til para diversas aplicaciones que requieren almacenamiento y verificaci√≥n de datos en la cadena.</p>
<h2 id="esquema-de-firma-ecdsa-con-umbral"><a class="header" href="#esquema-de-firma-ecdsa-con-umbral">Esquema de firma ECDSA con umbral</a></h2>
<p>Algunas innovaciones que se ir√°n tratando como el esquema de firma ECDSA con umbral en bandeja de entrada de compromisos optimistas. </p>
<p>Para acceder al estado de diferentes cadenas, necesitamos acceder a las cabeceras de bloque, de las que podemos recuperar todo tipo de informaci√≥n (incluido el estado). Tenemos varias estrategias para obtener las cabeceras de bloque de diferentes cadenas, una de las cuales es un protocolo MPC que ejecuta un algoritmo de firma ECDSA de umbral. La salida del protocolo es una √∫nica firma que se validar√° en la cadena. Esto es mejor que tener una firma por parte, lo que es posible gracias a una ceremonia DKG (generaci√≥n de clave distribuida).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-proof-vs-oracle"><a class="header" href="#storage-proof-vs-oracle">Storage Proof Vs Oracle</a></h1>
<p>Las cadenas de bloques est√°n dise√±adas para no generar confianza, lo que significa que no pueden acceder intr√≠nsecamente a datos fuera de la cadena. Esta limitaci√≥n afecta a la capacidad de los contratos inteligentes para tomar decisiones basadas en eventos del mundo real o en informaci√≥n hist√≥rica de la cadena de bloques. Como soluci√≥n, se introdujeron los or√°culos para proporcionar a los contratos inteligentes datos fuera de la cadena o resultados de c√°lculos fuera de la cadena que consumen muchos recursos.</p>
<p>Los or√°culos suelen requerir que un tercero, como una instituci√≥n o una red descentralizada de operadores de nodos, env√≠e datos a la cadena. Aunque esto introduce un nivel de confianza, varios equipos, como Pragma, est√°n trabajando para minimizar este requisito de confianza.</p>
<p>Chainlink es un conocido or√°culo de blockchain que proporciona datos del mundo real, servicios de c√°lculo fuera de la cadena y servicios entre cadenas. Dado que los contratos inteligentes dependen actualmente de los or√°culos para obtener datos del mundo real, los or√°culos se han convertido en una parte crucial del ecosistema blockchain.</p>
<h2 id="pueden-los-or√°culos-ser-sustituidos-o-mejorados-por-storage-proof"><a class="header" href="#pueden-los-or√°culos-ser-sustituidos-o-mejorados-por-storage-proof">¬øPueden los or√°culos ser sustituidos o mejorados por Storage Proof?</a></h2>
<p>En algunos casos, las Storage Proof pueden sustituir a los or√°culos. Algunos datos proporcionados por los or√°culos ya est√°n disponibles en la cadena, y una prueba de almacenamiento puede eliminar la necesidad de confiar en un tercero, permitiendo que los contratos inteligentes se basen por completo en la seguridad de los compromisos criptogr√°ficos. Sin embargo, en otros casos en los que las Storage Proof  no pueden sustituir completamente a los or√°culos, pueden mejorarlos con una funcionalidad adicional:</p>
<ul>
<li>Las Storage Proof permiten realizar c√°lculos sobre datos de diferentes fuentes y exportar los resultados a otras cadenas, haciendo posible que los or√°culos transmitan informaci√≥n a trav√©s de m√∫ltiples cadenas.</li>
<li>Las Storage Proof pueden facilitar una validaci√≥n rentable en las cadenas de destino, ya que la cadena de origen preferida suele tener un c√°lculo barato.</li>
<li>L√≠deres en investigaci√≥n, como Herodotus, permiten el acceso a datos entre dominios a trav√©s de cadenas Ethereum utilizando Storage Proof y matem√°ticas ZK. Pragma planea asociarse con Herodotus para soportar or√°culos entre cadenas en un futuro pr√≥ximo.</li>
<li>Las Storage Proof pueden unificar el estado de m√∫ltiples rollups e incluso permitir lecturas s√≠ncronas entre capas Ethereum.</li>
<li>La recuperaci√≥n fiable de datos hist√≥ricos de la cadena es otra mejora posible gracias a las Storage Proof . Las cadenas de bloques con estado, como Ethereum y Starknet, preservan criptogr√°ficamente su estado a trav√©s de estructuras de datos especializadas, lo que permite probar la inclusi√≥n de datos. Esto permite a los contratos inteligentes acceder a informaci√≥n que se remonta al bloque de g√©nesis.</li>
</ul>
<p>Pragma est√° explorando el desarrollo de un or√°culo L3 en Starknet, que podr√≠a permitir a otras cadenas extraer y verificar datos utilizando Storage Proof. Los beneficios de tener un or√°culo L3 en una red computacionalmente barata como Starknet incluyen:</p>
<ul>
<li>Consenso m√°s r√°pido en bloques debido a la cadena L3 altamente personalizable, reduciendo significativamente la latencia de datos para el or√°culo.</li>
<li>Transferencia as√≠ncrona de datos de baja latencia a otras cadenas al alcanzar el consenso en la cadena de origen, en combinaci√≥n con Storage Proof .</li>
<li>Mayor confianza en los datos mediante un sistema incorporado para penalizar a los proveedores de datos deshonestos. Los proveedores de datos en la L3 podr√≠an poner en juego sus activos como garant√≠a de la exactitud de los datos. Como toda la red L3 debe alcanzar un consenso antes de que otras cadenas puedan utilizar los datos, los datos del or√°culo pueden considerarse garantizados por la apuesta de los validadores en L3.</li>
</ul>
<p>La creciente adopci√≥n de soluciones L2 de Ethereum, como Starknet, Optimism y Arbitrum, ha permitido vislumbrar el futuro del sector. Sin embargo, un reto clave que impide un mayor crecimiento es la implementaci√≥n de un sistema descentralizado de mensajer√≠a entre cadenas, las Storage Proof tienen un enorme potencial para resolver este problema.</p>
<p>En algunos casos, las Storage Proof pueden sustituir o mejorar los or√°culos, facilitando una comunicaci√≥n entre cadenas m√°s eficiente y el acceso a datos hist√≥ricos. Al reducir la dependencia de la confianza en terceros, las Storage Proof  pueden reforzar significativamente la seguridad y la eficiencia de las aplicaciones de blockchain.</p>
<p>A medida que el panorama de las cadenas de bloques siga evolucionando, podemos anticipar nuevos desarrollos e innovaciones en Storage Proof, or√°culos y comunicaci√≥n entre cadenas. Aprovechando estas tecnolog√≠as, el ecosistema blockchain puede mantener su crecimiento y ofrecer m√°s valor tanto a los usuarios como a los desarrolladores.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estado-de-oracles-en-starknet"><a class="header" href="#estado-de-oracles-en-starknet">Estado de Oracles en Starknet</a></h1>
<p>En la red de pruebas de Starknet, Chainlink proporciona datos de precios para siete pares de criptomonedas y se ha asociado con Starkware para acelerar el desarrollo y crecimiento de aplicaciones en el ecosistema de Starknet. Chainlink minimiza los supuestos de confianza a trav√©s de una red descentralizada de nodos, pero la agregaci√≥n de datos se produce fuera de la cadena.</p>
<p>Pragma y Stork Network son dos importantes proveedores de or√°culos en Starknet, que operan tanto en la mainnet como en la testnet. Ofrecen tickers de precios para m√∫ltiples pares de criptomonedas, y Pragma est√° trabajando en la implementaci√≥n de una fuente de aleatoriedad verificable en la mainnet para una aleatoriedad segura en la cadena. Las fuentes de precios de Pragma se basan en env√≠os de grandes instituciones y creadores de mercado, aprovechando la eficiente tecnolog√≠a ZK para la agregaci√≥n de precios en la cadena.</p>
<p>En resumen, tanto las Storage Proof  como los or√°culos son cruciales para facilitar la comunicaci√≥n entre cadenas y el acceso a datos fuera de la cadena. Mientras que los or√°culos son indispensables para los datos del mundo real, las Storage Proof  ofrecen una forma fiable y eficiente de transferir y verificar la informaci√≥n de la cadena de bloques entre cadenas. Juntos, ayudan a crear un ecosistema de cadenas de bloques m√°s s√≥lido e interconectado.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pragma---bases"><a class="header" href="#pragma---bases">Pragma - Bases</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainlink---bases"><a class="header" href="#chainlink---bases">Chainlink - Bases</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cairo---arquitectura"><a class="header" href="#cairo---arquitectura">Cairo - Arquitectura</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cairo-v2---nueva-versi√≥n-del-compilador"><a class="header" href="#cairo-v2---nueva-versi√≥n-del-compilador">Cairo v2 - Nueva versi√≥n del Compilador</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sint√°xis-b√°sica"><a class="header" href="#sint√°xis-b√°sica">Sint√°xis B√°sica</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>https://twitter.com/nodeguardians/status/1682410394864832514</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducci√≥n-parte-3"><a class="header" href="#introducci√≥n-parte-3">Introducci√≥n Parte 3</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="otras-arquitecturas"><a class="header" href="#otras-arquitecturas">Otras Arquitecturas</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>

<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>L2 Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="Introducci√≥n.html"><strong aria-hidden="true">1.</strong> Introducci√≥n Parte 1</a></li><li class="chapter-item "><a href="Bases_Criptogr√°ficas.html"><strong aria-hidden="true">2.</strong> Bases Criptogr√°ficas</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Criptograf√≠a_Sim√©trica.html"><strong aria-hidden="true">2.1.</strong> Criptograf√≠a Sim√©trica</a></li><li class="chapter-item "><a href="Criptograf√≠a_Asim√©trica.html"><strong aria-hidden="true">2.2.</strong> Criptograf√≠a Asim√©trica</a></li><li class="chapter-item "><a href="Criptograf√≠a_H√≠bridas.html"><strong aria-hidden="true">2.3.</strong> Criptograf√≠a H√≠bridas</a></li><li class="chapter-item "><a href="Firmas_Digitales.html"><strong aria-hidden="true">2.4.</strong> Firmas Digitales</a></li><li class="chapter-item "><a href="Generador_de_Claves.html"><strong aria-hidden="true">2.5.</strong> Generador de Claves</a></li><li class="chapter-item "><a href="Funciones_Hash.html"><strong aria-hidden="true">2.6.</strong> Funciones Hash</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Merkle_Tree_en_Blockchain.html"><strong aria-hidden="true">2.6.1.</strong> Merkle Tree en Blockchain</a></li><li class="chapter-item "><a href="Patricia_Merkle_Trie.html"><strong aria-hidden="true">2.6.2.</strong> Patricia Merkle Trie</a></li><li class="chapter-item "><a href="Sha256.html"><strong aria-hidden="true">2.6.3.</strong> SHA-256</a></li><li class="chapter-item "><a href="Keccak.html"><strong aria-hidden="true">2.6.4.</strong> Keccak - El nuevo SHA-3</a></li></ol></li><li class="chapter-item "><a href="Quantum_Secure.html"><strong aria-hidden="true">2.7.</strong> Quantum Secure</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Grover.html"><strong aria-hidden="true">2.7.1.</strong> Grover</a></li><li class="chapter-item "><a href="Shor.html"><strong aria-hidden="true">2.7.2.</strong> Shor</a></li><li class="chapter-item "><a href="Lattice.html"><strong aria-hidden="true">2.7.3.</strong> Lattice</a></li><li class="chapter-item "><a href="Kyber_Crystal.html"><strong aria-hidden="true">2.7.4.</strong> Kyber Crystal</a></li><li class="chapter-item "><a href="EOA_AA.html"><strong aria-hidden="true">2.7.5.</strong> EOA y AA - Firmantes</a></li></ol></li><li class="chapter-item "><a href="Starknet_AA.html"><strong aria-hidden="true">2.8.</strong> Starknet AA</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Stark_Curve.html"><strong aria-hidden="true">2.8.1.</strong> EC en Cairo - STARK Curve</a></li><li class="chapter-item "><a href="Secp256r1.html"><strong aria-hidden="true">2.8.2.</strong> MyBraavos Secp256r1</a></li><li class="chapter-item "><a href="Stark_Key.html"><strong aria-hidden="true">2.8.3.</strong> Creaci√≥n de una Stark Key en StarkEx</a></li></ol></li><li class="chapter-item "><a href="Starknet_funciones_hash.html"><strong aria-hidden="true">2.9.</strong> Starknet y Funciones Hash</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Keccak_Starknet.html"><strong aria-hidden="true">2.9.1.</strong> Hash Keccak</a></li><li class="chapter-item "><a href="Pedersen_Starknet.html"><strong aria-hidden="true">2.9.2.</strong> Hash Pedersen</a></li><li class="chapter-item "><a href="Poseidon_Starknet.html"><strong aria-hidden="true">2.9.3.</strong> Hash Poseidon</a></li><li class="chapter-item "><a href="Hashing_Array.html"><strong aria-hidden="true">2.9.4.</strong> Hashing de Array</a></li></ol></li><li class="chapter-item "><a href="Starks.html"><strong aria-hidden="true">2.10.</strong> S-T-ARKs</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Starks_Propiedades.html"><strong aria-hidden="true">2.10.1.</strong> Propiedades de las STARKs</a></li><li class="chapter-item "><a href="Starks_Eficientes.html"><strong aria-hidden="true">2.10.2.</strong> STARKs eficientes</a></li><li class="chapter-item "><a href="Starks_Iops.html"><strong aria-hidden="true">2.10.3.</strong> IOPs</a></li><li class="chapter-item "><a href="Starks_Polinomios.html"><strong aria-hidden="true">2.10.4.</strong> Polinomios</a></li></ol></li><li class="chapter-item "><a href="Starks_Creacion.html"><strong aria-hidden="true">2.11.</strong> Creaci√≥n de un STARK</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Starks_Aritmetizacion.html"><strong aria-hidden="true">2.11.1.</strong> Aritmetizaci√≥n</a></li><li class="chapter-item "><a href="Starks_Traza.html"><strong aria-hidden="true">2.11.2.</strong> Polinomio y Composici√≥n para nuestra Traza</a></li><li class="chapter-item "><a href="Starks_Bajo.html"><strong aria-hidden="true">2.11.3.</strong> Pruebas de Bajo Grado</a></li><li class="chapter-item "><a href="Starks_Fri.html"><strong aria-hidden="true">2.11.4.</strong> FRI</a></li></ol></li><li class="chapter-item "><a href="Cairo.html"><strong aria-hidden="true">2.12.</strong> Leve introducci√≥n a Cairo (AIR)</a></li><li class="chapter-item "><a href="Conclusi√≥n.html"><strong aria-hidden="true">2.13.</strong> Conclusiones</a></li></ol></li><li class="chapter-item "><a href="Introducci√≥n2.html"><strong aria-hidden="true">3.</strong> Introducci√≥n Parte 2 üöß</a></li><li class="chapter-item "><a href="Arquitectura_Starknet.html"><strong aria-hidden="true">4.</strong> Arquitectura Starknet y Cairo üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Componentes.html"><strong aria-hidden="true">4.1.</strong> Componentes üöß</a></li><li class="chapter-item "><a href="Secuenciadores.html"><strong aria-hidden="true">4.2.</strong> Secuenciadores üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Secuenciadores_Rust.html"><strong aria-hidden="true">4.2.1.</strong> Secuenciadores Basados en Rustüöß</a></li><li class="chapter-item "><a href="Madara_Base.html"><strong aria-hidden="true">4.2.2.</strong> Madara - Bases de su arquitectura üöß</a></li><li class="chapter-item "><a href="Kraken.html"><strong aria-hidden="true">4.2.3.</strong> Kraken - Secuencenciador descentralizadoüöß</a></li></ol></li><li class="chapter-item "><a href="Fullnode.html"><strong aria-hidden="true">4.3.</strong> Full Nodes - Starknet Stack üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Pathfinder.html"><strong aria-hidden="true">4.3.1.</strong> Pathfinder üöß</a></li><li class="chapter-item "><a href="Juno.html"><strong aria-hidden="true">4.3.2.</strong> Juno üöß</a></li><li class="chapter-item "><a href="Deoxys.html"><strong aria-hidden="true">4.3.3.</strong> Deoxys üöß</a></li><li class="chapter-item "><a href="Papyrus.html"><strong aria-hidden="true">4.3.4.</strong> Papyrus üöß</a></li></ol></li><li class="chapter-item "><a href="SHARP.html"><strong aria-hidden="true">4.4.</strong> SHARP üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="SHARP_Recursividad.html"><strong aria-hidden="true">4.4.1.</strong> Recursividad - SHARP üöß</a></li><li class="chapter-item "><a href="SHARP_Componentes.html"><strong aria-hidden="true">4.4.2.</strong> Componentes - SHARP üöß</a></li><li class="chapter-item "><a href="Playground.html"><strong aria-hidden="true">4.4.3.</strong> Playground üöß</a></li><li class="chapter-item "><a href="Cairo_Verifier_Rust.html"><strong aria-hidden="true">4.4.4.</strong> Cairo Verifier - Rust üöß</a></li></ol></li><li class="chapter-item "><a href="Quantum_Leap.html"><strong aria-hidden="true">4.5.</strong> Quantum Leap üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Versiones.html"><strong aria-hidden="true">4.5.1.</strong> Versiones üöß</a></li></ol></li><li class="chapter-item "><a href="Starknet_Stack.html"><strong aria-hidden="true">4.6.</strong> Starknet Stack üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Appchain_Paradex.html"><strong aria-hidden="true">4.6.1.</strong> AppChain Paradex - Starknet Stack üöß</a></li><li class="chapter-item "><a href="Lambda_Stack.html"><strong aria-hidden="true">4.6.2.</strong> Lambda Starknet Stack üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Watcher_Prover.html"><strong aria-hidden="true">4.6.2.1.</strong> Watcher-Prover üöß</a></li></ol></li></ol></li><li class="chapter-item "><a href="DA.html"><strong aria-hidden="true">4.7.</strong> Data Avalability üöß</a></li><li class="chapter-item "><a href="EVM_zkEVM.html"><strong aria-hidden="true">4.8.</strong> EVM vs zkEVM üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Kakarot_Base.html"><strong aria-hidden="true">4.8.1.</strong> Kakarot - Bases de su arquitectura üöß</a></li></ol></li><li class="chapter-item "><a href="VM_Cairo.html"><strong aria-hidden="true">4.9.</strong> VM de Cairo üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Builtins_y_mecanismos_de_fee.html"><strong aria-hidden="true">4.9.1.</strong> Builtins y Mecanismos de Fee üöß</a></li><li class="chapter-item "><a href="Sierra.html"><strong aria-hidden="true">4.9.2.</strong> Sierra - IR üöß</a></li><li class="chapter-item "><a href="Cairo_Native.html"><strong aria-hidden="true">4.9.3.</strong> Cairo Native - MLIR üöß</a></li></ol></li><li class="chapter-item "><a href="Storage_Proof.html"><strong aria-hidden="true">4.10.</strong> Herodotus - Storage Proof üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Arquitectura_Herodotus.html"><strong aria-hidden="true">4.10.1.</strong> Arquitectura Herodotus üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Commitments_Inbox.html"><strong aria-hidden="true">4.10.1.1.</strong> Commitments Inbox üöß</a></li><li class="chapter-item "><a href="Headers_Store.md.html"><strong aria-hidden="true">4.10.1.2.</strong> Headers Store üöß</a></li><li class="chapter-item "><a href="Facts_Registry.html"><strong aria-hidden="true">4.10.1.3.</strong> Facts Registry üöß</a></li></ol></li><li class="chapter-item "><a href="Herodotus_Turbo.html"><strong aria-hidden="true">4.10.2.</strong> Herodotus Turbo üöß</a></li><li class="chapter-item "><a href="Casos_de_uso.html"><strong aria-hidden="true">4.10.3.</strong> Casos de Usos üöß</a></li><li class="chapter-item "><a href="Ejemplos_Storage_Proof.html"><strong aria-hidden="true">4.10.4.</strong> Ejemplos Storage Proof üöß</a></li><li class="chapter-item "><a href="Proyectos_Storage_Proof.html"><strong aria-hidden="true">4.10.5.</strong> Proyectos SHH y Hackaton üöß</a></li><li class="chapter-item "><a href="Merkle_Mountain_Ranges.html"><strong aria-hidden="true">4.10.6.</strong> Merkle Mountain Ranges en Cairo üöß</a></li><li class="chapter-item "><a href="Storage_Proof_Oracle.html"><strong aria-hidden="true">4.10.7.</strong> Storage Proof Vs Oracle üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Estado_Oracle_Starknet.html"><strong aria-hidden="true">4.10.7.1.</strong> Estado de Oracles en Starknet üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Pragma.html"><strong aria-hidden="true">4.10.7.1.1.</strong> Pragma - Bases üöß</a></li><li class="chapter-item "><a href="Chainlink.html"><strong aria-hidden="true">4.10.7.1.2.</strong> Chainlink - Bases üöß</a></li><li class="chapter-item "><a href="Redstone.html"><strong aria-hidden="true">4.10.7.1.3.</strong> Redstone - Bases üöß</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><a href="Exploradores_de_bloques.html"><strong aria-hidden="true">4.11.</strong> Exploradores de Bloques üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Starkscan.html"><strong aria-hidden="true">4.11.1.</strong> Starkscan üöß</a></li><li class="chapter-item "><a href="Voyager.html"><strong aria-hidden="true">4.11.2.</strong> Voyager üöß</a></li><li class="chapter-item "><a href="Madara_Explorer.html"><strong aria-hidden="true">4.11.3.</strong> Madara üöß</a></li><li class="chapter-item "><a href="Elixir.html"><strong aria-hidden="true">4.11.4.</strong> Elixir üöß</a></li><li class="chapter-item "><a href="View_Block.html"><strong aria-hidden="true">4.11.5.</strong> View Block üöß</a></li></ol></li><li class="chapter-item "><a href="Arquitectura_Cairo.html"><strong aria-hidden="true">4.12.</strong> Cairo - Arquitectura üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Sintaxis_Basica.html"><strong aria-hidden="true">4.12.1.</strong> Sint√°xis B√°sica üöß</a></li><li class="chapter-item "><a href="Cairov2.html"><strong aria-hidden="true">4.12.2.</strong> Cairo v2 - Nueva versi√≥n del Compilador üöß</a></li></ol></li><li class="chapter-item "><a href="Node_Guardians.html"><strong aria-hidden="true">4.13.</strong> Node Guardians - Cairo Educacional üöß</a></li></ol></li><li class="chapter-item "><a href="Introducci√≥n3.html"><strong aria-hidden="true">5.</strong> Introducci√≥n Parte 3 üöß</a></li><li class="chapter-item "><a href="Otras_Arquitecturas.html"><strong aria-hidden="true">6.</strong> Otras Arquitecturas üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Lambda_en_Starknet.html"><strong aria-hidden="true">6.1.</strong> Lambda en Starknet üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Starknet_en_Rust.html"><strong aria-hidden="true">6.1.1.</strong> Starknet en Rust üöß</a></li><li class="chapter-item "><a href="Lambda_Prover_Platinum.html"><strong aria-hidden="true">6.1.2.</strong> Lambda Prover - Platinum üöß</a></li><li class="chapter-item "><a href="Lambda_Sequencer.html"><strong aria-hidden="true">6.1.3.</strong> Lambda Sequencer üöß</a></li><li class="chapter-item "><a href="Lambda_Work.html"><strong aria-hidden="true">6.1.4.</strong> LambdaWorks üöß</a></li></ol></li><li class="chapter-item "><a href="Madara.html"><strong aria-hidden="true">6.2.</strong> Madara üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Madara_Fusionando_Fuerzas.html"><strong aria-hidden="true">6.2.1.</strong> Madara - Fusionando Fuerzas üöß</a></li><li class="chapter-item "><a href="Sharingan.html"><strong aria-hidden="true">6.2.2.</strong> Sharingan üöß</a></li></ol></li><li class="chapter-item "><a href="Otros_Secuenciadores.html"><strong aria-hidden="true">6.3.</strong> Otros Secuenciadores üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Secuenciador_Katana.html"><strong aria-hidden="true">6.3.1.</strong> Katana üöß</a></li><li class="chapter-item "><a href="Secuenciador_Radius.html"><strong aria-hidden="true">6.3.2.</strong> Radius üöß</a></li><li class="chapter-item "><a href="Secuenciador_Kraken.html"><strong aria-hidden="true">6.3.3.</strong> Kraken üöß</a></li></ol></li><li class="chapter-item "><a href="Otros_Prover.html"><strong aria-hidden="true">6.4.</strong> Otros Prover üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Sandstorm.html"><strong aria-hidden="true">6.4.1.</strong> Sandstorm üöß</a></li></ol></li><li class="chapter-item "><a href="Kakarot.html"><strong aria-hidden="true">6.5.</strong> Kakarot üöß</a></li><li class="chapter-item "><a href="Dojo.html"><strong aria-hidden="true">6.6.</strong> Dojo üöß</a></li><li class="chapter-item "><a href="Giza.html"><strong aria-hidden="true">6.7.</strong> Giza üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Orion.html"><strong aria-hidden="true">6.7.1.</strong> Orion üöß</a></li></ol></li><li class="chapter-item "><a href="Cartridge.html"><strong aria-hidden="true">6.8.</strong> Cartridge üöß</a></li><li class="chapter-item "><a href="Visara.html"><strong aria-hidden="true">6.9.</strong> Vistara üöß</a></li><li class="chapter-item "><a href="Servicios_API.html"><strong aria-hidden="true">6.10.</strong> Servicios API üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Infura.html"><strong aria-hidden="true">6.10.1.</strong> Infura üöß</a></li><li class="chapter-item "><a href="Alchemy.html"><strong aria-hidden="true">6.10.2.</strong> Alchemy üöß</a></li></ol></li><li class="chapter-item "><a href="Indexer.html"><strong aria-hidden="true">6.11.</strong> Indexer üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Checkpoint.html"><strong aria-hidden="true">6.11.1.</strong> Checkpoint üöß</a></li><li class="chapter-item "><a href="Apibara.html"><strong aria-hidden="true">6.11.2.</strong> Apibara üöß</a></li><li class="chapter-item "><a href="Tokenflow.html"><strong aria-hidden="true">6.11.3.</strong> TokenFlow üöß</a></li><li class="chapter-item "><a href="Torii.html"><strong aria-hidden="true">6.11.4.</strong> Torii üöß</a></li></ol></li><li class="chapter-item "><a href="dApp_ecosistema.html"><strong aria-hidden="true">6.12.</strong> Dapp - Ecosistema üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Avnu.html"><strong aria-hidden="true">6.12.1.</strong> Avnu üöß</a></li></ol></li><li class="chapter-item "><a href="Recursos.html"><strong aria-hidden="true">6.13.</strong> Recursos üöß</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Cairo_by_example.html"><strong aria-hidden="true">6.13.1.</strong> Cairo by Example üöß</a></li><li class="chapter-item "><a href="Challegues.html"><strong aria-hidden="true">6.13.2.</strong> Challengues üöß</a></li><li class="chapter-item "><a href="Cairo_Book.html"><strong aria-hidden="true">6.13.3.</strong> Cairo book üöß</a></li><li class="chapter-item "><a href="Starknet_Book.html"><strong aria-hidden="true">6.13.4.</strong> Starknet book üöß</a></li><li class="chapter-item "><a href="Starkli.html"><strong aria-hidden="true">6.13.5.</strong> Starkli üöß</a></li><li class="chapter-item "><a href="Scarb.html"><strong aria-hidden="true">6.13.6.</strong> Scarb üöß</a></li><li class="chapter-item "><a href="Wizard.html"><strong aria-hidden="true">6.13.7.</strong> OZ - Wizard üöß</a></li><li class="chapter-item "><a href="Remix_Starknet.html"><strong aria-hidden="true">6.13.8.</strong> Remix - Starknet üöß</a></li><li class="chapter-item "><a href="Starknet_js.html"><strong aria-hidden="true">6.13.9.</strong> Starknet.js üöß</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">L2 Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introducci√≥n"><a class="header" href="#introducci√≥n">Introducci√≥n</a></h1>
<p>¬°Hola comunidad! üëã</p>
<p>Antes que nada nos gustar√≠a expresar nuestro m√°s sincero agradecimiento a todos aquellos que han contribuido y hecho posible la realizaci√≥n de esta exhaustiva investigaci√≥n y documento sobre criptograf√≠a y como se adaptan en StarkWare. Especial reconocimiento a los expertos que han colaborado en su creaci√≥n y a <a href="https://twitter.com/0xhasher_">Carlos</a> que ha brindado sus valiosas correcciones y orientaci√≥n en numerosos aspectos del trabajo. Sus experiencias y conocimientos han sido fundamentales para alcanzar los resultados y conclusiones presentados en este informe.</p>
<p>En esta ocasi√≥n, estamos emocionados de presentar una serie de art√≠culos profundos sobre el desarrollo detr√°s de Starkware. Recomendamos a los lectores que previamente hayan le√≠do otros documentos y tengan conocimientos t√©cnicos para una mejor comprensi√≥n, para este documento en concreto recomendamos:</p>
<p><a href="https://starkware.co/resource/stark-endgame/">Stark END-Game</a> | <a href="https://starkware.co/resource/stark-endgame/">Recursive Stark</a> |  <a href="https://starkware.co/resource/account-abstraction-improving-security-and-user-experience-for-mainstream-crypto-adoption/">Account Abstraction</a> | <a href="https://starkware.co/stark-math-a-very-short-primer/">Intro Maths Starks</a></p>
<p>El panorama actual es complejo, pero nos enorgullece contar con las mentes m√°s brillantes trabajando en el ecosistema, una STARK que los une a todos.</p>
<p>¬øEres o ser√°s uno de ellos? Antes de sumergirnos, exploraremos una serie de conceptos para establecer bases e historias sobre criptograf√≠a, lo que nos permitir√° adentrarnos a√∫n m√°s en el ecosistema STARKs. ¬°Comencemos!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bases-criptogr√°ficas"><a class="header" href="#bases-criptogr√°ficas">Bases Criptogr√°ficas</a></h1>
<p>La <a href="https://en.wikipedia.org/wiki/Cryptography"><strong>criptograf√≠a</strong></a> es el campo de estudio y desarrollo de t√©cnicas y algoritmos para asegurar la confidencialidad, integridad y autenticidad de la informaci√≥n. Utilizando claves secretas o p√∫blicas, <strong>la criptograf√≠a transforma los datos en un formato incomprensible para terceros no autorizados</strong>, garantizando que solo los destinatarios leg√≠timos puedan acceder a la informaci√≥n original. La criptograf√≠a desempe√±a un papel vital en la seguridad de las comunicaciones y el almacenamiento de datos, protegiendo la privacidad y la confianza en diversos √°mbitos de la vida moderna.</p>
<ul>
<li>
<p><strong>Encryption:</strong> <a href="https://en.wikipedia.org/wiki/Encryption">el cifrado</a> es el proceso de convertir informaci√≥n legible en un formato ilegible llamado texto cifrado, mediante el uso de algoritmos y una clave. El objetivo principal del cifrado es proteger la confidencialidad de los datos, asegurando que solo las personas autorizadas puedan acceder y comprender la informaci√≥n cifrada. Para ello, se aplica una serie de transformaciones matem√°ticas al texto original, lo que dificulta su interpretaci√≥n sin la clave correspondiente.</p>
</li>
<li>
<p><strong>Cryptographic protocol:</strong> <a href="https://en.wikipedia.org/wiki/Cryptographic_protocol">un protocolo criptogr√°fico</a> o protocolo de seguridad (tambi√©n llamado protocolo de cifrado) es un protocolo abstracto o concreto que realiza funciones relacionadas con la seguridad, aplicando m√©todos criptogr√°ficos.‚Äã Un protocolo describe la forma en que un algoritmo debe usarse.</p>
</li>
<li>
<p><strong>Algorithm:</strong> <a href="https://es.wikipedia.org/wiki/Algoritmo">un algoritmo</a> de cifrado es un procedimiento que convierte un mensaje de texto plano en un texto cifrado. Los algoritmos modernos utilizan matem√°ticas avanzadas y una o varias claves de cifrado. Esto hace que sea relativamente f√°cil cifrar un mensaje, pero pr√°cticamente imposible descifrarlo sin conocer las claves requeridas.</p>
</li>
</ul>
<h2 id="esquema-de-cifrado"><a class="header" href="#esquema-de-cifrado">Esquema de cifrado</a></h2>
<p>Estos esquemas definen c√≥mo se realiza la transformaci√≥n de los datos originales en texto cifrado y c√≥mo se realiza la operaci√≥n inversa para recuperar los datos originales a partir del texto cifrado. Un esquema de cifrado generalmente consta de los siguientes elementos:</p>
<ul>
<li>
<p><strong>Encryption Algorithm:</strong> vimos que es el conjunto de operaciones matem√°ticas utilizadas para cifrar los datos en texto cifrado.</p>
</li>
<li>
<p><strong>Decryption Algorithm:</strong> es el conjunto de operaciones matem√°ticas inversas utilizadas para descifrar el texto cifrado y recuperar los datos originales.</p>
</li>
<li>
<p><strong>Key:</strong> conocida como clave, es un valor secreto que se utiliza como entrada para el algoritmo de cifrado. La key determina c√≥mo se realiza la transformaci√≥n de los datos y es esencial para descifrar el texto cifrado.</p>
</li>
<li>
<p><strong>Protocols:</strong> establecen c√≥mo se utiliza el esquema de cifrado, incluyendo la generaci√≥n y distribuci√≥n segura de claves, el manejo de errores y la gesti√≥n de la seguridad.</p>
</li>
</ul>
<p>Existen varios tipos de esquemas de cifrado:</p>
<ol>
<li>
<p>El <a href="https://academy.bit2me.com/que-es-criptografia-simetrica/"><strong>cifrado sim√©trico</strong></a> (donde se utiliza una sola clave tanto para cifrar como para descifrar),</p>
</li>
<li>
<p>El <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_asim%C3%A9trica"><strong>cifrado asim√©trico</strong></a> o de clave p√∫blica (donde se utilizan pares de claves p√∫blica y privada)</p>
</li>
<li>
<p>Otras variantes de esquemas de cifrados como de <a href="https://es.wikipedia.org/wiki/Cifrador_de_flujo">flujo</a> y de <a href="https://es.wikipedia.org/wiki/Cifrado_por_bloques">bloque</a>. Cada esquema tiene sus propias caracter√≠sticas y se utiliza en diferentes contextos seg√∫n los requisitos de seguridad y las necesidades espec√≠ficas de la aplicaci√≥n, pero nos centraremos en las principales para entender su funcionamiento antes de pasar a la evoluci√≥n de las STARKs.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="criptograf√≠a-sim√©trica"><a class="header" href="#criptograf√≠a-sim√©trica">Criptograf√≠a Sim√©trica</a></h2>
<p>La historia de la criptograf√≠a sim√©trica se remonta a tiempos antiguos, pero su uso moderno se consolid√≥ en el siglo XX con el desarrollo de m√©todos m√°s sofisticados. Un ejemplo ic√≥nico es la <a href="https://en.wikipedia.org/wiki/Enigma_machine">m√°quina Enigma</a>, utilizada por los alemanes durante la Segunda Guerra Mundial para cifrar y descifrar mensajes, esta m√°quina demostr√≥ la eficacia de la criptograf√≠a sim√©trica en entornos militares.</p>
<p>Podemos ver la criptograf√≠a sim√©trica como una antigua y confiable llave maestra en el mundo de la seguridad inform√°tica. Es una t√©cnica que ha sido utilizada desde hace mucho tiempo y a√∫n en la actualidad sigue siendo efectiva y segura para proteger informaci√≥n en diversas situaciones.</p>
<p>Imag√≠nate una llave que puede tanto cerrar como abrir una puerta. Los algoritmos criptogr√°ficos de clave sim√©trica funcionan de manera similar, utilizan la misma clave para cifrar el texto original y descifrar el texto cifrado, esta clave compartida es como el secreto que solo t√∫ y los destinatarios autorizados conocen.</p>
<p><img src="./assets/simetrico.gif" alt="graph" /></p>
<div align="center">
<em>Criptograf√≠a Sim√©trica - √önica Key</em>
</div>
<p>Sin embargo, a medida que la tecnolog√≠a avanzaba y las capacidades de c√≥mputo aumentaban, se hizo evidente que era necesario fortalecer los sistemas de cifrado. Surgieron nuevos desaf√≠os y amenazas que requer√≠an niveles m√°s altos de seguridad. Es por eso que se desarrollaron otros m√©todos criptogr√°ficos, como la criptograf√≠a asim√©trica, que utiliza pares de claves diferentes para el cifrado y el descifrado.</p>
<p>Aunque la criptograf√≠a sim√©trica ha evolucionado con el tiempo, todav√≠a se utiliza ampliamente en muchos sistemas y aplicaciones. Su simplicidad y eficiencia la convierten en una opci√≥n popular para proteger datos en redes privadas, sistemas de comunicaci√≥n y almacenamiento de informaci√≥n sensible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="criptograf√≠a-asim√©trica"><a class="header" href="#criptograf√≠a-asim√©trica">Criptograf√≠a Asim√©trica</a></h1>
<p>El concepto de algoritmos criptogr√°ficos de clave asim√©trica, fue un enfoque revolucionario que introdujo un concepto completamente diferente, <strong>el uso de un par de claves complementarias, una p√∫blica y una privada</strong>, para asegurar la confidencialidad de los datos. Cada clave del par ten√≠a una funci√≥n espec√≠fica:</p>
<ul>
<li><strong>Public key</strong>: esta clave p√∫blica se compart√≠a abiertamente y se utilizaba para cifrar la informaci√≥n.</li>
<li><strong>Private key:</strong> esta clave privada se guardaba cuidadosamente y se utilizaba para descifrarla.</li>
</ul>
<p>Con la criptograf√≠a de clave p√∫blica, los mensajes cifrados pod√≠an ser transmitidos a trav√©s de redes inseguras sin el temor de que fueran interceptados y descifrados por personas no autorizadas, pero en este caso diferenci√°ndose de la sim√©trica en que estos mensajes requer√≠an un Private key y una Public key. Era como si se hubiera descubierto una nueva forma de comunicaci√≥n secreta y segura en el mundo digital, fue un avance revolucionario en el campo de la criptograf√≠a.</p>
<p><img src="./assets/asimetrico.gif" alt="graph" /></p>
<div align="center">
<em>Criptograf√≠a Asim√©trica - Creaci√≥n de PK y PB</em>
</div>
<p>Algunos de los m√°s destacados y utilizados son los siguiente:</p>
<ul>
<li>
<p><strong>RSA -</strong> <a href="https://es.wikipedia.org/wiki/RSA"><strong>Rivest-Shamir-Adleman:</strong></a> es un sistema criptogr√°fico asim√©trico de clave p√∫blica desarrollado en 1979. Su seguridad radica en el problema de la factorizaci√≥n de n√∫meros enteros y se utiliza en diversos √°mbitos de la transmisi√≥n de datos en Internet debido a su facilidad de uso. Este sistema consta de una clave p√∫blica RSA y una clave privada RSA.</p>
</li>
<li>
<p><strong>ECC -</strong> <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_de_curva_el%C3%ADptica"><strong>Elliptic Curve Cryptography:</strong></a> en la d√©cada de 1980 se desarroll√≥ este enfoque de curva el√≠ptica criptogr√°fica, una variante de la criptograf√≠a asim√©trica o de clave p√∫blica basada en las matem√°ticas de las curvas el√≠pticas que proporciona niveles de seguridad similares o superiores a RSA pero con claves m√°s cortas.</p>
</li>
<li>
<p><strong>ECDSA -</strong> <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf"><strong>Elliptic Curve Digital Signature Algorithm:</strong></a> en los A√±os 1990 naci√≥ ECDSA, un algoritmo de firma digital y autenticaci√≥n en criptograf√≠a asim√©trica, basado en curvas el√≠pticas. Se utiliza en criptograf√≠a para garantizar la autenticidad, integridad de los datos. ECDSA se basa en la dificultad computacional de resolver el problema del logaritmo discreto en curvas el√≠pticas.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="criptograf√≠a-h√≠brida"><a class="header" href="#criptograf√≠a-h√≠brida">Criptograf√≠a H√≠brida</a></h1>
<p>El <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_h%C3%ADbrida"><strong>cifrado h√≠brido</strong></a> utiliza las propiedades √∫nicas de la criptograf√≠a de clave p√∫blica para intercambiar informaci√≥n secreta a trav√©s de un canal no confiable, combinando la eficacia del cifrado sim√©trico. Esto proporciona una soluci√≥n pr√°ctica de extremo a extremo para garantizar la privacidad de los datos.</p>
<p>Aunque los algoritmos de clave p√∫blica, como RSA-OAEP, son menos eficientes que los algoritmos sim√©tricos, generalmente no se utilizan directamente para cifrar los datos. Sin embargo, desempe√±an un papel importante en el ecosistema criptogr√°fico al permitir el intercambio seguro de claves.</p>
<p>Para utilizar el cifrado sim√©trico, las partes deben compartir una clave. Si ya existe un canal seguro, se puede enviar la clave a trav√©s de √©l. Sin embargo, si no hay un canal seguro disponible, se resuelve el problema del intercambio de claves utilizando la criptograf√≠a de clave p√∫blica.</p>
<ul>
<li><strong>DH -</strong> <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"><strong>Diffie‚ÄìHellman:</strong></a> el intercambio de claves DH es un algoritmo criptogr√°fico de clave p√∫blica dise√±ado espec√≠ficamente para acordar una clave sim√©trica en ausencia de un canal seguro.
La combinaci√≥n de criptograf√≠a de clave p√∫blica para el intercambio de claves y el cifrado sim√©trico para el cifrado de datos en masa se conoce como cifrado h√≠brido.</li>
</ul>
<p>El cifrado h√≠brido se utiliza ampliamente en los protocolos de transferencia de datos para la web, como en la capa de seguridad de transporte <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">(TLS)</a>. Cuando te conectas a un sitio web que utiliza <a href="https://en.wikipedia.org/wiki/HTTPS">HTTPS</a> (HTTP seguro con TLS), tu navegador negocia los algoritmos criptogr√°ficos que aseguran la conexi√≥n. Estos algoritmos incluyen m√©todos para el intercambio de claves, cifrado sim√©trico y firmas digitales.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="firmas-digitales"><a class="header" href="#firmas-digitales">Firmas digitales</a></h1>
<p>Los esquemas de firma digital son un tipo de criptograf√≠a de clave p√∫blica que garantiza la integridad, autenticidad y no repudio de los datos.</p>
<p>Es importante destacar que el esquema de firma digital puede variar dependiendo del algoritmo utilizado, ECDSA, es un ejemplo com√∫n de esquema de firma basado en criptograf√≠a de curva el√≠ptica. Aqu√≠ EC recordemos que representa la curva el√≠ptica utilizada y <a href="https://en.wikipedia.org/wiki/Digital_Signature_Algorithm"><strong>DSA</strong></a> (una variante de los esquemas de firma <a href="https://en.wikipedia.org/wiki/Schnorr_signature">Schnorr</a> y <a href="https://en.wikipedia.org/wiki/ElGamal_signature_scheme">ElGamal</a>) el algoritmo de firma digital. Cada esquema tiene sus propias caracter√≠sticas y propiedades de seguridad, y se selecciona seg√∫n los requisitos y consideraciones espec√≠ficas de la aplicaci√≥n.</p>
<p>Cuando se trata de firmas digitales, los pasos generales suelen ser los siguientes:</p>
<ul>
<li>
<p><strong>Key generation:</strong> el Generador de Claves es un protocolo o algoritmo que genera <strong>un Keypar</strong>, un par de claves asim√©tricas como se explic√≥ anteriormente compuestas por una public key y una private key. En el caso de la criptograf√≠a de curva el√≠ptica (como ECDSA), se generan los par√°metros necesarios para definir la curva y se elige una clave privada aleatoria. A partir de la clave privada, se calcula la clave p√∫blica correspondiente utilizando operaciones matem√°ticas espec√≠ficas.</p>
</li>
<li>
<p><strong>Hash del mensaje:</strong> antes de firmar el mensaje, se aplica una funci√≥n hash criptogr√°fica al contenido del mensaje. Esto reduce el mensaje a un valor de longitud fija llamado resumen o hash. El objetivo es garantizar la integridad y eficiencia del proceso de firma, ya que es m√°s r√°pido firmar y verificar un resumen m√°s corto que el mensaje completo.</p>
</li>
<li>
<p><strong>Digital Signature:</strong> este proceso tiene el prop√≥sito de realizar una serie de operaciones matem√°ticas utilizando la clave privada y el hash del mensaje para generar la firma digital.</p>
</li>
<li>
<p><strong>Verify Signature:</strong> para verificar la autenticidad de la firma, se necesita la clave p√∫blica del firmante. Se aplica nuevamente la funci√≥n hash al mensaje original y se utiliza la clave p√∫blica junto con la firma para realizar operaciones matem√°ticas espec√≠ficas. Si el resultado coincide con la firma original, se considera que la firma es v√°lida y se confirma la autenticidad del mensaje y del firmante.</p>
</li>
</ul>
<p>El proceso de firma puede considerarse como el cifrado del archivo mediante la clave privada. Para ello, la persona que firma utiliza su clave privada para producir una firma.</p>
<p>Exploraremos a continuaci√≥n la relevancia de los diversos esquemas de firmas para garantizar la seguridad de nuestros datos, as√≠ como la forma en que Starknet usa AA para abstraer la firma de la validaci√≥n. En este contexto, se pueden dise√±ar diferentes esquemas o configuraciones, como el <code>secp256r1</code>, una variante de STARK Curve, la versi√≥n amigable de ECDSA optimizada en Starknet. Este esquema de firma se puede utilizar para incorporar firmas en dispositivos modernos de manera biom√©trica, aislada y abstra√≠da por naturaleza, lo que mejora significativamente la eficiencia, tal como se discutir√° en detalle m√°s adelante.</p>
<p>Por lo tanto, resulta crucial abordar el siguiente apartado relacionado con el uso de Key generation que desempe√±an un papel fundamental en este contexto.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-generator"><a class="header" href="#key-generator">Key generator</a></h1>
<p>Tenemos que entender c√≥mo el generador de claves <a href="https://en.wikipedia.org/wiki/Key_generator"><strong>(Key generator)</strong></a> genera el Keypair, para lograrlo, es necesario trabajar con valores pseudoaleatorios que se utilizan en la generaci√≥n de la private key. Un Key generator se puede implementar en un sistema con el prop√≥sito de generar y autenticar claves.</p>
<p>Key generator puede implementarse en cualquier sistema criptogr√°fico que utilice la curva el√≠ptica, como es el caso de <code>secp256k1</code> (una curva optimizada basada en las propiedades matem√°ticas de las curvas el√≠pticas para proporcionar un esquema de firma digital seguro y eficiente), como Bitcoin y Ethereum.</p>
<p>Este generador de claves garantiza que, con alta probabilidad, las claves privadas generadas sean √∫nicas y seguras, lo que a su vez respalda la integridad y autenticidad de las transacciones realizadas en la red.</p>
<h2 id="generadores-de-n√∫meros-pseudoaleatorios"><a class="header" href="#generadores-de-n√∫meros-pseudoaleatorios">Generadores de n√∫meros pseudoaleatorios</a></h2>
<p>Para garantizar la seguridad usando la pseudoaleatoriedad estad√≠stica de un <strong>PRNG -</strong> <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator"><strong>Pseudorandom number generator</strong></a>, es crucial contar con una semilla inicial. Si la semilla es f√°cilmente predecible, generar√° valores predecibles de n√∫meros y todo el proceso ser√° inseguro.</p>
<p>Para lograr una inicializaci√≥n segura del generador pseudoaleatorio, es necesario recolectar <a href="https://en.wikipedia.org/wiki/Entropy_(computing)"><strong>Entrop√≠a</strong></a>, que representa la aleatoriedad necesaria en el proceso.</p>
<h2 id="entrop√≠a"><a class="header" href="#entrop√≠a">Entrop√≠a</a></h2>
<p>La entrop√≠a o aleatoriedad impredecible en computaci√≥n, generalmente se mide en bits. Tenemos varios ejemplos para entender el concepto y grado de aleatoriedad. Si mueve el mouse de su computadora, generar√° algunos eventos dif√≠ciles de predecir, como la ubicaci√≥n de inicio y la ubicaci√≥n final del cursor del mouse.</p>
<blockquote>
<p>Si suponemos que el mouse ha cambiado su posici√≥n en el rango de <code>[ 0 ... 255 p√≠xeles ]</code>, la entrop√≠a recolectada de este movimiento del mouse debe ser de aproximadamente <strong>8 bits</strong>, porque <code>2‚Å∏ = 255</code></p>
</blockquote>
<blockquote>
<p>Si se le pide al usuario que piense en un n√∫mero en el rango <code>[ 0 ... 1000 ]</code>, este n√∫mero tendr√° alrededor de <strong>9-10 bits</strong> de entrop√≠a porque, <code>2¬π‚Å∞ = 1024</code></p>
</blockquote>
<p>Para recolectar 256 bits de entrop√≠a, es decir, para generar de forma segura un n√∫mero entero de 256 bits, deber√° tener en cuenta una secuencia de varios eventos similares (como movimientos del mouse e interracidades del teclado del usuario).</p>
<p>Aqu√≠ la importancia de d√≥nde y c√≥mo hemos generado nuestras claves privadas y p√∫blicas y las posibles vulnerabilidades en algunos malos usos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funciones-hash-y-funciones-hash-criptogr√°ficas"><a class="header" href="#funciones-hash-y-funciones-hash-criptogr√°ficas">Funciones hash y funciones hash criptogr√°ficas</a></h1>
<p>Este cap√≠tulo es de suma importancia para comprender el funcionamiento de las funciones hash. A diferencia de los esquemas de cifrado o las firmas, las funciones hash no requieren de una clave. Cualquier persona puede calcular el hash de una entrada determinada, y la funci√≥n hash siempre producir√° la misma salida para la misma entrada.</p>
<p>As√≠ que podemos definir una <a href="https://en.wikipedia.org/wiki/Hash_function"><strong>funci√≥n hash</strong></a> como un algoritmo que toma una entrada, como un mensaje o un archivo, y produce una salida de longitud fija llamada hash o resumen. Esta salida es √∫nica para cada entrada espec√≠fica, lo que permite la verificaci√≥n de la integridad de los datos y garantiza que cualquier cambio en la entrada resultar√° en un hash completamente diferente.</p>
<p>Una <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function"><strong>funci√≥n hash criptogr√°fica</strong></a>, por otro lado, es aquella funci√≥n hash que se utiliza en el √°mbito de la criptograf√≠a, para evaluar la seguridad de una funci√≥n de hash criptogr√°fica, se consideran las siguientes propiedades:</p>
<ul>
<li><strong>Resistencia a la preimagen:</strong> partiendo de un valor <code>hash h</code>, es dif√≠cil encontrar un mensaje <code>m</code> que genere ese <code>hash</code>, es decir, <code>h = hash(m)</code>, este concepto est√° relacionado con el de una funci√≥n de sentido √∫nico. Las funciones que carecen de esta propiedad son vulnerables a ataques de preimagen.</li>
<li><strong>Resistencia a la segunda preimagen:</strong> dado un mensaje <code>m‚ÇÅ</code>, es dif√≠cil encontrar otro mensaje <code>m‚ÇÇ</code> distinto a <code>m‚ÇÅ</code> que produzca el mismo valor de hash, es decir, <code>hash(m‚ÇÅ) = hash(m‚ÇÇ)</code>. Esta propiedad tambi√©n se conoce como resistencia d√©bil a colisiones. Las funciones que no cumplen esta propiedad son vulnerables a ataques de segunda preimagen.</li>
<li><strong>Resistencia a colisiones:</strong> es dif√≠cil encontrar dos mensajes diferentes <code>m‚ÇÅ</code> y <code>m‚ÇÇ</code> que produzcan el mismo valor de hash, es decir, <code>hash(m‚ÇÅ) = hash(m‚ÇÇ)</code>. Estas colisiones son conocidas como colisiones criptogr√°ficas de hash. Esta propiedad tambi√©n se conoce como resistencia fuerte a colisiones. Se requiere que el tama√±o del hash sea al menos el doble de largo para garantizar la resistencia a la preimagen.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merkle-tree-en-blockchain"><a class="header" href="#merkle-tree-en-blockchain">Merkle Tree en Blockchain</a></h1>
<p>Ahora que hemos comprendido mejor qu√© es un hash, veamos c√≥mo en criptograf√≠a y <a href="https://en.wikipedia.org/wiki/Computer_science">ciencias de la computaci√≥n</a>, un √°rbol hash, tambi√©n conocido c√≥mo <a href="https://en.wikipedia.org/wiki/Merkle_tree"><strong>Merkle Tree o binary Merkle tree</strong></a>, es una <a href="https://en.wikipedia.org/wiki/Data_structure">estructura de datos</a> utilizada para garantizar la integridad de los contenidos almacenados en un sistema, como la tecnolog√≠a blockchain.</p>
<p>Podemos ver los Merkle Trees como una estructura de √°rbol en la que cada &quot;hoja&quot; o nodo terminal, est√° etiquetado con el hash criptogr√°fico de un bloque de datos. A su vez, cada nodo que no es una hoja, tambi√©n conocido como rama, nodo interior o inodo, est√° etiquetado con el hash criptogr√°fico de las etiquetas de sus nodos secundarios.</p>
<p>La construcci√≥n de un Merkle Tree implica dividir los datos en bloques m√°s peque√±os y aplicar una funci√≥n de hash criptogr√°fico a cada uno de ellos. Luego, los bloques hash se combinan en pares y se vuelven a hashear, repitiendo este proceso hasta obtener un √∫nico hash llamado ra√≠z de Merkle o ‚ÄúMerkle root‚Äù. Esta ra√≠z se coloca en la cabecera de un bloque o transacci√≥n y se utiliza como una firma digital que representa y verifica la integridad de todos los datos incluidos en el bloque.</p>
<p><img src="./assets/merkle.gif" alt="graph" /></p>
<div align="center">
<em>Ejemplo de estructura de un Merkle Tree</em>
</div>
<p>Una de las principales ventajas de los Merkle Trees es su capacidad para proporcionar una verificaci√≥n eficiente y segura de los contenidos de una gran estructura de datos. Como cada nodo intermedio en el √°rbol est√° etiquetado con el hash criptogr√°fico de las etiquetas de sus nodos secundarios, cualquier cambio realizado en los datos se reflejar√° en cambios en los hashes correspondientes.</p>
<p>En la tecnolog√≠a blockchain que usan los Merkle Trees, los utilizan para garantizar la integridad de los datos almacenados en cada bloque de la cadena. Cada bloque contiene una lista de transacciones, y el Merkle Tree se construye utilizando los hashes de estas transacciones.</p>
<p>Cuando se agrega un nuevo bloque a la cadena, la ra√≠z de Merkle del bloque anterior se incluye en el nuevo bloque, creando una cadena enlazada de √°rboles de Merkle. Esto permite verificar r√°pidamente la integridad de cualquier bloque en la cadena sin necesidad de verificar todos los datos desde el inicio. Adem√°s, si alg√∫n dato se modifica en un bloque, el hash del bloque cambiar√°, lo que afectar√° la ra√≠z de Merkle y se√±alar√° la alteraci√≥n en la cadena.</p>
<p>Algunos casos posibles de uso de los binary Merkle Trees para los diferentes esquemas pueden ser:</p>
<ul>
<li><strong>Los binary Merkle Trees:</strong> son estructuras de datos muy eficientes para autenticar informaci√≥n que se presenta en formato de &quot;lista&quot;, es decir, una secuencia de elementos consecutivos.</li>
<li><strong>Los transaction trees:</strong> tambi√©n resultan beneficiosos, ya que una vez creado el √°rbol, no importa cu√°nto tiempo se tarde en editarlo, ya que permanecer√° inmutable.</li>
<li><strong>Los State trees:</strong> sin embargo, cuando se trata de un √°rbol que almacena estados la situaci√≥n se vuelve m√°s compleja, el estado en Ethereum, que consiste en un mapa de valores clave donde:
<ul>
<li><strong>Las claves son direcciones</strong></li>
<li><strong>Los valores son las declaraciones de cuenta que incluyen:</strong> saldo, nonce, c√≥digo y almacenamiento asociados a cada cuenta, r</li>
<li><strong>Requiere la construcci√≥n de una prueba de transici√≥n de estado de Merkle</strong> <a href="https://medium.com/@chiqing/verify-ethereum-account-balance-with-state-proof-83b51ceb15cf">(Merkle state transition proof)</a></li>
</ul>
</li>
</ul>
<p>As√≠ que, comprender el funcionamiento de los State Trees y su optimizaci√≥n de datos es crucial en el contexto actual donde los datos y los hashes desempe√±an un papel fundamental. En el caso de Ethereum, uno de los principales actores en el √°mbito de los State Trees, se han incorporado modificaciones interesantes usando Patricia Merkle Trie.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patricia-merkle-trie"><a class="header" href="#patricia-merkle-trie">Patricia Merkle Trie</a></h1>
<p>La especificaci√≥n de Ethereum define el <a href="https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/"><strong>Modified Merkle Patricia Trie</strong></a> (tambi√©n conocido como MPT) este m√©todo se utiliza para guardar estados. B√°sicamente, el MPT es una combinaci√≥n del Patricia trie y el Merkle tree, con algunas optimizaciones adicionales adaptadas a las caracter√≠sticas de Ethereum.</p>
<p>Patricia trie, <a href="https://en.wikipedia.org/wiki/Radix_tree">(Radix tree o Radix trie)</a>, √°rbol de prefijos compacto <strong>(compact prefix tree)</strong> o √°rbol de prefijos comprimido <strong>(compressed trie)</strong>, es una sofisticada estructura de datos que ofrece una optimizaci√≥n espacial en la representaci√≥n de [Tries] (√°rboles de prefijos). Una de las caracter√≠sticas clave de este tipo de √°rbol es la fusi√≥n de nodos cuando un nodo es hijo √∫nico de su padre, lo que contribuye a una mayor eficiencia y rendimiento.</p>
<p>Esta estructura es un tipo de <strong>√°rbol de b√∫squeda k-ary</strong>, siendo un <a href="https://en.wikipedia.org/wiki/M-ary_tree">m-ary tree</a> (tambi√©n conocido como <code>n-ary tree</code>, <code>k-ary tree</code> o <code>k-way tree</code>) un √°rbol ra√≠z en el cual cada nodo tiene como m√°ximo m hijos. Ambas estructuras de datos se utilizan para localizar claves espec√≠ficas dentro de un conjunto.</p>
<p>Estos √°rboles son completamente deterministas, lo que significa que aquellos con las mismas asociaciones de (clave, valor) est√°n garantizados de ser id√©nticos, hasta el √∫ltimo byte. Esto asegura que tengan el mismo hash ra√≠z, lo que proporciona la deseada eficiencia de <code>O(log(n))</code> para inserciones, b√∫squedas y eliminaciones. Adem√°s, son m√°s f√°ciles de entender y programar que alternativas m√°s complejas basadas en comparaciones, como los <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">red-black tree.</a></p>
<p>El Patricia Merkle Trie combina la estructura de un √°rbol de b√∫squeda binario con la estructura de √°rbol de Merkle, lo cual permite verificar eficientemente la integridad de los datos y proporciona una representaci√≥n compacta del estado completo de la cadena.</p>
<p>El uso del Patricia Merkle Trie en Ethereum ofrece ventajas significativas en t√©rminos de eficiencia y escalabilidad. Permite realizar consultas r√°pidas sobre el estado de las cuentas y los contratos, evitando la necesidad de recorrer todo el estado completo. En cambio, solo es necesario verificar y acceder a los nodos relevantes en el √°rbol, lo que ahorra tiempo y recursos.</p>
<p>Adem√°s, esta estructura de √°rbol facilita la implementaci√≥n de funciones de snapshot y revert en Ethereum. Estas funciones permiten crear instant√°neas del estado del sistema en momentos espec√≠ficos y revertir cambios en caso de errores o ataques, brindando una capa adicional de seguridad y confiabilidad a la red blockchain.</p>
<p><img src="" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>La comprensi√≥n de los Merkle Trees y el MPT resulta especialmente relevante al explorar otras estructuras de datos criptogr√°ficas, como las Merkle Mountain Ranges (MMRs) en Herodotus para las Storage Proof. Las MMRs pueden considerarse una lista de √Årboles de Merkle, donde cada √°rbol se representa como una monta√±a y la lista completa forma el rango. La utilizaci√≥n de funciones hash espec√≠ficas y sus caracter√≠sticas de seguridad se explorar√°n para comprender c√≥mo crear estos √°rboles de manera eficiente y √≥ptima.</p>
<p>Por lo tanto, es crucial comprender a fondo las diferentes funciones hash y sus propiedades para tomar decisiones informadas sobre la selecci√≥n y optimizaci√≥n de las mismas en la construcci√≥n de estructuras de datos criptogr√°ficas m√°s eficientes y seguras en los √Årboles de Merkle.</p>
<p>Las funciones hash desempe√±an un papel fundamental en garantizar la integridad y la seguridad de los datos almacenados en los √°rboles de Merkle, ya que se utilizan para calcular los hashes de los nodos y verificar su integridad durante la construcci√≥n y la verificaci√≥n del √°rbol.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sha-256"><a class="header" href="#sha-256">SHA-256</a></h1>
<p>En este cap√≠tulo aprenderemos algunos ejemplos de funciones hash criptogr√°ficas ampliamente utilizadas, un ejemplo es <code>SHA-256</code> <a href="https://es.wikipedia.org/wiki/SHA-2"><strong>(Secure Hash Algorithm 256-bit)</strong></a>, <strong>que es una funci√≥n de hash criptogr√°fica perteneciente a la familia de algoritmos SHA-2.</strong> Esta funci√≥n acepta una entrada de cualquier longitud y genera una salida de 256 bits que se considera √∫nica y asociada de forma irreversible a dicha entrada.</p>
<p>Pueden probar la generaci√≥n de un hash utilizando cualquier <a href="https://miniwebtool.com/es/sha256-hash-generator/">generador en l√≠nea</a>. En este caso, <a href="https://bfotool.com/category/encode-decoder">realizamos pruebas</a> utilizando la funci√≥n hash <code>SHA-256</code> y <code>keccak-256</code>, tambi√©n pueden explorar y probar <a href="https://bfotool.com/category/encode-decoder">m√°s funciones hash desde aqu√≠.</a></p>
<p>El cambio de un solo bit causa un efecto avalancha, lo que significa que incluso un cambio m√≠nimo como un <code>.</code> en la entrada, produce un cambio significativo en la salida. Puedes revisar el hash de <code>L2 en Espa√±ol</code> y <code>L2 en Espa√±ol.</code></p>
<p><img src="./assets/Sha256.png" alt="graph" /></p>
<div align="center">
<em>Salida de datos completamente diferente a√±adiendo un "."</em>
</div>
<p><code>SHA-256</code> se utiliza ampliamente en criptograf√≠a, y cuenta con diversos casos de uso destacados:</p>
<ol>
<li><strong>Verificaci√≥n de integridad:</strong> <code>SHA-256</code> se utiliza para verificar la integridad de los datos almacenados en un sistema. Al calcular el hash de un archivo o conjunto de datos, se puede comparar con el hash original para detectar cualquier cambio o alteraci√≥n en los datos.</li>
<li><strong>Firmas digitales:</strong> las firmas digitales se generan mediante algoritmos criptogr√°ficos y se basan en la funci√≥n SHA-256 para asegurar la autenticidad e integridad de los mensajes. El hash <code>SHA-256</code> se utiliza para resumir y proteger la informaci√≥n que se firma digitalmente.</li>
<li><strong>Almacenamiento seguro de contrase√±as:</strong> en lugar de almacenar contrase√±as en texto plano, los sistemas de seguridad suelen almacenar el hash <code>SHA-256</code> de las contrase√±as. Cuando un usuario ingresa su contrase√±a, se calcula el hash y se compara con el valor almacenado, lo que permite verificar la autenticidad de la contrase√±a sin almacenarla directamente.</li>
<li><strong>Generaci√≥n de claves criptogr√°ficas:</strong> <code>SHA-256</code> se utiliza en algoritmos de generaci√≥n de claves criptogr√°ficas para producir claves aleatorias y seguras.</li>
</ol>
<p>En resumen, <code>SHA-256</code> es una funci√≥n hash criptogr√°fica ampliamente utilizada que forma parte de la familia de algoritmos <code>SHA-2</code>, la hace ideal para verificar la integridad de los datos, generar firmas digitales, almacenar contrase√±as de forma segura y generar claves criptogr√°ficas. <code>SHA-256</code> ha demostrado su robustez y eficacia en numerosos casos de uso en criptograf√≠a. Ahora es el turno de explorar otra funci√≥n hash criptogr√°fica m√°s moderna llamada Keccak.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak---el-nuevo-sha-3"><a class="header" href="#keccak---el-nuevo-sha-3">Keccak - El nuevo SHA-3</a></h1>
<p>Este cap√≠tulo nos centraremos en el <code>SHA-3</code> <a href="https://en.wikipedia.org/wiki/SHA-3"><strong>(Secure Hash Algorithm 3)</strong></a>, es un est√°ndar de funci√≥n hash criptogr√°fica dise√±ado por los cript√≥grafos Joan Daemen y Gilles Van Assche. El algoritmo utilizado en <code>SHA-3</code> se llama <a href="https://keccak.team/index.html"><strong>Keccak</strong></a>, el cual fue <a href="https://www.federalregister.gov/documents/2015/08/05/2015-19181/announcing-approval-of-federal-information-processing-standard-fips-202-sha-3-standard"><strong>seleccionado como el ganador del concurso</strong></a> organizado por el Instituto Nacional de Est√°ndares y Tecnolog√≠a <a href="https://en.wikipedia.org/wiki/National_Institute_of_Standards_and_Technology">(NIST)</a> para encontrar un nuevo est√°ndar de funci√≥n hash criptogr√°fica.</p>
<p>A diferencia de <code>SHA-256</code>, <code>Keccak</code> utiliza una estructura y operaciones diferentes. En lugar de rondas, <code>Keccak</code> se basa en una construcci√≥n llamada funci√≥n de esponja <a href="https://en.wikipedia.org/wiki/Sponge_function">(Sponge function)</a>, que se basa en una funci√≥n pseudoaleatoria amplia o <a href="https://keccak.team/glossary.html#permutation">(permutation)</a> pseudoaleatorio permitiendo ingresar <strong>&quot;absorbing&quot;</strong> y <strong>&quot;squeezing&quot;</strong>.</p>
<p><code>Keccak-256</code> es una funci√≥n hash criptogr√°fica utilizada en Ethereum. Pertenece a la familia de algoritmos <code>SHA-3</code> y se emplea ampliamente en la plataforma Ethereum para diversos prop√≥sitos.</p>
<p>Algunos casos de uso de <code>Keccak-256</code> incluyen:</p>
<ul>
<li>Ethereum utiliza <code>Keccak-256</code> para garantizar la integridad de los datos y generar identificadores √∫nicos (hash) para verificar la autenticidad de los archivos y mensajes en sistemas criptogr√°ficos.</li>
<li>Tambi√©n se utiliza en la firma criptogr√°fica de peque√±o tama√±o, donde en lugar de firmar la entrada completa, se firma el hash <code>Keccak-256</code> del mensaje o dato.</li>
<li><code>Keccak-256</code> es utilizado para obtener una identificaci√≥n √∫nica y determinista de una colecci√≥n de datos. Por ejemplo, en Ethereum, las direcciones de Ethereum se derivan de claves p√∫blicas o contratos utilizando la funci√≥n hash unidireccional <code>Keccak-256</code>.</li>
</ul>
<p>Las direcciones Ethereum son n√∫meros hexadecimales, identificadores derivados de los √∫ltimos 20 bytes del hash <code>Keccak-256</code> de la clave p√∫blica.</p>
<p>A diferencia de las direcciones de Bitcoin, que est√°n codificadas en la interfaz de usuario de todos los clientes para incluir una suma de verificaci√≥n incorporada para proteger contra direcciones mal escritas, las direcciones de Ethereum se presentan como hexadecimales sin ninguna suma de verificaci√≥n.</p>
<p><img src="./assets/Keccak.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>El algoritmo <strong>Keccak</strong> utiliza la <a href="https://keccak.team/glossary.html#sponge_construction"><strong>Sponge construction</strong></a> para procesar los datos de entrada de longitud variable para generar una salida de longitud variable. Esta construcci√≥n se basa en una funci√≥n interna llamada <code>&quot;F&quot;</code> que opera en un n√∫mero fijo de bits, denotado como <code>&quot;width&quot;</code> <a href="https://keccak.team/glossary.html#width">(anchura)</a>.</p>
<p>La anchura total del algoritmo Keccak se determina sumando dos componentes, el valor de <code>&quot;r&quot;</code> <a href="https://keccak.team/glossary.html#rate">(rate)</a> y el valor de <code>&quot;c&quot;</code> <a href="https://keccak.team/glossary.html#capacity">(capacity)</a>, donde <code>b = r + c</code>.</p>
<ul>
<li>El valor de <code>&quot;r&quot;</code> representa la cantidad de bits absorbidos en cada paso de la funci√≥n esponja, es decir, <strong>la capacidad de absorci√≥n de la esponja.</strong> Un valor de <code>&quot;r&quot;</code> m√°s grande permite procesar m√°s informaci√≥n en cada paso, lo que reduce la cantidad de pasos necesarios para procesar una entrada espec√≠fica.</li>
<li>El valor de <code>&quot;c&quot;</code> representa la capacidad de la esponja, es decir, <strong>la cantidad de bits que se mantienen en el estado interno del algoritmo despu√©s de cada paso de absorci√≥n</strong>. Estos bits se mezclan con los datos de entrada y el resultado de la funci√≥n interna <code>&quot;F&quot;</code>. La capacidad afecta la resistencia del algoritmo a ataques criptogr√°ficos como colisiones o preimagen.</li>
</ul>
<p>La suma de <code>&quot;r&quot;</code> y <code>&quot;c&quot;</code> da como resultado el n√∫mero total de bits, <code>&quot;b&quot;</code>, utilizados en la funci√≥n esponja de Keccak. Este valor determina la longitud del estado interno y, por lo tanto, la longitud de la salida generada por el algoritmo.</p>
<h2 id="funcionamiento-keccak"><a class="header" href="#funcionamiento-keccak">Funcionamiento keccak</a></h2>
<p>El algoritmo funciona de la siguiente manera, inicialmente la cadena de entrada se rellena con bits adicionales para enmascarar el mensaje inicial y se divide en bloques de longitud <code>&quot;r&quot;</code> bits. Luego, los <code>&quot;b&quot;</code> bits de estado se inicializan a <code>0</code>, que da inicio a la <strong>Sponge construction</strong> en dos fases <strong>&quot;absorbing&quot;</strong> y <strong>&quot;squeezing&quot;</strong>.</p>
<ul>
<li><strong>Fase Absorbing:</strong> a los bloques de entrada de longitud <code>r-bits</code> se les aplica un <a href="https://en.wikipedia.org/wiki/XOR_cipher">XOR</a> (toma dos bits y devuelve un resultado que es 1 si solo uno de los bits es 1, y 0 en caso contrario) a los primeros <code>r</code> bits del estado, altern√°ndose con la funci√≥n <code>f</code>. Cuando todos los bloques han sido procesados, se pasa a la siguiente fase.</li>
<li><strong>Fase Squeezing:</strong> los primeros <code>r</code> bits del estado son devueltos como bloques de salida, altern√°ndose con ejecuciones de la funci√≥n <code>f</code>. El n√∫mero de bloques de salida es seleccionado por el usuario.</li>
</ul>
<p>A continuaci√≥n os dejamos una tabla que enumeran algunas de las diferencias entre <code>SHA-256</code> y <code>Keccak-256</code>.</p>
<p><img src="./assets/Comparativa_Sha_keccak.png" alt="graph" /></p>
<div align="center">
<em>Algunas diferencias entre SHA-256 y Keccak-256</em>
</div>
<p>Vemos c√≥mo cada tipo de criptograf√≠a o funci√≥n hash tiene caracter√≠sticas distintas. En el contexto actual de la computaci√≥n cu√°ntica en constante evoluci√≥n, es crucial abordar las preocupaciones emergentes sobre seguridad. Algunos algoritmos criptogr√°ficos podr√≠an ser vulnerables a los ataques cu√°nticos en un futuro cercano. Es en este punto donde entra en juego el concepto de criptograf√≠a <a href="https://en.wikipedia.org/wiki/Post-quantum_cryptography">Post-Quantum</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quantum-secure"><a class="header" href="#quantum-secure">Quantum Secure</a></h1>
<p>Recomendamos repasar los episodios previos antes de leer este cap√≠tulo, con el fin de adquirir un mayor conocimiento de algunas definiciones y explorar posibles escenarios te√≥ricos apocal√≠pticos que podr√≠an ocurrir. Pero antes comencemos con una breve descripci√≥n sobre <a href="https://es.wikipedia.org/wiki/Computaci%C3%B3n_cu%C3%A1ntica">computaci√≥n cu√°ntica</a> para sumergirnos en el tema. <strong>No es m√°s que un modelo de computaci√≥n basado en la</strong> <a href="https://es.wikipedia.org/wiki/Mec%C3%A1nica_cu%C3%A1ntica"><strong>f√≠sica cu√°ntica</strong></a>, que funciona de manera diferente a las computadoras cl√°sicas (el tipo de computadoras que usamos habitualmente) y tiene la capacidad de realizar tareas que estas √∫ltimas no pueden, como romper ciertos algoritmos de manera eficiente.</p>
<blockquote>
<p><strong>¬°As√≠ que espera un momento!</strong> Antes de que tu imaginaci√≥n se desborde y te veas rodeado de supercomputadoras cu√°nticas capaces de solucionar todos nuestros problemas, d√©jame contarte una peque√±a an√©cdota.</p>
</blockquote>
<blockquote>
<p><em>Ah, las computadoras cu√°nticas, esas criaturas de la f√≠sica cu√°ntica que nos hacen so√±ar con un futuro lleno de posibilidades. Pero, ¬øsab√≠as que no son m√°quinas m√°gicas capaces de resolver todos nuestros problemas inform√°ticos en un abrir y cerrar de ojos?</em></p>
</blockquote>
<blockquote>
<p><strong>Imagina esto:</strong> las computadoras cu√°nticas son como esas personas brillantes que son s√∫per eficientes en ciertas tareas, pero bastante d√©biles en otras. Son como el genio matem√°tico que resuelve complicados problemas de c√°lculo en segundos, pero se le olvida c√≥mo atarse los zapatos.</p>
</blockquote>
<blockquote>
<p><em>Entonces, s√≠, las computadoras cu√°nticas pueden ser incre√≠blemente poderosas cuando se trata de ciertos problemas espec√≠ficos, como el factorizar n√∫meros grandes o buscar en enormes bases de datos. Pero cuando se trata de tareas cotidianas, como revisar correos electr√≥nicos o navegar por la web, bueno, digamos que son como un caracol tratando de correr una marat√≥n.</em></p>
</blockquote>
<p>Despu√©s de esta peque√±a relato, es importante comprender el concepto de criptograf√≠a post-cu√°ntica <a href="https://cryptobook.nakov.com/quantum-safe-cryptography"><strong>(PQC)</strong></a>, tambi√©n conocida como <a href="https://cryptobook.nakov.com/quantum-safe-cryptography"><strong>Resistente a la Computaci√≥n Cu√°ntica</strong></a>, se refiere a algoritmos criptogr√°ficos especialmente algoritmos de clave p√∫blica, que se consideran seguros contra los ataques criptoanal√≠ticos llevados a cabo por computadoras cu√°nticas.</p>
<p>A medida que avanza la computaci√≥n cu√°ntica, se espera que algunos algoritmos y t√©cnicas criptogr√°ficas tradicionales utilizadas en los sistemas de seguridad actuales sean vulnerables a los ataques cu√°nticos. Esto se debe a la capacidad de las computadoras cu√°nticas para realizar c√°lculos a una escala exponencialmente mayor que las computadoras cl√°sicas, lo que podr√≠a comprometer la seguridad de los sistemas criptogr√°ficos actuales.</p>
<p>Es bien sabido en inform√°tica que las computadoras cu√°nticas podr√°n romper algunos algoritmos criptogr√°ficos, especialmente los criptosistemas de clave p√∫blica como <strong>RSA</strong>, el intercambio de llaves <strong>Diffie‚ÄìHellman</strong> y <strong>ECDSA</strong>, que dependen del <a href="https://es.wikipedia.org/wiki/Factorizaci%C3%B3n_de_enteros"><strong>IFP</strong></a> (problema de factorizaci√≥n en n√∫meros primos), el <a href="https://es.wikipedia.org/wiki/Logaritmo_discreto"><strong>DLP</strong></a> (problema del logaritmo discreto) y el ECDLP (problema del logaritmo discreto de curva el√≠ptica). Todos estos problemas podr√≠an resolverse f√°cilmente en una computadora cu√°ntica suficientemente poderosa que ejecute el algoritmo de Shor.</p>
<p>Pero los algoritmos cu√°nticos no significar√°n el fin de la criptograf√≠a, porque:</p>
<ul>
<li>Solo algunos criptosistemas son inseguros frente a la computaci√≥n cu√°ntica (como RSA, DHKE, ECDSA y ECDH).</li>
<li>Algunos criptosistemas son seguros frente a la computaci√≥n cu√°ntica y solo se ver√°n ligeramente afectados (como los hash criptogr√°ficos, algoritmos <a href="https://es.wikipedia.org/wiki/C%C3%B3digo_de_autenticaci%C3%B3n_de_mensaje">MAC</a> y cifrados de clave sim√©trica como <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard?wprov=srpw1_0">AES</a>, siempre que se utilicen tama√±os de clave suficientemente grandes).</li>
</ul>
<p>A diferencia de la amenaza que representa la computaci√≥n cu√°ntica para los algoritmos de clave p√∫blica actuales, <strong>la mayor√≠a de los algoritmos criptogr√°ficos sim√©tricos y las funciones hash actuales se consideran relativamente seguros contra ataques de computadoras cu√°nticas.</strong> Si bien el algoritmo cu√°ntico de Grover acelera los ataques contra los cifrados sim√©tricos, duplicar el tama√±o de la clave puede bloquear eficazmente estos ataques. Por lo tanto, la criptograf√≠a sim√©trica post-cu√°ntica no necesita diferir significativamente de la criptograf√≠a sim√©trica actual.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="el-algoritmo-de-grover-y-la-b√∫squeda-no-estructurada"><a class="header" href="#el-algoritmo-de-grover-y-la-b√∫squeda-no-estructurada">El algoritmo de Grover y la b√∫squeda no estructurada</a></h1>
<p>El <a href="https://es.wikipedia.org/wiki/Algoritmo_de_Grover">algoritmo de Grover</a> es un <a href="https://es.wikipedia.org/wiki/Algoritmo_cu%C3%A1ntico">algortimo cu√°ntico</a> para la b√∫squeda en una secuencia no ordenada de datos con <code>N</code> componentes en un tiempo <a href="https://es.wikipedia.org/wiki/Cota_superior_asint%C3%B3tica">O</a>(N¬π/‚ÇÇ), y con una necesidad adicional de espacio de almacenamiento de <code>O(logN)</code>. Fue inventado por Lov K. Grover en <a href="https://es.wikipedia.org/wiki/1996">1996</a>.</p>
<p>Aunque el algoritmo de Grover es eficiente, su paralelizaci√≥n √≥ptima resulta complicada y no se espera que las computadoras cu√°nticas actuales tengan suficiente potencia para comprometer la seguridad de esquemas como ECDSA o de funciones de hash como SHA256.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="el-algoritmo-de-shor-te√≥rico-y-su-impacto-en-ecdsa"><a class="header" href="#el-algoritmo-de-shor-te√≥rico-y-su-impacto-en-ecdsa">El algoritmo de Shor te√≥rico y su impacto en ECDSA</a></h1>
<p>El <a href="https://en.wikipedia.org/wiki/Shor&#x27;s_algorithm"><strong>algoritmo de Shor</strong></a> es un algoritmo cu√°ntico desarrollado por Peter Shor en 1994. Este algoritmo es conocido por su capacidad para factorizar grandes n√∫meros enteros de manera mucho m√°s eficiente que los algoritmos cl√°sicos conocidos, lo que tiene implicaciones importantes para la seguridad de algunos sistemas criptogr√°ficos basados en la factorizaci√≥n de n√∫meros enteros.</p>
<p>En el contexto de sistemas centralizados, como los sistemas bancarios, ECDSA se utiliza para garantizar la autenticidad de las transacciones, proteger la confidencialidad de la informaci√≥n y asegurar la integridad de los datos. En el √°mbito de Bitcoin y Ethereum, si bien los algoritmos de b√∫squeda cu√°ntica, como el algoritmo de Shor, podr√≠an eventualmente romper la ECDSA, es importante destacar que estos algoritmos a√∫n est√°n en una etapa te√≥rica.</p>
<p>Cada implementaci√≥n de algoritmos o protocolos puede ser diversa, ya sea privada o abstracta. Nos hemos centrado en los principios b√°sicos comunes de ECDSA, adem√°s se espera que la implementaci√≥n pr√°ctica de algoritmos de b√∫squeda cu√°ntica sea un desaf√≠o t√©cnico debido a los requisitos de recursos y la necesidad de superar errores cu√°nticos.</p>
<p>Aqu√≠ tienes una descripci√≥n general de en qu√© consisten algunos problemas que se consideran complejos de resolver mediante la computaci√≥n cl√°sica.</p>
<h2 id="ifp"><a class="header" href="#ifp">IFP</a></h2>
<p>El IFP se refiere al desaf√≠o de descomponer un n√∫mero entero grande en sus factores primos. En el caso de n√∫meros peque√±os, esto puede hacerse f√°cilmente mediante el uso de algoritmos como <a href="https://yosoytuprofe.20minutos.es/2022/11/09/que-es-la-criba-de-eratostenes-y-cual-es-su-importancia-en-las-matematicas/">el cribado de Erat√≥stenes</a> o <a href="https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm_for_logarithms">el algoritmo de factorizaci√≥n de Pollard</a>.</p>
<p>A modo de ejemplo simplificado, supongamos que queremos factorizar el n√∫mero compuesto <code>N = 35</code> utilizando el algoritmo de Shor. Despu√©s de aplicar el algoritmo, encontrar√≠amos que los factores primos de <code>N</code> son <code>5 y 7</code>.</p>
<p>Sin embargo, a medida que los n√∫meros crecen en tama√±o, el IFP se vuelve cada vez m√°s dif√≠cil de resolver. De hecho, la seguridad de muchos sistemas criptogr√°ficos se basa en la dificultad de factorizar n√∫meros grandes en tiempo razonable, como el popular algoritmo RSA.</p>
<h2 id="dlp"><a class="header" href="#dlp">DLP</a></h2>
<p>Por otro lado, el DLP implica encontrar el exponente desconocido de una potencia modular dada. En t√©rminos m√°s sencillos, se trata de resolver la ecuaci√≥n <code>(y = gÀ£ mod p)</code> para el exponente desconocido <code>(x)</code>, donde <code>(g)</code> y <code>(p)</code> son n√∫meros conocidos e <code>(y)</code> es el resultado de la operaci√≥n de potenciaci√≥n modular. Para valores peque√±os de <code>(p)</code>, el DLP puede resolverse mediante la aplicaci√≥n de m√©todos exhaustivos como la prueba y error.</p>
<p>A modo de ejemplo simplificado, ser√≠a encontrar el logaritmo discreto de <code>base 2</code> para el n√∫mero <code>5</code> <code>m√≥dulo 11</code>. Esto implica encontrar el valor de <code>x</code> en la ecuaci√≥n <code>2À£ ‚â° 5 (mod 11).</code></p>
<p>Realizando los c√°lculos paso a paso:</p>
<ul>
<li>2¬π ‚â° 2 (mod 11)</li>
<li>2¬≤ ‚â° 4 (mod 11)</li>
<li>2¬≥ ‚â° 8 (mod 11)</li>
<li>2‚Å¥ ‚â° 5 (mod 11)</li>
</ul>
<p>Entonces, el valor de <code>x</code> que satisface la ecuaci√≥n <code>2À£ ‚â° 5 (mod 11)</code> es <code>x = 4</code>.</p>
<h2 id="ecdlp"><a class="header" href="#ecdlp">ECDLP</a></h2>
<p>La seguridad de esquemas criptogr√°ficos basados en <strong>ECC</strong>, como <strong>ECDSA</strong>, se basa en la dificultad de resoluci√≥n del problema del logaritmo discreto de curva el√≠ptica o <strong>ECDLP</strong>. Las curvas el√≠pticas son objetos matem√°ticos utilizados en criptograf√≠a de clave p√∫blica, y el <strong>ECDLP</strong> ser√≠a el problema de hallar el valor de <code>‚ÄòK‚Äô</code> en esta ecuaci√≥n, <code>P =k‚ãÖG</code>, donde <code>P</code> es un punto en la curva, <code>k</code> es el valor que debemos hallar y <code>G</code> es un punto base conocido (el generador).</p>
<p>Al igual que en el caso del <strong>DLP</strong>, el <strong>ECDLP</strong> se vuelve m√°s dif√≠cil de resolver a medida que el tama√±o de los n√∫meros involucrados en esas expresiones matem√°ticas aumentan</p>
<h2 id="ecdsa"><a class="header" href="#ecdsa">ECDSA</a></h2>
<p>Por √∫ltimo llegamos a un algoritmo ampliamente utilizado y conocido como es el <strong>ECDSA</strong>, que se utiliza com√∫nmente en blockchain. La clave p√∫blica se obtiene multiplicando un punto base conocido (llamado generador) en la curva el√≠ptica por un entero, que representa la llave privada. El desaf√≠o radica en encontrar ese valor privado a partir del punto p√∫blico conocido en la curva.</p>
<p>La curva el√≠ptica <strong>secp256k1</strong> est√° definida por la ecuaci√≥n: <code>y¬≤ = x¬≥ + ax + b</code> sobre <code>ùîΩp</code> donde <code>p</code> es un n√∫mero primo grande.</p>
<p>El algoritmo de Shor, en su versi√≥n completa y ejecutado en un computador cu√°ntico lo suficientemente grande y estable, podr√≠a factorizar el n√∫mero primo <code>p</code> en esta ecuaci√≥n, lo que proporcionar√≠a informaci√≥n sobre el orden del subgrupo c√≠clico relacionado con la curva.</p>
<p>Si se pudiera determinar el orden del subgrupo c√≠clico relacionado con la curva <code>secp256k1</code> utilizando el algoritmo de <strong>Shor</strong>, ser√≠a posible encontrar el valor privado a partir de la clave p√∫blica. Esto comprometer√≠a la seguridad de <strong>ECDSA</strong>, ya que la clave privada es fundamental para generar firmas digitales y autenticar transacciones. Es importante destacar que el algoritmo de Shor plantea un desaf√≠o para los sistemas criptogr√°ficos actuales basados en la factorizaci√≥n de n√∫meros enteros o en el logaritmo discreto, como <strong>RSA</strong> y <strong>ECDSA</strong>.</p>
<p>No obstante, la implementaci√≥n pr√°ctica de un algoritmo cu√°ntico capaz de realizar estos c√°lculos, como los mencionados ejemplos, todav√≠a se encuentra en desarrollo y no representa una amenaza inmediata para los sistemas criptogr√°ficos utilizados en la actualidad. La investigaci√≥n y el desarrollo continuo en criptograf√≠a pos-cu√°ntica son fundamentales para garantizar la seguridad en un entorno tecnol√≥gico en constante evoluci√≥n.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="criptograf√≠a-basada-en-lattice-previene-shor"><a class="header" href="#criptograf√≠a-basada-en-lattice-previene-shor">Criptograf√≠a basada en Lattice previene Shor</a></h2>
<p>En este cap√≠tulo aprenderemos c√≥mo una verificaci√≥n de esquemas de firmas puede ser lo suficientemente fuerte para prevenirnos contra un posible ataque ejecutado con el algoritmo de Shor, la criptograf√≠a basada en ret√≠culos <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_basada_en_ret%C3%ADculos"><strong>(Lattice)</strong></a>, es una forma segura de protegerse frente a muchos algoritmos.</p>
<p>Pensemos en un <a href="https://es.wikipedia.org/wiki/Red_(grupo)">ret√≠culo</a>, como una estructura matem√°tica que se forma mediante una red de puntos en un espacio n-dimensional. Es similar a una cuadr√≠cula o una rejilla en dos dimensiones, pero se extiende a cualquier n√∫mero de dimensiones. Cada punto en el ret√≠culo est√° ubicado en una posici√≥n determinada y est√° conectado a los puntos vecinos por l√≠neas rectas de igual longitud.</p>
<p>En el contexto de la criptograf√≠a basada en ret√≠culos, se utilizan ret√≠culos en <a href="https://es.wikipedia.org/wiki/Teor%C3%ADa_de_n%C3%BAmeros">teor√≠a de n√∫meros</a> para construir sistemas criptogr√°ficos. Estos ret√≠culos se definen mediante un conjunto de vectores base, que son combinaciones lineales de vectores de coordenadas con coeficientes enteros. Los ret√≠culos tienen propiedades matem√°ticas interesantes, como la propiedad de ser densos y uniformes en el espacio.</p>
<p>Los problemas computacionales basados en ret√≠culos, como el problema de la aproximaci√≥n m√°s cercana en ret√≠culos o el problema del vector corto m√°s cercano, se utilizan en criptograf√≠a para establecer la seguridad de los esquemas basados en ret√≠culos. Estos problemas son dif√≠ciles de resolver y se cree que no existen algoritmos eficientes para resolverlos en el caso general, lo que brinda seguridad a los sistemas criptogr√°ficos basados en ret√≠culos.</p>
<p>La criptograf√≠a basada en ret√≠culos es el t√©rmino gen√©rico para las construcciones de primitivas criptogr√°ficas que involucran ret√≠culos, ya sea en la construcci√≥n misma o en la prueba de seguridad.</p>
<p><strong>Las construcciones basadas en ret√≠culos son actualmente candidatas importantes para la criptograf√≠a post-cu√°ntica.</strong> A diferencia de los esquemas de clave p√∫blica m√°s ampliamente utilizados y conocidos, como RSA, Diffie-Hellman o los criptosistemas de curva el√≠ptica, que te√≥ricamente podr√≠an ser derrotados utilizando el algoritmo de Shor en un computador cu√°ntico, algunas construcciones basadas en ret√≠culos parecen ser resistentes a los ataques tanto de computadoras cl√°sicas como cu√°nticas. Adem√°s, muchas construcciones basadas en ret√≠culos se consideran seguras bajo la suposici√≥n de que ciertos problemas computacionales bien estudiados en ret√≠culos no pueden ser resueltos.</p>
<p>Aqu√≠ hay una breve explicaci√≥n de las diferencias entre los esquemas de criptograf√≠a basados en ret√≠culos en t√©rminos de encriptaci√≥n, funciones hash y intercambio de claves:</p>
<ol>
<li><strong>Encriptaci√≥n basada en ret√≠culos:</strong> los esquemas de encriptaci√≥n basados en ret√≠culos aprovechan las propiedades matem√°ticas de los ret√≠culos para proporcionar seguridad en la comunicaci√≥n.</li>
<li><strong>Funciones hash basadas en ret√≠culos:</strong> las funciones hash basadas en ret√≠culos utilizan ret√≠culos y operaciones matem√°ticas relacionadas para calcular los hashes y se utilizan en diversas aplicaciones criptogr√°ficas, como la integridad de datos y la firma digital.</li>
<li><strong>Intercambio de claves basado en ret√≠culos:</strong> el intercambio de claves basado en ret√≠culos como el <a href="https://newhopecrypto.org/">(Intercambio NewHope Protocol)</a> implica el establecimiento de una clave compartida entre dos o m√°s partes que desean comunicarse de manera segura. Los protocolos de intercambio de claves basados en ret√≠culos utilizan los ret√≠culos y los problemas computacionales relacionados con ellos para garantizar que las partes puedan acordar una clave sin que un tercero pueda determinarla. Estos esquemas se basan en la dificultad de resolver ciertos problemas matem√°ticos relacionados con los ret√≠culos para asegurar la confidencialidad de la clave compartida.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kyber-crystal"><a class="header" href="#kyber-crystal">Kyber Crystal</a></h1>
<p>En este estudio post-quantum veremos <a href="https://pq-crystals.org/kyber/resources.shtml"><strong>Kyber</strong></a>, antes de entrar dentro del ecosistema de Starkware y aprender c√≥mo se generan los contratos de cuentas, as√≠ como las caracter√≠sticas criptogr√°ficas y matem√°ticas detr√°s de las STARKs.</p>
<p>Kyber es un m√©todo de encapsulaci√≥n de clave <a href="https://en.wikipedia.org/wiki/Key_encapsulation">(KEM)</a> dise√±ado para resistir ataques criptoanal√≠ticos realizados por futuras computadoras cu√°nticas poderosas. Se utiliza para establecer un secreto compartido entre dos partes que se comunican, sin que un atacante <a href="https://en.wikipedia.org/wiki/Ciphertext_indistinguishability">(IND-CCA2)</a> en el sistema de transmisi√≥n pueda descifrarlo. Este criptosistema asim√©trico utiliza una variante del problema de redes de aprendizaje con errores <a href="https://en.wikipedia.org/wiki/Learning_with_errors">(learning with errors, LWE)</a> como su <a href="https://en.wikipedia.org/wiki/Trapdoor_function">funci√≥n b√°sica con trampa</a>. Gan√≥ la competencia del NIST para el primer est√°ndar de criptograf√≠a PQ.</p>
<p>La generaci√≥n de claves en Kyber no se basa en la factorizaci√≥n de enteros o en problemas relacionados con las curvas el√≠pticas, sino que utiliza el problema de aprendizaje con errores en ret√≠culos como base para la seguridad del algoritmo.</p>
<p>El sistema se basa en el aprendizaje con errores en m√≥dulos (M-LWE) del campo del aprendizaje autom√°tico, en conjunto con anillos ciclot√≥micos. Recientemente, tambi√©n se ha logrado una reducci√≥n formal matem√°tica estrecha de la problem√°tica del anillo LWE al MLWE. <strong>En comparaci√≥n con otros m√©todos de criptograf√≠a post-cu√°ntica, tiene las ventajas t√≠picas de los m√©todos basados en ret√≠culos, como el tiempo de ejecuci√≥n, el tama√±o de los textos cifrados y el material clave.</strong></p>
<p>En cuanto a los par√°metros, Kyber proporciona diferentes conjuntos para alcanzar diferentes niveles de seguridad. Por ejemplo, <code>Kyber-512</code> tiene una seguridad aproximada equivalente a <code>AES-128</code>, <code>Kyber-768</code> tiene una seguridad aproximada equivalente a <code>AES-192</code> y <code>Kyber-1024</code> tiene una seguridad aproximada equivalente a <code>AES-256</code>.</p>
<p>En resumen, Kyber utiliza un enfoque matem√°tico diferente a ECDSA en la generaci√≥n de claves. Se basa en el problema de aprendizaje con errores en ret√≠culos y en la selecci√≥n adecuada de par√°metros de seguridad. La seguridad de Kyber radica en la dificultad de resolver problemas criptogr√°ficos espec√≠ficos asociados a ese enfoque matem√°tico.</p>
<p>Con esto hemos concluido las bases criptogr√°ficas que nos han brindado los detalles de c√≥mo se generan los distintos tipos de criptograf√≠a sim√©trica o asim√©trica, as√≠ como las funciones hash y su importancia en la seguridad. Nos adentramos en c√≥mo se integraban en los Merkle Tree o Patricia Trie, para luego explorar el √°mbito de la computaci√≥n cu√°ntica y ver c√≥mo se pod√≠an resolver algunos de los problemas planteados por ciertas criptograf√≠as. Tambi√©n destacamos la importancia de las firmas y las verificaciones de firmas en los avances de la tecnolog√≠a de la computaci√≥n cu√°ntica.</p>
<p>La computaci√≥n cu√°ntica se mostr√≥ resistente a las bases sim√©tricas de una llave maestra o a las funciones hash en s√≠. Adem√°s, presenciamos avances en la prevenci√≥n de ataques cu√°nticos y en algoritmos cu√°nticos como Lattice o encapsulamientos por Kyber. Con estos avances en mente, es hora de pasar a ver las EOA (Externally Owned Accounts) y los firmantes en Ethereum, para luego diferenciarlos de la Account Abstraction nativa en Starknet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eoa-y-aa---firmantes"><a class="header" href="#eoa-y-aa---firmantes">EOA y AA - Firmantes</a></h1>
<p>Las cuentas de EOA <a href="https://ethereum.org/en/whitepaper/#ethereum-accounts"><strong>(Externally Owned Accounts)</strong></a> en Ethereum, al igual que muchas otras criptomonedas, utilizan el algoritmo ECDSA que aprendimos antes para generar claves y firmar transacciones digitalmente. Esto les permite participar de manera segura en la red y realizar operaciones. Las EOA son cuentas que pertenecen a usuarios externos a la cadena de bloques.</p>
<p>En Ethereum, el estado de una cuenta solo puede ser modificado a trav√©s de transacciones, las cuales deben ser iniciadas por una EOA. sin embargo, no cualquier persona puede activar una transacci√≥n desde cualquier EOA, aqu√≠ es donde entra en juego el concepto de firmante.</p>
<p>Cada cuenta en Ethereum est√° asociada con un objeto criptogr√°fico llamado keypair, como aprendimos antes.</p>
<p>La clave privada, se utiliza para firmar mensajes digitales, mientras que la clave p√∫blica permite que cualquiera pueda verificar que una firma en particular fue generada por la clave privada correspondiente.</p>
<p>La asociaci√≥n entre una cuenta y un firmante se realiza mediante la direcci√≥n de la cuenta. La direcci√≥n de un EOA se deriva de la clave p√∫blica del firmante, espec√≠ficamente, <strong>la direcci√≥n se obtiene tomando los √∫ltimos 20 bytes del hash Keccak-256 de la clave p√∫blica.</strong></p>
<p>El propietario de una cuenta puede autorizar una transacci√≥n desde su cuenta firmando los par√°metros de la transacci√≥n con la clave privada correspondiente.</p>
<p>La <a href="https://ethereum.org/en/whitepaper/#ethereum-accounts"><strong>curva el√≠ptica secp256k1</strong></a>  es una de las curvas el√≠pticas m√°s utilizadas en criptograf√≠a, especialmente en el contexto de criptomonedas como Bitcoin o Ethereum. Esto ha permitido establecer esquemas de firmas digitales que garantizan la integridad de las transacciones al asegurar la autenticidad de las claves.</p>
<p>La abstracci√≥n de firma y clave privada es una propiedad presente en algunos sistemas criptogr√°ficos, como ciertos esquemas de firmas digitales basados en identidad. Sin embargo, en el caso del algoritmo ECDSA utilizado en Ethereum y muchas otras blockchain, la firma est√° inherentemente vinculada a la clave privada de la cuenta y no es posible separarlas o abstraerlas, como podr√≠a ser el caso en otros esquemas dise√±ados con estos principios.</p>
<p>Ahora que ya hemos adquirido los conceptos b√°sicos y hemos prestado atenci√≥n para adquirir la formaci√≥n adecuada y avanzada, podemos sumergirnos en el apasionante ecosistema de StarkWare, Starknet, StarkEx y STARKs. Nuestra mente est√° mejor preparada para embarcarnos en el viaje que nos espera en el resto del documento y en las futuras series.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="starknet-aa"><a class="header" href="#starknet-aa">Starknet AA</a></h2>
<p>En esta secci√≥n sobre <a href="https://www.starknet.io/en"><strong>Starknet</strong></a>, continuaremos construyendo sobre los conceptos previamente abordados en los cap√≠tulos anteriores, donde exploramos temas fundamentales de criptograf√≠a. Esperamos que haya disfrutado de la informaci√≥n y recursos presentados en cap√≠tulos anteriores, ya que han sido de vital importancia para comprender lo que abordaremos a continuaci√≥n dentro de <strong>Starknet</strong>. Exploraremos c√≥mo mejora todo el ecosistema y c√≥mo los contratos de cuentas (CA) y el esquema de firmas abstra√≠das ofrecen beneficios significativos en comparaci√≥n con el <a href="https://medium.com/infinitism/erc-4337-account-abstraction-without-ethereum-protocol-changes-d75c9d94dc4a">ERC-4337</a>.</p>
<p><em>Si deseas aprender m√°s sobre el concepto y las variantes del ERC-4337, te recomendamos leer esta serie de art√≠culos en el blog de <a href="https://www.argent.xyz/argent-x/">Argent</a>. La serie est√° compuesta por la <a href="https://www.argent.xyz/blog/wtf-is-account-abstraction/">Parte 1</a>, <a href="https://www.argent.xyz/blog/part-2-wtf-is-account-abstraction/">Parte 2</a> y <a href="https://www.argent.xyz/blog/part-3-wtf-is-account-abstraction/">Parte 3</a>. Argent y <a href="https://braavos.app/">Braavos</a> son Smart wallets que aprovechan el poder del AA nativo en Starknet. Tambi√©n te recomendamos leer los art√≠culos de Braavos de <a href="https://braavos.app/account-abstraction-ethereum-comprehensive-guide/">Guide 101 AA</a> y <a href="https://braavos.app/account-abstraction-security-pyramid/">Security Pyramid AA</a>, los cuales presentan optimizaciones adicionales y capas de seguridad que exploraremos m√°s adelante. Estos recursos te proporcionar√°n una mejor comprensi√≥n del concepto de <strong>AA</strong> y del <strong>ERC-4337</strong>.</em></p>
<p><strong>¬°As√≠ que sin m√°s pre√°mbulos, bienvenidos a Starknet!</strong></p>
<p>En el ecosistema de Starknet, se encuentran diversas metodolog√≠as para generar claves y firmas. A diferencia de las cuentas EOA, en Starknet se emplea <strong>Account Abstraction</strong> <a href="https://book.starknet.io/chapter_5/index.html"><strong>(AA)</strong></a> para la implementaci√≥n de <strong>Contract Accounts</strong> <a href="https://book.starknet.io/chapter_5/index.html#ethereums_current_account_system_a_closer_look">(CA)</a>. Estos contratos son responsables de establecer la l√≥gica en nuestras cuentas dentro de Starknet, incluyendo la validaci√≥n del esquema de firma abstra√≠do.</p>
<p>En lugar de utilizar ECDSA, Starknet utiliza una variaci√≥n llamada [<strong>STARK Curve</strong>], un tipo de curva el√≠ptica m√°s amigable y optimizada que es nativa en el ecosistema, esta variante nos ofrece mejoras y caracter√≠sticas espec√≠ficas para las necesidades de Starknet.</p>
<p>Lo grandioso de tener esta abstracci√≥n nativa es que permite a√±adir diferentes l√≥gicas en tus esquemas o capas adicionales. Normalmente, se utiliza un sistema asim√©trico usando la curva el√≠ptica <code>secp256k1</code>, basado en la pseudoaleatoriedad y diversas operaciones matem√°ticas utilizando dicha curva, para generar claves privadas y p√∫blicas. Sin embargo, tambi√©n se pueden a√±adir curvas adicionales de forma nativa al crear un CA, como lo ha hecho Braavos con la <a href="https://github.com/myBraavos/efficient-secp256r1">secp256r1</a>. Esta curva cuenta con un sistema de firmas integrado, mejor optimizado y preparado para dispositivos modernos, donde el signer puede almacenar los datos habilitados por biometricidad en dispositivos aislados y seguros, como el m√≥dulo &quot;Enclave&quot; de Apple.</p>
<p>La AA desempe√±a un papel crucial al abstraer el esquema de firmas o verificaci√≥n de firmas de la ejecuci√≥n. Como vimos anteriormente, podemos generar una clave privada y mediante ECDSA generar una clave p√∫blica. En este caso el poseedor de esta clave privada y del esquema de firma asociado tiene el poder de realizar transacciones en Starknet, los <a href="https://book.starknet.io/chapter_8/transactions.html">dos tipos de transacciones</a> son <code>DEPLOY</code> o <code>INVOKE</code>.</p>
<p><img src="./assets/Invoke.png" alt="graph" /></p>
<div align="center">
<em>Contrato de Cuenta de usuario</em>
</div>
<p>Con AA podemos modificar estas firmas o curvas. Por ejemplo, la curva <code>Secp256r1</code>, vimos que ofrece una seguridad adicional en Braavos al configurar una firma biom√©trica en el m√≥dulo de seguridad del enclave. De esta manera, esta firma biom√©trica solo puede ser a√±adida gracias a AA.</p>
<p>Todo esto es posible gracias al lenguaje de programaci√≥n utilizado en la implementaci√≥n, el poderoso <a href="https://starkware.co/cairo/"><strong>Cairo</strong></a>, as√≠ que analicemos c√≥mo Cairo incorpora esta abstracci√≥n en su programaci√≥n.</p>
<p>En primer lugar, se necesita validar la firma y comprobar que coincide con la generada mediante ECDSA antes de proceder a la ejecuci√≥n. Estas dos funciones principales son <code>validate</code> y <code>execute</code>. Adem√°s, <code>execute</code> tambi√©n puede realizar m√∫ltiples llamadas utilizando <code>execute_calls</code>.</p>
<p><img src="./assets/invoke_execute.gif" alt="graph" /></p>
<div align="center">
<em>Informaci√≥n de la L√≥gica separada de las funciones validate, execute</em>
</div>
<p>Ahora analicemos c√≥mo Cairo incorpora esta abstracci√≥n en su programaci√≥n.</p>
<p>Veamos c√≥mo funciona un ciclo de transacci√≥n con AA nativa y c√≥mo se representa gr√°ficamente este ciclo completo de firmas para detectar si es correcto y realizar la operaci√≥n.</p>
<p>Tambi√©n pensemos en c√≥mo se podr√≠an combinar de manera eficiente firmas como ha realizado Braavos con la EC <code>secp256r1</code> o incluso realizar la verificaci√≥n de firmas, como vimos con Lattice para prevenir ataques cu√°nticos.</p>
<p><img src="./assets/transaccion.gif" alt="graph" /></p>
<div align="center">
<em>Ciclo completo de una firma y validaci√≥n de una trnasacci√≥n</em>
</div>
<p>Los conocimientos previos adquiridos nos han ense√±ado muchas cosas, una de ellas es c√≥mo el algoritmo de Shor puede te√≥ricamente romper ECDSA, pero no podr√° romper una prueba STARK. </p>
<p>En la secci√≥n de generaci√≥n de STARKs, aprenderemos como gracias a sus bases de criptograf√≠a sim√©trica y otras variables, si alguien nos roba, hackea o perdemos la cuenta, el esquema <strong>PQS</strong> para la prueba no ser√° de mucha utilidad, ya que no se ha alterado la integridad del estado de los datos, sino que por oun te√≥rico ataque criptoanal√≠tico se habr√° obtenido tu PK, lo que permitir√≠a mover los fondos de forma justa.</p>
<p><strong>Pero, ¬øqu√© suceder√≠a si tuvi√©ramos un esquema de verificaci√≥n de firmas seguro frente a un ataque cu√°ntico?</strong></p>
<p>Aqu√≠ es donde entran en juego peque√±os cambios, espec√≠ficamente en la parte de validaci√≥n y no de ejecuci√≥n, con las mejoras en Starknet y con la ayuda de AA nativo, est√° implementando para prepararse para el futuro. Una posibilidad ser√≠a el uso de Lattice o Kyber, aunque el futuro no est√° escrito, as√≠ que ha llegado el momento de ver c√≥mo se genera la parte de la EC.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-en-cairo---stark-curve"><a class="header" href="#ec-en-cairo---stark-curve">EC en Cairo - STARK Curve</a></h1>
<p>Como hemos visto en cap√≠tulos anteriores, en el contexto de los sistemas criptogr√°ficos, la elecci√≥n de la curva el√≠ptica adecuada es de suma importancia. En este caso, se utiliza una variante de EC la cual ha sido especialmente dise√±ada y optimizada para su aplicaci√≥n en el entorno de Starknet.</p>
<p>La STARK Curve <a href="https://github.com/starkware-libs/cairo-lang/blob/361fe32d5930db340ea78fe05aedfe706f6c9405/src/starkware/cairo/common/ec.cairo"><strong>(EC.cairo)</strong></a> se define mediante la ecuaci√≥n:</p>
<p><img src="./assets/stark_curve.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Los valores espec√≠ficos de <code>Œ±</code>, <code>Œ≤</code> y <code>p</code> utilizados en esta curva han sido cuidadosamente seleccionados para proporcionar propiedades criptogr√°ficas s√≥lidas y un rendimiento eficiente en el contexto de los contratos de cuenta nativos en Starknet.</p>
<p>En particular, los valores de <code>Œ±</code>, <code>Œ≤</code> (notese que es <code>œÄ</code> ‚ÄúPI‚Äù sin decimales usando 67 digitos) y <code>p</code> son los siguientes:</p>
<p><img src="./assets/stark_curve1.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Estos valores aseguran que la curva el√≠ptica Stark-friendly cumple con los requisitos de seguridad necesarios para su aplicaci√≥n en sistemas criptogr√°ficos.</p>
<p>Adem√°s se utiliza un punto generador <a href="https://docs.starkware.co/starkex/crypto/stark-curve.html">(G)</a> espec√≠fico asociado a esta curva. El punto generador <code>G</code> se define como:</p>
<p><img src="./assets/stark_curve_g.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Este punto generador desempe√±a un papel fundamental en el esquema de firmas digitales ECDSA, permitiendo la generaci√≥n de claves p√∫blicas, como aprendimos al momento de hablar del Generador de Claves.</p>
<p>La elecci√≥n de la curva el√≠ptica Stark-friendly y el punto generador <code>G</code> asociado a ella proporcionan una base s√≥lida y optimizada para la implementaci√≥n de esquemas criptogr√°ficos en el entorno de Starknet. Estos elementos garantizan la seguridad y eficiencia necesarias para la creaci√≥n de contratos de cuenta nativos y la verificaci√≥n de firmas digitales en el sistema.</p>
<p>Si desea probar y adentrarse en el despliegue de cuentas en Starknet, o si est√° interesado en aprender c√≥mo se generan y calculan off-chain, y luego financiar esas cuentas para que los contratos de cuenta se autodesplieguen, le animamos a seguir los ejercicios oficiales de <a href="https://github.com/starknet-edu/starknet-accounts/blob/answers/ES%20README.md"><strong>Starknet-Edu Account</strong></a> o las <a href="https://github.com/Nadai2010/Nadai-StarknetEs-Guia-Cairo1#configuraci%C3%B3n-de-una-cuenta"><strong>Gu√≠as Completas Cairo 1</strong></a> proporcionadas por <a href="https://twitter.com/StarkNetEs">Starknet-Es</a> para realizar pruebas reales.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-braavos---secp256r1"><a class="header" href="#my-braavos---secp256r1">My Braavos - Secp256r1</a></h1>
<p>Comencemos explorando un dato interesante relacionado con la curva el√≠ptica vista en cap√≠tulos anteriores, la <code>secp256k1</code>. En este contexto, la <code>k</code> hace referencia a <a href="https://es.wikipedia.org/wiki/Neal_Koblitz"><strong>Koblitz</strong></a>, un destacado matem√°tico cuyas contribuciones fueron fundamentales para el desarrollo de la criptograf√≠a y la teor√≠a de n√∫meros.</p>
<p>Por otro lado, en el caso de <code>secp256r1</code>, la <code>r</code> significa <code>random</code>, resaltando el √©nfasis en el proceso de selecci√≥n aleatoria de par√°metros utilizado en esta curva el√≠ptica.</p>
<p>Braavos ha incorporado la firma y validaci√≥n de transacciones utilizando <code>secp256r1</code>, lo que brinda una excelente experiencia al usuario final al permitir transacciones con firma biom√©trica directamente en el dispositivo del usuario, a√±adiendo as√≠ un nivel adicional de seguridad. Puedes encontrar m√°s detalles sobre esta implementaci√≥n en el <a href="https://braavos.app/account-abstraction-security-pyramid/">blog de Braavos</a>, donde presentan una interesante Pir√°mide de Seguridad AA.</p>
<p><img src="./assets/Mybraavos.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Podemos ver en la c√∫spide de la pir√°mide al Multi-Signer (3FA). El Multi-Signer combina la protecci√≥n de la frase de recuperaci√≥n (seed phrase) en la extensi√≥n del navegador y el Hardware Signer o Protected Signer utilizando el dispositivo m√≥vil.</p>
<p>Ahora se requieren dos firmas de dos claves diferentes para ejecutar la transacci√≥n en la cadena, obteniendo una autenticaci√≥n de 3FA:</p>
<ul>
<li><strong>Algo que sabemos:</strong> la clave derivada de tu frase de recuperaci√≥n en la extensi√≥n del navegador.</li>
<li><strong>Algo que tenemos:</strong> tu dispositivo m√≥vil.</li>
<li><strong>Algo que somos:</strong> tu huella dactilar o identificaci√≥n biom√©trica facial.</li>
</ul>
<p>Cabe destacar que aunque se ha agregado otro firmante, no se ha a√±adido otra seed phrase, esto tambi√©n tiene el beneficio adicional de alejarse de las seed phrase a una mejor seguridad en los dispositivos m√≥viles/computadoras port√°tiles modernas, y seguridad superior cuando el dispositivo del usuario admite un chip de seguridad dedicado, como el <a href="https://cloud.google.com/blog/products/identity-security/titan-in-depth-security-in-plaintext">elemento seguro Titan de Android</a> o <a href="https://support.apple.com/es-us/guide/security/sec59b0b31ff/web">Enclave Secure de Apple</a>, etc.</p>
<p>Este chip Secure Enclave/Titan es un subsistema dedicado y aislado, totalmente separado del procesador de aplicaciones que puede generar claves privadas y mensajes de signo. Genera las teclas utilizando un generador interno de n√∫meros aleatorios verdaderos <a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator"><strong>(TRNG)</strong></a> y firma mensajes a trav√©s de la curva el√≠ptica <code>secp256r1</code> a trav√©s de su acelerador interno de claves p√∫blicas <a href="https://www.rambus.com/security/crypto-accelerator-cores/pka-ip-28/"><strong>(PKA)</strong></a>. Las claves privadas nunca abandonan el sistema seguro y son desconocidas / inaccesibles para cualquier persona, ni siquiera para el usuario o para la aplicaci√≥n en s√≠.</p>
<p>Esto significa que incluso si el n√∫cleo del procesador de la aplicaci√≥n del dispositivo se ve comprometido, <strong>¬°Nuestras claves se mantendr√°n seguras!</strong></p>
<p><img src="./assets/Enclave.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Vemos que esta implementaci√≥n de la firma ECDSA <code>secp256r1</code> en Cairo no es nativa, lo que significa que no tiene un Builtin dedicado nativo, esto puede llevar a un alto costo de gas al validar la firma. Sin embargo, Braavos es uno de los que han adoptado esta maravillosa novedad y est√° trabajando en mejorar la eficiencia de este proceso.</p>
<p>Adem√°s, aprovechando la funcionalidad de Multi-Call incorporada, los usuarios pueden agrupar m√∫ltiples transacciones en una √∫nica transacci√≥n at√≥mica. Esto no solo acelera y reduce los costos de las transacciones, sino que tambi√©n permite a los usuarios aprobar la cantidad exacta que desean depositar, lo cual mejora la seguridad al eliminar la necesidad de <a href="https://hackernoon.com/erc20-infinite-approval-a-battle-between-convenience-and-security-lk60350r">aprobaci√≥n infinita</a></p>
<p>En cuanto a la <strong>gesti√≥n de firmantes</strong>, cuando se a√±ade un firmante adicional, como un Hardware Signer o Protected Signer, el firmante original basado en semillas ya no puede firmar transacciones, a menos que se solicite la eliminaci√≥n del firmante adicional y se regrese al firmante basado en semillas. <strong>Esta solicitud tiene un retraso de tiempo (actualmente de 4 d√≠as)</strong> para su procesamiento.</p>
<p>Por otro lado, la funci√≥n de multifirma permite configurar la cuenta en modo de multifirma (actualmente admite 2 de 2), lo que significa que ninguna transacci√≥n se ejecutar√° hasta que los 2 firmantes definidos en la cuenta firmen la transacci√≥n. La seed phrase puede solicitar la desactivaci√≥n de la multifirma, pero esto <strong>tambi√©n tiene un retraso de tiempo (actualmente 4 d√≠as)</strong> antes de que se haga efectiva.</p>
<p>Vemos la importancia de las firmas y como vimos en el contexto del PQS, entendemos la relevancia de poder modificar nuestros esquemas de verificaci√≥n de firmas, como la utilizaci√≥n de Lattice o Kyber, por ejemplo. Ahora, centr√©monos en aprender c√≥mo creamos una Stark Key para StarkEx, el motor de escalabilidad de Starknet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creaci√≥n-de-una-stark-key-en-starkex"><a class="header" href="#creaci√≥n-de-una-stark-key-en-starkex">Creaci√≥n de una Stark Key en StarkEx</a></h1>
<p>Es importante comprender c√≥mo <a href="https://mirror.xyz/dashboard/edit/KJVQJ6X6wvbf6ps1oy96zpE3TztWyhSIDZd2IHu5NuI">StarkEx</a> se comunica con otras billeteras en t√©rminos de firmas, y c√≥mo mantiene todo el motor de transacciones y pruebas STARKs en su interior.</p>
<p>StarkEx ofrece soluciones altamente especializadas para diferentes aplicaciones que deseen construir sobre su servicio, y esto es parte de lo que StarkWare, como compa√±√≠a, proporciona a grandes empresas o cualquier otra entidad que desee aprovechar su conjunto de profesionales y servicios adaptables.</p>
<p>Aplicaciones populares como Sorare, Rhino y Apex Pro, por ejemplo, aprovechan las soluciones ofrecidas por StarkWare. Estas aplicaciones espec√≠ficas se construyen sobre el marco de Starknet. Si bien no profundizaremos en los detalles espec√≠ficos de estas aplicaciones aqu√≠, se recomienda visitar la <a href="https://layer2es.notion.site/39d63a8af9ca4524a7237b1f2456e745">Biblioteca de Layer 2 en Espa√±ol</a> para obtener informaci√≥n m√°s detallada sobre cada una de ellas y comprender mejor c√≥mo se integran en las soluciones de escalado de capa 2 de Ethereum.</p>
<p>Para utilizar StarkEx y asociar tu cuenta de MetaMask u otra billetera a Starknet, es necesario crear una Stark Key. StarkEx admite diferentes tipos de billeteras y m√©todos para crear esta clave, dependiendo de c√≥mo se utilizar√° posteriormente. A continuaci√≥n, se detallan las opciones disponibles:</p>
<h2 id="billeteras-compatibles-con-bip32"><a class="header" href="#billeteras-compatibles-con-bip32">Billeteras compatibles con BIP32</a></h2>
<p>Si est√°s utilizando una billetera compatible con <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki"><strong>BIP32</strong></a>, como Ledger, se recomienda seguir el EIP-2645. Este est√°ndar describe una ruta denominada <code>starkPath</code> y un algoritmo de derivaci√≥n de clave que utiliza esta ruta para obtener la <code>starkPrivateKey</code>.</p>
<p>La <code>starkPath</code> est√° compuesta por cuatro par√°metros pasados y dos par√°metros internos, y sigue la siguiente estructura:</p>
<p><code>m/purpose'/layer'/application'/ethAddress1'/ethAddress2'/index</code></p>
<p>Los par√°metros externos pasados son los siguientes:</p>
<ul>
<li><strong>Purpose:</strong> el n√∫mero de EIP correspondiente (en este caso, 2645).</li>
<li><strong>Layer:</strong> se utiliza para diferenciar entre tecnolog√≠as y se calcula como <code>sha256(layer) &amp; ((1 &lt;&lt; 31) - 1))</code>. En el contexto de StarkEx, el valor es <code>579218131</code> seg√∫n lo descrito en el EIP-2645.</li>
<li><strong>Application:</strong> sirve para diferenciar entre aplicaciones y se calcula como: <code>sha256(application_name) &amp; ((1 &lt;&lt; 31) - 1))</code>.</li>
<li><strong>Index:</strong> permite tener m√∫ltiples claves por direcci√≥n de Ethereum.</li>
</ul>
<p>Los par√°metros internos usados son los siguientes:</p>
<ul>
<li><strong>ethAddress1:</strong> Los 31 LSB de la direcci√≥n Ethereum del usuario, es decir, <code>(ethAddress &amp; 1 &lt;&lt; 31) - 1</code></li>
<li><strong>ethAddress2:</strong> Los 31 LSB siguientes de la direcci√≥n Ethereum del usuario, es decir, <code>(ethAddress &gt;&gt; 31) &amp; 1 &lt;&lt; 31) - </code>.</li>
</ul>
<p>Adem√°s, es importante que las billeteras compatibles con BIP32 mantengan un estado persistente en relaci√≥n con su propia direcci√≥n de Ethereum.</p>
<h2 id="billeteras-no-compatibles-con-bip32"><a class="header" href="#billeteras-no-compatibles-con-bip32">Billeteras NO compatibles con BIP32</a></h2>
<p>Si est√°s utilizando una billetera que no es compatible con BIP32, como MetaMask, se recomienda seguir el siguiente proceso:</p>
<ol>
<li>El usuario firma un mensaje utilizando su clave privada de Ethereum a trav√©s de MetaMask u otra billetera similar. Se recomienda utilizar el est√°ndar  IP-712 para brindar transparencia al usuario durante el proceso de firma. Es importante que el mensaje incluya una advertencia, indicando al usuario que so1lo debe firmarlo si proviene de un dominio espec√≠fico.</li>
<li>La firma <code>(r, s, v)</code> se utiliza como entrada para el algoritmo de derivaci√≥n de clave, que generar√° la <code>starkPrivateKey</code>. Para realizar este c√°lculo, puedes utilizar la biblioteca <a href="https://www.npmjs.com/package/@starkware-industries/starkware-crypto-utils">StarkEx Crypto SDK</a>. Primero, llama a la funci√≥n <code>getPrivateKeyFromEthSignature</code> para obtener la clave privada a partir de la firma, y luego utiliza la funci√≥n <code>privateToStarkKey</code> para calcular la <code>StarkKey</code>.</li>
</ol>
<p>Al seguir estos pasos, podr√°s crear una Stark Key asociada a tu cuenta de MetaMask u otra billetera compatible. Esta clave te permitir√° interactuar con StarkEx y otras aplicaciones dentro del ecosistema de Starknet, realizar transacciones seguras y aprovechar las funcionalidades ofrecidas por esta plataforma.</p>
<p><img src="./assets/Stark_Key.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-y-funciones-hash"><a class="header" href="#starknet-y-funciones-hash">Starknet y Funciones Hash</a></h1>
<p>En cap√≠tulos anteriores aprendimos la importancia de las firmas, el poder de AA y la asociaci√≥n de los hash dentro del ecosistema de Starknet y StarkEx. Ahora, profundicemos en c√≥mo se utilizan y los diferentes tipos de hash que podemos encontrar.</p>
<h2 id="dominio-y-rango"><a class="header" href="#dominio-y-rango">Dominio y rango</a></h2>
<p>Todas las salidas de las funciones de hash se mapean eventualmente a elementos en <code>ùîΩ‚Çö</code> con <code>p = 2¬≤‚Åµ¬π + 17 ‚ãÖ 2¬π‚Åπ¬≤ + 1</code> como vimos en la Stark Curve.</p>
<p>Las funciones hash son componentes clave en las especificaciones de Starknet, y se utilizan para mapear las salidas de los c√°lculos a elementos en el campo finito <code>ùîΩ‚Çö</code>. A continuaci√≥n, explicaremos las tres funciones hash utilizadas en Starknet de manera m√°s clara:</p>
<p><img src="./assets/Stark_func_hash.png" alt="graph" /></p>
<div align="center">
<em>Ciclo completo de una firma y validaci√≥n de una trnasacci√≥n</em>
</div>
<ol>
<li><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#starknet_keccak"><strong>sn_keccak:</strong></a> Esta funci√≥n hash se basa en el algoritmo KECCAK, que es una familia de funciones hash criptogr√°ficas como vimos antes. Su dominio es el conjunto de cadenas de bits compuestas por ceros y unos <code>{0,1}*</code> y su rango es el campo finito <code>ùîΩ‚Çö</code> La funci√≥n toma una cadena de bits como entrada y produce una salida en el campo finito <code>ùîΩ‚Çö</code>.</li>
<li><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#pedersen_hash"><strong>Pedersen:</strong></a> La funci√≥n hash Pedersen es una funci√≥n hash computacionalmente segura que se utiliza en la construcci√≥n de criptograf√≠a de compromiso cero y otras primitivas criptogr√°ficas. Su dominio es el conjunto de pares de elementos del campo finito <code>ùîΩ¬≤p</code>, donde <code>p</code> es un n√∫mero primo, y su rango es el campo finito <code>ùîΩp</code>. La funci√≥n toma un par de elementos del campo finito <code>ùîΩ¬≤p</code> como entrada y produce una salida en el campo finito <code>ùîΩp</code>.</li>
<li><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#poseidon_hash"><strong>Poseidon:</strong></a> La funci√≥n hash Poseidon es una funci√≥n hash criptogr√°fica. Su dominio es un conjunto de elementos del campo finito <code>ùîΩp</code>, que incluye el cero y los elementos inversos multiplicativos, y su rango tambi√©n es el campo finito <code>ùîΩp</code>. La funci√≥n toma un conjunto de elementos del campo finito <code>ùîΩp</code> como entrada y produce una salida en el campo finito <code>ùîΩp</code>.</li>
</ol>
<p>Las funciones de hash mencionadas son a√±adidas como <a href="https://mirror.xyz/0x7D1c14939AcEE5ca141c8beDF3474AFBf3884041/RTgQnMxeVGRCczih1pGXKy2KGFcU_xmf2NMx52wDgH0"><strong>Builtin</strong></a> (AIR integradas espec√≠ficas de aplicaciones), que se utilizan como herramientas adicionales en el protocolo para garantizar la seguridad y la integridad de las transacciones y los datos.</p>
<p>Estas funciones hash desempe√±an un papel fundamental en las operaciones de Starknet al garantizar la integridad y seguridad de los c√°lculos realizados en el sistema.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak-starknet"><a class="header" href="#keccak-starknet">Keccak Starknet</a></h1>
<p>Keccak en Starknet es una implementaci√≥n espec√≠fica de la funci√≥n hash <code>Keccak256</code> adaptada para su uso en la red Starknet. Proporciona un m√©todo confiable y eficiente para calcular hashes dentro del entorno de Starknet.</p>
<p>Generalmente denotado por <code>sn_keccak</code>, se define como los primeros <strong>250 bits del hash Keccak256</strong> (esto es simplemente <code>Keccak256</code> ampliado para ajustarse a un field element ‚Äúelemento de campo‚Äù).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pedersen-hash-starknet"><a class="header" href="#pedersen-hash-starknet">Pedersen Hash Starknet</a></h1>
<p>El <a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#pedersen_hash">Pedersen hash</a> es una funci√≥n hash criptogr√°fica utilizada en criptograf√≠a propuesta por Torben Pedersen en 1991.</p>
<p>Uno de los aspectos interesantes del <a href="https://en.wikipedia.org/wiki/Commitment_scheme">esquema de compromiso de Pedersen</a> es su propiedad homom√≥rfica, que permite realizar la adici√≥n entre dos compromisos. En otras palabras, dados dos mensajes <code>m‚ÇÅ</code> y <code>m‚ÇÇ</code>, y sus respectivas aleatoriedades <code>r‚ÇÅ</code> y <code>r‚ÇÇ</code>, el Pedersen hash permite combinarlos de manera segura.</p>
<p>La funci√≥n Pedersen Hash utilizada en Starknet es resistente a colisiones para entradas de longitud fija, siempre y cuando la funci√≥n de codificaci√≥n subyacente sea inyectiva. Una funci√≥n inyectiva asigna elementos distintos de su dominio a elementos distintos de su codominio, esto hace que el Pedersen hash sea resistente a ciertos tipos de ataques, como colisiones y preim√°genes.</p>
<p>Sin embargo, es importante destacar que la implementaci√≥n y el contexto en el que se utilice esta funci√≥n pueden influir en su resistencia. Para obtener m√°s informaci√≥n se recomienda realizar una lectura sobre <a href="https://research.nccgroup.com/2023/03/22/breaking-pedersen-hashes-in-practice/">Pedersen hashes in Practice</a>.</p>
<p>En Starknet, se utiliza la EC amigable STARK curve sobre el campo finito <code>ùîΩ‚Çö</code> para calcular el Pedersen hash de manera eficiente y segura.</p>
<p><img src="./assets/Pedersen_Starknet.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<ul>
<li>Œ± = 1</li>
<li>Œ≤ = 31415926535897932384626433832795028841971693993751058209749 44592307816406665</li>
</ul>
<p>Los par√°metros <code>Œ±</code> y <code>Œ≤</code> de la curva son importantes en t√©rminos de seguridad y eficiencia en los algoritmos utilizados en la construcci√≥n del Pedersen hash y los protocolos de ZKP o basados en STARK.</p>
<p>Dada una entrada <code>(a, b) ‚àà ùîΩ¬≤p</code>, se divide en <code>alow</code>, <code>ahigh</code>, <code>blow</code> y <code>bhigh</code>, donde la parte <code>low</code> consiste en los <strong>248 bits menos significativos del elemento</strong> y la parte <code>high</code> consiste en los <strong>4 bits m√°s significativos del elemento.</strong> El c√°lculo del Pedersen hash se define de la siguiente manera:</p>
<p><img src="./assets/Pedersen_Starknet1.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>En esta f√≥rmula, <code>[P]x</code> denota la coordenada <code>x</code> del punto <code>P</code>. Para calcular el hash, se realiza una combinaci√≥n lineal de los puntos <code>P0, P1, P2 y P3</code>, ponderados por los valores <code>alow</code>, <code>ahigh</code>, <code>blow</code> y <code>bhigh</code>, respectivamente. Luego, se suma el punto <code>shift_point</code> y se extrae la coordenada <code>x</code> del resultado.</p>
<p>Los valores de las constantes <code>shift_point</code>, <code>P0</code>, <code>P1</code>, <code>P2</code> y <code>P3</code> se encuentran en el archivo <a href="https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/crypto/signature/fast_pedersen_hash.py">fast_pedersen_hash.py</a>. Este archivo contiene la implementaci√≥n espec√≠fica del algoritmo necesario para calcular el Pedersen hash.</p>
<p>No se trata de puntos en la EC en s√≠ misma, sino de valores espec√≠ficos que se han elegido para el c√°lculo del hash y tampoco est√°n relacionadas con la EC ni con el punto generador <code>G</code>, revise minuciosamente la informaci√≥n oficial en caso de querer hacer pruebas sobre Stark Curve o Hash en Starknet. Estas constantes se eligen de forma independiente para el c√°lculo del hash y se utilizan en combinaci√≥n con los valores de entrada para obtener el hash resultante.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poseidon-hash-starknet"><a class="header" href="#poseidon-hash-starknet">Poseidon hash Starknet</a></h1>
<p>La funci√≥n <strong>Poseidon hash</strong> es un <a href="https://www.poseidon-hash.info/">ZK-friendly Hashing</a>, pertenece a una familia de funciones hash dise√±adas para ser muy eficientes en circuitos algebraicos. Como tal, pueden ser muy √∫tiles en sistemas ZK proof como STARKs y otros.</p>
<p>Poseidon es una construcci√≥n de esponja basada en la permutaci√≥n Hades, la estrategia de dise√±o Hades se basa en dividir el proceso en diferentes rondas para garantizar la seguridad y eficiencia del algoritmo:</p>
<ul>
<li>En las primeras rondas, denominadas <code>Rf</code>, se aplican las <code>S-boxes</code> al estado completo. Las <code>S-boxes</code> son funciones no lineales que mezclan y transforman los datos. En esta etapa inicial, se busca lograr una alta dispersi√≥n de los bits en el estado.</li>
<li>Despu√©s de estas rondas iniciales, se llevan a cabo las rondas intermedias, denominadas <code>RP</code>. En cada ronda intermedia, se aplica √∫nicamente una <code>S-box</code>, mientras que el resto del estado permanece sin cambios, es decir, se utiliza una funci√≥n identidad en lugar de las <code>S-boxes</code> faltantes. Esta simplificaci√≥n reduce el costo computacional y la complejidad del algoritmo.</li>
<li>Finalmente, en las √∫ltimas rondas, nuevamente se utilizan las <code>S-boxes</code> para el estado completo. Estas rondas finales, al igual que las rondas iniciales, permiten obtener una mezcla y transformaci√≥n adicional de los datos.</li>
</ul>
<p>Para una revisi√≥n m√°s profunda sobre su integridad en sistema de Proof pueden revisar <a href="https://eprint.iacr.org/2019/458.pdf">POSEIDON: A New Hash Function for Zero-Knowledge Proof Systems (Updated Version)</a>.</p>
<p>La versi√≥n de <strong>Poseidon</strong> utilizada en Starknet se basa en una permutaci√≥n de estado de tres elementos.</p>
<p>El campo <strong>ùîΩ</strong>, sobre el que se definen las declaraciones aritm√©ticas que utilizan Poseidon. A menudo es determinado por el sistema de prueba ZK. Lo m√°s probable es que sea un subgrupo de primer orden del grupo de puntos de una curva el√≠ptica. Poseidon mapea secuencias de elementos <strong>ùîΩ</strong> a una secuencia de longitud fija de elementos <strong>ùîΩ</strong>.</p>
<p>A continuaci√≥n, se define el <strong>Poseidon hash</strong> de hasta 2 elementos, y tambi√©n se menciona una versi√≥n que admite un n√∫mero arbitrario de entradas.</p>
<p><img src="./assets/Poseidon_Starknet.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashing-de-array-matrices"><a class="header" href="#hashing-de-array-matrices">Hashing de Array (matrices)</a></h1>
<p>En este cap√≠tulo, explicaremos c√≥mo se realizan los hashings de Arrays (matrices) utilizando las funciones Pedersen y Poseidon en el contexto de Starknet. Estas operaciones son fundamentales para garantizar la integridad y seguridad de los c√°lculos realizados en el sistema.</p>
<p>El hashing de un array implica aplicar la funci√≥n de hash correspondiente a cada elemento del array, de manera secuencial o iterativa. Esto permite resumir y representar de manera compacta la informaci√≥n contenida en el array, independientemente de su longitud o contenido espec√≠fico.</p>
<p>El hashing de un array es √∫til en muchas aplicaciones, como la verificaci√≥n de integridad de datos, la indexaci√≥n eficiente de informaci√≥n y la identificaci√≥n √∫nica de elementos.</p>
<h2 id="pedersen"><a class="header" href="#pedersen">Pedersen</a></h2>
<p>La funci√≥n hash Pedersen, denotada como <code>h</code>, se utiliza para calcular el hash de un array de elementos de campo. Consideremos un arreglo <code>a‚ÇÅ</code>, <code>a‚ÇÇ</code>, ..., <code>a‚Çô</code> que contiene <code>n</code> elementos. La definici√≥n de <code>h(a‚ÇÅ a‚ÇÇ, ..., a‚Çô)</code> es la siguiente:</p>
<ol>
<li>Comenzamos con un valor inicial de 0.</li>
<li>Aplicamos la funci√≥n de hash h al primer elemento a‚ÇÅ junto con el valor inicial. El resultado se convierte en el nuevo valor inicial.</li>
<li>Continuamos aplicando la funci√≥n de hash h al siguiente elemento a‚ÇÇ junto con el valor anteriormente obtenido. Nuevamente, el resultado se convierte en el nuevo valor inicial.</li>
<li>Repetimos este proceso hasta llegar al √∫ltimo elemento a‚Çô, aplicando la funci√≥n de hash en cada paso.</li>
<li>Finalmente, aplicamos la funci√≥n de hash h al √∫ltimo elemento an junto con el valor obtenido en el paso anterior.</li>
</ol>
<p>De esta manera, obtenemos el resultado final que representa el hash del array completo.</p>
<p><img src="./assets/Hash_Array.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Esta construcci√≥n en capas nos permite combinar de manera secuencial los elementos del array a medida que calculamos el hash. Cada iteraci√≥n agrega un nivel adicional de seguridad y complejidad al resultado final.</p>
<h2 id="poseidon"><a class="header" href="#poseidon">Poseidon</a></h2>
<p>La funci√≥n de hash Poseidon utiliza la permutaci√≥n Hades, representada por hades: <code>ùîΩ¬≥‚Çö‚ÜíùîΩ‚Çö</code>, con los par√°metros de Starknet. Dado un array <code>a‚ÇÅ</code>, <code>a‚ÇÇ</code>, ..., <code>a‚Çô</code> que contiene <code>n</code> field elements, definimos <code>poseidon(a‚ÇÅ, a‚ÇÇ, ..., a‚Çô)</code> como la primera coordenada de <code>H(a‚ÇÅ, a‚ÇÇ, ..., a‚Çô; 0, 0, 0)</code>,</p>
<ul>
<li><code>H(a‚ÇÅ, a‚ÇÇ, ..., a‚Çô; s‚ÇÅ, s‚ÇÇ, s‚ÇÉ)</code> se define de la siguiente manera:</li>
</ul>
<p><img src="./assets/Hash_Poseidon.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<ul>
<li><strong>Si n ‚â• 2:</strong> entonces <code>H(a‚ÇÅ,a‚ÇÇ,...,a‚Çô;s‚ÇÅ,s‚ÇÇ,s‚ÇÉ) = H(a‚ÇÉ, a‚ÇÑ, ..., a‚Çô;hades(s‚ÇÅ + a‚ÇÅ, s‚ÇÇ + a‚ÇÇ, s‚ÇÉ))</code>.</li>
<li><strong>Si n = 1:</strong> entonces <code>H(a‚ÇÅ; s‚ÇÅ, s‚ÇÇ, s‚ÇÉ) = hades(s‚ÇÅ + a‚ÇÅ, s‚ÇÇ + 1, s‚ÇÉ)</code>.</li>
<li><strong>Si n = 0:</strong> entonces <code>H(); s‚ÇÅ, s‚ÇÇ, s‚ÇÉ) = hades(s‚ÇÅ + 1, s‚ÇÇ, s‚ÇÉ)</code>.</li>
</ul>
<p>En resumen, la <code>funci√≥n poseidon(a‚ÇÅ,a‚ÇÇ,...,a‚Çô)</code> toma el array de field elements y aplica la permutaci√≥n Hades en capas. Cada iteraci√≥n de la permutaci√≥n combina los elementos del array en funci√≥n de los valores de  <code>s‚ÇÅ</code>, <code>s‚ÇÇ</code> y <code>s‚ÇÉ</code>, generando as√≠ una salida √∫nica. La primera coordenada de la salida final se considera el resultado de la funci√≥n de hash Poseidon.</p>
<p>Esta construcci√≥n en capas y la utilizaci√≥n de la permutaci√≥n Hades permiten obtener un hash seguro y resistente a ciertos ataques criptogr√°ficos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="s-t-arks"><a class="header" href="#s-t-arks">S-T-ARKs</a></h1>
<p>Ahora, adentr√©monos en una de las partes m√°s fascinantes del ecosistema, los <strong>STARKs</strong> <a href="https://starkware.co/stark/">(Scalable Transparent Argument of Knowledge)</a> que se basan en matem√°ticas modernas, la existencia de funciones hash criptogr√°ficas seguras y resistentes a las colisiones. Los STARKs presentan variados beneficios, entre los cuales tenemos:</p>
<ol>
<li>
<p><strong>Seguridad poscu√°ntica:</strong> los <strong>STARK</strong> son plausiblemente seguros frente a ordenadores cu√°nticos eficientes.</p>
</li>
<li>
<p><strong>Eficiencia concreta:</strong> el prover <strong>STARK</strong> es al menos <strong>10 veces m√°s r√°pido</strong> que el prover SNARK y el prover <a href="https://eprint.iacr.org/2017/1066.pdf">Bulletproofs</a>.</p>
<p>El verificador <strong>STARK</strong> es al menos <strong>2 veces m√°s r√°pido</strong> que el verificador <strong>SNARK</strong> y m√°s de <strong>10 veces m√°s r√°pido</strong> que el verificador <strong>Bulletproof</strong>.</p>
<p>A medida que StarkWare contin√∫e optimizando <strong>STARKs</strong> estos ratios probablemente mejorar√°n. Sin embargo, la longitud de una prueba <strong>STARK es ~100x mayor</strong> que la correspondiente <strong>SNARK</strong> y <strong>~20x mayor que BulletProofs</strong>.</p>
</li>
</ol>
<p>Puede encontrar una imagen animada de una comparativa con los datos expuestos sobre el proving time y verification time, tama√±o de la prueba, configuraci√≥n inicial y PQS entre STARKs y SNARKs, veremos c√≥mo cada una cumple con distintas propiedades que les permite ser recomendadas para variados usos.</p>
<p><img src="./assets//Stark_Prover.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Ahora que tenemos conceptos m√°s profundos sobre algunos aspectos de la criptograf√≠a, funciones hash y las operaciones detr√°s de cada una, veamos la importancia de la Integridad Computacional (CI), una propiedad fundamental para el d√≠a a d√≠a. Esta propiedad se refiere a la confianza en que la salida de un c√°lculo es correcta, permiti√©ndonos confiar en el saldo de una cuenta o en el monto de una factura en una tienda.</p>
<blockquote>
<p><strong>Pero, ¬øc√≥mo podemos garantizar esta integridad en un entorno digital donde no siempre podemos confiar en todas las partes involucradas?</strong></p>
</blockquote>
<p>Aqu√≠ es donde entra en juego la tecnolog√≠a STARK, que se basa en estas Validity Proof para garantizar que la computaci√≥n se realice correctamente, <strong>incluso si nadie est√° observando <code>‚ÄúINTEGRO‚Äù</code></strong>. STARKs utiliza matem√°ticas para lograr este objetivo y est√° dise√±ado para monitorear y garantizar la integridad de un gran c√°lculo realizado por un grupo de supercomputadoras poco confiables.</p>
<p>Las Validity Proofs son una herramienta crucial para garantizar la integridad y validez de los cambios realizados fuera de la cadena principal. Los sistemas de ZKP, en los que el prover posee informaci√≥n secreta que no es conocida por el verifier, son clave para las Validity Proofs. En el caso de Starknet, se trata de un Validity Rollup que utiliza STARKs.</p>
<p>Es importante tener en cuenta que ZK en Starknet, es una propiedad adicional que se utiliza para afirmar al probador que no tiene que revelar ninguna informaci√≥n incluida en el c√°lculo. Sin embargo, en el caso de Starknet como una capa 2 p√∫blica, los datos de transacci√≥n son p√∫blicos, lo que significa que no se ofrece privacidad como tal en transacciones, ocultar saldos u otras operaciones opacas, aunque los zk-STRAKs est√°n listas para eso.</p>
<p>En Starknet, el enfoque principal es el Validity Rollup, que se utiliza para probar la validez del c√°lculo computacional, a diferencia de otros protocolos que utilizan el t√©rmino <code>ZK Rollup</code>. Los STARKs en Starknet son Validity Proofs en lugar de ZK Proofs.</p>
<p>Los STARKs utilizan funciones de criptograf√≠a sim√©trica y hash criptogr√°ficos como componentes fundamentales en su construcci√≥n, las vulnerabilidades cu√°nticas conocidas en criptograf√≠a, como el algoritmo de Shor que puede factorizar n√∫meros enteros grandes y romper sistemas de criptograf√≠a asim√©trica basados en factorizaci√≥n, no afectan a las STARKs.</p>
<p><img src="./assets//Stark_1.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>En la imagen superior, se puede observar que las pruebas pueden basarse en principios de criptograf√≠a sim√©trica o asim√©trica, como aprendimos al principio del documento. Adem√°s, se pueden apreciar las diferentes propiedades de cada una en cuanto a escalabilidad, transparencia, seguridad en el futuro post-cu√°ntico o tama√±o de la prueba.</p>
<p>Como conclusi√≥n final antes de pasar a sus propiedades podemos ver para pruebas cortas como se recomienda utilizar <strong>Groth16</strong> o <strong>SNARKs</strong>, mientras que para todo lo dem√°s se sugiere <strong>STARK</strong>. Es importante destacar que este campo se encuentra en constante desarrollo y cada uno sigue optimizando sus propias soluciones. Tanto las <strong>STARKs</strong> como Starknet tambi√©n experimentar√°n optimizaciones para mejorar <strong>STARK</strong> y/o admitir diferentes tipos de pruebas. Un ejemplo de esto es como <a href="https://github.com/keep-starknet-strange">Keep-Starknet-Strange</a> el equipo detr√°s de <a href="https://github.com/keep-starknet-strange/garaga"><strong>Garaga</strong></a>, que est√° trabajando en diversas librer√≠as criptogr√°ficas como <a href="https://eprint.iacr.org/2019/953.pdf">Plonk</a>, <a href="https://eprint.iacr.org/2016/260.pdf">Groth16</a>, <strong>SNARK</strong>, entre otras.</p>
<p>Si desea obtener m√°s informaci√≥n sobre como los STARKs est√°n en diversas arquitectura y sus diversos casos de uso para asentar las bases dela criptograf√≠a moderna, recomendamos leer el articulo que sacamos para L2 Espa√±ol <a href="https://mirror.xyz/layer2es.eth/8TUEfpZPgl1u3-HyyGaUA0YMrFm8XSHfYtY6tfqFX7s">Profundizando en el Ecosistema STARKs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="propiedas-de-las-starks"><a class="header" href="#propiedas-de-las-starks">Propiedas de las STARKs</a></h2>
<p>En cap√≠tulos anteriores hemos visto c√≥mo diferenciar los tipos de pruebas seg√∫n su criptograf√≠a, as√≠ como la comparativa entre varias de ellas. Ahora veamos cu√°les son las dos propiedades esenciales en las pruebas y c√≥mo se pueden lograr, antes de pasar a la definici√≥n de STARK</p>
<ol>
<li><strong>Succintness:</strong> exigimos que nuestras pruebas y, en particular, el tiempo de verificaci√≥n sean sucintos, es decir, que sean √≥rdenes de magnitud m√°s peque√±os que el tiempo necesario para calcular nuestro programa. De lo contrario, no habr√≠a ninguna ventaja para el verificador en utilizar la prueba en lugar del c√°lculo original.</li>
<li><strong>Heur√≠stica Fiat-Shamir:</strong> este es un proceso mediante el cual podemos convertir una prueba interactiva en una no interactiva. Funciona proporcionando compromisos a los mensajes que formar√≠an la interacci√≥n y las funciones hash se utilizan como fuente de aleatoriedad.</li>
</ol>
<p>Uno de los protocolos que se utiliza en sistemas criptogr√°ficos, como los STARKs, para abordar el desaf√≠o de verificar eficientemente la correcci√≥n de grandes c√°lculos polinomiales es FRI (Fast Reed-Solomon Interactive Oracle Proofs of Proximity).</p>
<p>FRI utiliza c√≥digos de correcci√≥n de errores Reed-Solomon para permitir pruebas interactivas eficientes. Esto significa que el probador puede proporcionar una prueba corta de la correcci√≥n del c√°lculo, mientras que el verificador puede verificar de manera eficiente la validez de la prueba. Este proceso interactivo permite realizar pruebas de proximidad, donde el verificador puede verificar de manera eficiente si el c√°lculo reclamado se acerca al resultado correcto sin tener que evaluar por completo todo el polinomio.</p>
<blockquote>
<p>El conjunto de operaciones matem√°ticas, bases criptogr√°ficas, FRI y otras propiedades, como Fiat-Shamir, permite que las STARKs logren seguridad cu√°ntica y escalabilidad, al tiempo que proporcionan una verificaci√≥n transparente y eficiente de c√°lculos complejos.</p>
</blockquote>
<p>Podemos decir entonces que los STARKs demuestran la correcta operaci√≥n de una m√°quina virtual al demostrar que la traza de ejecuci√≥n asociada es v√°lida con respecto al AIR dado. En t√©rminos generales, las trazas de ejecuci√≥n se organizan como tablas de n√∫meros, y el protocolo STARK demuestra que estos n√∫meros resuelven conjuntamente un sistema de polinomios.</p>
<p>As√≠ vemos c√≥mo algunas de estas propiedades, como <code>Succintness</code>, pueden venir de forma natural en las STARKs, y c√≥mo el principio de Fiat-Shamir permite realizar pruebas interactivas. Adem√°s, contar con FRI como correcci√≥n de errores ampl√≠a las capacidades y visi√≥n de las STARKs, as√≠ que ahora vayamos a su definici√≥n</p>
<h2 id="s--scalable"><a class="header" href="#s--scalable">S = Scalable</a></h2>
<p>Una de las principales ventajas de STARKs es que al trasladar un c√°lculo fuera de la cadena, se reducen de manera exponencial los costos de verificaci√≥n en la cadena de bloques. El proceso de creaci√≥n de una prueba fuera de la cadena tiene un costo similar al de solicitar a un √∫nico nodo de la cadena de bloques que realice el c√°lculo.</p>
<p>La producci√≥n de pruebas no resulta considerablemente m√°s costosa que la ejecuci√≥n del c√°lculo original, y la validaci√≥n de las pruebas es <strong>exponencialmente m√°s r√°pida</strong> que la ejecuci√≥n del c√°lculo original. Adem√°s, las pruebas son <strong>considerablemente m√°s cortas</strong> en tama√±o que el c√°lculo original.</p>
<p>Otra ventaja importante es que a medida que se incrementa la cantidad de c√≥mputo, su crecimiento es casi lineal. Esto la convierte en una opci√≥n ideal para procesar transacciones a gran escala.</p>
<p><img src="./assets//Stark_2.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Adem√°s, se puede aprovechar la capacidad de paralelizaci√≥n de pruebas por el prover y recursividad de los STARKs eficentes para mejorar significativamente la escalabilidad.</p>
<p><img src="./assets//Stark_3.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<h2 id="t--transparent"><a class="header" href="#t--transparent">T = Transparent</a></h2>
<p>La seguridad de las STARKs no depende de ceremonias de configuraci√≥n elaboradas que puedan generar residuos t√≥xicos criptogr√°ficos, como ocurre en otras tecnolog√≠as de pruebas.</p>
<p>El uso de STARKs que tienen una base matem√°tica compleja y que utilizan pseudoaleatoriedad proporciona un inicio de ceremonia transparente y elimina la necesidad de una configuraci√≥n de confianza inicial (trusted setup), lo que mejora la seguridad y confiabilidad general del sistema criptogr√°fico.</p>
<p>Una caracter√≠stica importante de las STARKs es su construcci√≥n basada en el trabajo de <a href="https://es.wikipedia.org/wiki/Silvio_Micali">Micali</a>. En esta construcci√≥n, la √∫nica criptograf√≠a necesaria para producir o validar una prueba corta <code>ùõë</code> es una <strong>funci√≥n hash criptogr√°fica</strong> <code>H</code>, como <code>SHA-256</code> o <code>Keccak</code>. La elecci√≥n de <code>H</code> se convierte en el √∫nico <strong>&quot;par√°metro global&quot;</strong> que todos los usuarios del sistema de prueba deben conocer, y <strong>esta elecci√≥n puede hacerse de manera p√∫blica, garantizando la transparencia de las pruebas criptogr√°ficas obtenidas a trav√©s de las STARKs.</strong></p>
<p>Sin embargo siempre comparamos STARKs con SNARKs o pruebas derivadas de criptograf√≠a asim√©trica como las <a href="https://eprint.iacr.org/2013/279.pdf">Pinocchio</a> de ECC, pero cada una tiene sus varientes y esquemas diversos, aunque para una explicaci√≥n m√°s clara cogeremos el ejemplo de <a href="https://medium.com/@VitalikButerin/zk-snarks-under-the-hood-b33151a013f6">VB en un art√≠culo sobre zk-SNARKs</a>.</p>
<p><img src="./assets//Stark_4.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Imaginemos que tenemos un par de puntos <code>P</code> y <code>Q</code>, donde <code>P * k = Q</code>, y tienes un punto <code>C</code>, entonces no es posible obtener <code>C * k</code> a menos que <code>C</code> est√© <strong>&quot;derivado&quot;</strong> de alguna manera que conozcas a partir de <code>P</code>. Esto puede parecer intuitivamente obvio, pero esta suposici√≥n en realidad no puede derivarse de ninguna otra suposici√≥n (por ejemplo, la dificultad del logaritmo discreto) que usualmente utilizamos al probar la seguridad de los protocolos basados en EC. Por lo tanto, los SNARKs se basan en una base un tanto m√°s fr√°gil que la ECC en general.</p>
<p>Supongamos que cae del cielo un par de puntos <code>(P, Q)</code>, donde <code>P * k = Q</code>, pero nadie conoce el valor de <code>k</code>. Ahora, supongamos que yo presento un par de puntos <code>(R, S)</code> donde <code>R * k = S</code>. Entonces, la suposici√≥n de conocimiento del extremo de la curva (KoE, por sus siglas en ingl√©s) implica que la √∫nica forma en que podr√≠a haber creado ese par de puntos es tomando <code>P</code> y <code>Q</code>, y multiplic√°ndolos por un factor <code>r</code> que <strong>solo yo conozco</strong>. Tambi√©n hay que tener en cuenta que, gracias a la magia de las parejas de curvas el√≠pticas, verificar que <code>R = k * S</code> no requiere conocer <code>k</code>; en su lugar, simplemente puedes comprobar si <code>e(R, Q) = e(P, S)</code>, donde e es una funci√≥n de emparejamiento de curvas el√≠pticas.</p>
<p>Hagamos algo m√°s interesante. Supongamos que caen del cielo diez pares de puntos: <code>(P_1, Q_1), (P_2, Q_2) ... (P_10, Q_10)</code>. En todos los casos, se cumple que <code>P_i * k = Q_i</code>, ahora, supongamos que te proporciono un par de puntos <code>(R, S)</code> donde <code>R * k = S</code>.</p>
<p><strong>¬øQu√© sabemos ahora?</strong> Que <code>R</code> es una combinaci√≥n lineal de la forma <code>P_1 * i_1 + P_2 * i_2 + ... + P_10 * i_10</code>, donde yo conozco los coeficientes <code>i_1, i_2 ... i_10</code>, es decir, la √∫nica forma de obtener un par de puntos <code>(R, S)</code> de esta manera es tomando algunos m√∫ltiplos de <code>P_1, P_2 ... P_10</code> y sum√°ndolos, y hacer el mismo c√°lculo con <code>Q_1, Q_2 ... Q_10.</code></p>
<p>Enrtonces tenemos que tener en cuenta que dado cualquier conjunto espec√≠fico de puntos <code>P_1‚Ä¶P_10</code> para los que puedas querer verificar combinaciones lineales, en realidad no puedes crear los puntos correspondientes <code>Q_1‚Ä¶Q_10</code> sin conocer el valor de <code>k</code>, y si conoces el valor de <code>k</code>, entonces puedes crear un par <code>(R, S)</code> donde <code>R * k = S</code> para cualquier <code>R</code> que desees, sin necesidad de crear una combinaci√≥n lineal.</p>
<p><strong>Por lo tanto, para que esto funcione, es absolutamente imperativo que quien cree esos puntos sea confiable y realmente elimine <code>k</code> una vez que haya creado los diez puntos.</strong></p>
<p>Se debe destacar la importancia de las ceremonias de ajuste inicial en ciertos casos, como en implementaciones de sistemas de votaci√≥n. En estos casos, es crucial tener en cuenta qui√©n ha sido el creador de los puntos y si existe alguna posibilidad de manipulaci√≥n o si se ha eliminado correctamente el valor de k. Esto es necesario para lograr transparencia y evitar depender de estas verificaciones. En este sentido, los STARKs se presentan como una soluci√≥n prometedora y <strong>EFICIENTE</strong>, ya que proporcionan una base s√≥lida que elimina la necesidad de confiar en dichas ceremonias de ajuste inicial.</p>
<h2 id="ark--argument-of-knowledge"><a class="header" href="#ark--argument-of-knowledge">ARK = Argument of Knowledge</a></h2>
<p>Los argumentos de conocimiento ‚ÄúARK‚Äù son llevados a cabo por el prover que opera fuera de la cadena principal. Este probador se encarga de ejecutar el c√°lculo requerido para la prueba, utilizando las entradas auxiliares necesarias, la realizaci√≥n de la prueba fuera de la cadena principal es clave, ya que debe garantizar la integridad y la confiabilidad del proceso.</p>
<p>La principal ventaja de esta metodolog√≠a es que permite una verificaci√≥n aut√©ntica y matem√°ticamente s√≥lida. Despu√©s de que el probador haya realizado el c√°lculo, puede proporcionar la prueba generada a cualquier computadora o entidad interesada para su verificaci√≥n, haciendo uso de ARK sto significa que cualquier sistema inform√°tico puede confirmar la validez de la prueba de manera independiente.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="starks-eficientes"><a class="header" href="#starks-eficientes">STARKS eficientes</a></h2>
<p>En este cap√≠tulo, lleg√≥ el momento de comprender c√≥mo los STARKs representan una versi√≥n m√°s eficiente de los <a href="https://en.wikipedia.org/wiki/Probabilistically_checkable_proof"><strong>(PCP)</strong></a>, un protocolo que permite establecer la exactitud de las declaraciones de <strong>CI</strong>, mediante una verificaci√≥n aleatoria local en una prueba larga. Este protocolo se lleva a cabo entre un prover <strong>PCP</strong> y un verificador <strong>PCP</strong>.</p>
<p>En esta versi√≥n, se han realizado ajustes para mejorar la cohesi√≥n y la fluidez del texto. Se ha utilizado un lenguaje m√°s claro y directo para explicar la relaci√≥n entre los STARKs y los PCP, as√≠ como su funci√≥n en la verificaci√≥n de declaraciones de informaci√≥n computacional.</p>
<p>El prover <strong>PCP</strong> produce una cadena de prueba <code>ùöø</code> que codifica el seguimiento de c√°lculo de la declaraci√≥n de <code>CI</code>, a pesar de que <code>ùöø</code> es m√°s larga que la traza de c√°lculo de pasos <code>T</code>. Sin embargo, la cadena de prueba <code>ùöø</code> tiene la propiedad especial de que puede ser validada a trav√©s de una prueba probabil√≠stica que lee solo una peque√±a parte de <code>ùöø</code>.</p>
<p>El verifier <strong>PCP</strong>, al recibir la misma declaraci√≥n de <strong>CI</strong> <code>(A, x, y, T)</code>, puede validar la cadena de prueba <code>ùöø</code> leyendo aleatoriamente unas pocas ubicaciones de <code>ùöø</code> y luego realizar una <strong>&quot;verificaci√≥n local&quot;</strong> econ√≥mica en los valores le√≠dos. El n√∫mero de ubicaciones de lectura puede ser una peque√±a constante, como 3, independientemente de la longitud de la traza de c√°lculo <code>T</code>.</p>
<p>Si la declaraci√≥n de CI es verdadera, el verifier siempre aceptar√°. Sin embargo, si la declaraci√≥n de CI es falsa, el verificador la rechazar√° con alta probabilidad, sin importar c√≥mo se haya elegido la cadena de prueba <code>ùöø</code>.</p>
<p><img src="./assets/Stark_Sudoku.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>En la imagen animada podemos ver un ejemplo de <strong>PCP</strong> con un conjunto de resticciones un sudoku y ahora veremos como los STARKs eficiente pueden mejorar la eficiencia de las <strong>PCP</strong> y <strong>MPCP</strong> con <strong>IOPs</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iops---interactive-oracle-proof"><a class="header" href="#iops---interactive-oracle-proof">IOPs - Interactive Oracle Proof</a></h1>
<p>Las Interactive Oracle Proof <a href="https://eprint.iacr.org/2016/116"><strong>(IOP)</strong></a> son un nuevo tipo de sistema de prueba que combina las propiedades clave de <strong>pruebas interactivas</strong> y <strong>PCP</strong>, las <strong>IOP</strong> permiten que un verifier est√© convencido de la exactitud de una declaraci√≥n al interactuar con un prover no confiable mientras lee solo algunos bits de los mensajes enviados por el prover. Las <strong>IOP</strong> se han vuelto muy prominentes en el dise√±o de sistemas de prueba eficientes en los √∫ltimos a√±os.</p>
<blockquote>
<p><strong>Las construcciones STARK eficientes se obtienen combinando IOP eficientes y funciones hash criptogr√°ficas. La IOP le confiere al STARK su escalabilidad, mientras que la funci√≥n hash le confiere al STARK su transparencia.</strong></p>
</blockquote>
<p>Las STARKs eficientes se basan en IOP, de manera informal, un prover y un verifier participan en un protocolo interactivo en el que, en cada ronda, el verifier env√≠a algo de aleatoriedad <code>ùõî·µ¢</code> al prover, y el prover responde con una proof larga <code>ùöø·µ¢</code>. Al final de la interacci√≥n, el verificador realiza una verificaci√≥n local aleatoria de todas las proof largas <code>(ùöø‚ÇÅ,ùöø‚ÇÇ,‚Ä¶)</code> enviadas por el prover a lo largo de la interacci√≥n.</p>
<p>Ahora, antes de sumergirnos en el mundo de los pasos de creaci√≥n de un STARKs y su eficiencia, es importante comprender qu√© es un polinomio, ya que desempe√±an un papel crucial en la construcci√≥n y verificaci√≥n de STARKs. Son utilizados para representar y manipular datos de manera eficiente, lo que permite lograr un alto nivel de compresi√≥n y optimizaci√≥n en el proceso de verificaci√≥n.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="polinomios"><a class="header" href="#polinomios">Polinomios</a></h2>
<p>Los polinomios son una poderosa herramienta algebraica que se utiliza en diversas ramas de las matem√°ticas y la f√≠sica. Estas expresiones algebraicas est√°n formadas por t√©rminos que contienen variables y coeficientes. Los t√©rminos son la suma o resta de monomios, que son productos de constantes y variables elevadas a exponentes enteros no negativos.</p>
<p>Un polinomio puede tener una o varias variables, y su grado est√° determinado por el exponente m√°s alto presente en los t√©rminos del polinomio. Por ejemplo, el polinomio <code>3x¬≤ - 2x + 1</code>  es un polinomio de grado 2, ya que el t√©rmino de mayor grado tiene un exponente de 2.</p>
<p>Los polinomios se pueden sumar, restar, multiplicar y dividir, y se emplean en ecuaciones algebraicas, c√°lculo, geometr√≠a y muchas otras ramas de las ciencias exactas.</p>
<p><strong>¬øPor qu√© no eval√∫a el verifier los propios polinomios?</strong></p>
<ul>
<li>Porque, en realidad, el prover no env√≠a todos los polinomios al verificador, si lo hiciera perder√≠amos la succintness, contienen m√°s informaci√≥n que nuestra declaraci√≥n original, por lo que el prover s√≥lo proporciona un compromiso con los polinomios.</li>
</ul>
<p><strong>¬øQu√© propiedades de los polinomios son importantes en este caso?</strong></p>
<ul>
<li>Los polinomios son buenos c√≥digos de correcci√≥n de errores.</li>
</ul>
<p>Si tenemos polinomios de grado <code>d</code> sobre un dominio de codificaci√≥n <code>D</code>, y dos mensajes <code>m‚ÇÅ</code> y <code>m‚ÇÇ</code>, entonces  <code>m‚ÇÅ</code> y <code>m‚ÇÇ</code> diferir√°n en <code>|D|-d</code> puntos. Esto es importante porque queremos que la diferencia entre una declaraci√≥n correcta y una incorrecta sea grande, de modo que sea f√°cil de encontrar.</p>
<p>Esto conduce a un buen muestreo, lo que ayuda a la sucintez, s√≥lo necesitamos muestrear unos pocos valores para estar seguros de que la probabilidad de error es lo suficientemente baja como para ser insignificante.</p>
<ul>
<li>Disponer de pruebas eficaces de lote cero mantiene la sucintez.</li>
</ul>
<p>Tener la capacidad de realizar pruebas de lote cero eficaces es fundamental. Esto nos permite demostrar de manera conjunta que un conjunto de elementos cumple con una determinada propiedad, en lugar de tener que probar cada elemento de forma individual, esta t√©cnica de prueba en lote nos permite lograr una mayor concisi√≥n y eficiencia en la verificaci√≥n.</p>
<p>Imaginemos que queremos demostrar que un polinomio de grado grande <code>P(x) (grado ~ 10 millones)</code> eval√∫a a <code>0</code> en los puntos <code>1...1 mill√≥n</code>, pero queremos hacerlo con una sola consulta.</p>
<p>Imaginemos que nuestra afirmaci√≥n es que <code>P</code> desaparece en estos puntos. Si el verifier s√≥lo utiliza el muestreo, el prover podr√≠a hacer trampas f√°cilmente proporcionando un punto que se eval√∫e como <code>0</code>, pero los otros <code>999.999</code> podr√≠an ser distintos de <code>0</code>.</p>
<h2 id="resolviendo-el-problema"><a class="header" href="#resolviendo-el-problema">Resolviendo el problema</a></h2>
<p>Consideremos un conjunto <code>S = 1...10‚Å∂</code></p>
<p>Definir <code>V</code> como el polinomio que se anula en estos puntos, es decir: <code>(x - 1)(x - 2)(x - 3)...</code> el grado de <code>V = tama√±o de S</code> y esto es beneficioso porque:</p>
<ol>
<li><code>P(x) = P'(x) ‚Ä¢ V(x)</code></li>
<li><code>Grado de P = Grado de P' - Tama√±o de S.</code></li>
</ol>
<p>La introducci√≥n de <code>V(x)</code> nos permite verificar en todo el dominio.</p>
<ul>
<li>Estos polinomios tienen una propiedad <strong>&quot;multiplicadora&quot;</strong>. Podemos <strong>&quot;envolver&quot;</strong> una restricci√≥n alrededor de un polinomio.</li>
</ul>
<p>Por ejemplo, si tenemos la restricci√≥n <strong>C</strong>, que indica que nuestra evaluaci√≥n siempre ser√° 0 o 1, podr√≠amos expresarla como <code>C(x) = x ‚Ä¢ (x - 1)</code>. Esto se podr√≠a interpretar como restringir una salida para que sea un booleano, lo cual es √∫til en t√©rminos de integridad computacional.</p>
<p>En lugar de tener <code>x</code> como un simple punto, podr√≠amos considerar la evaluaci√≥n de un  de un polinomio <code>P‚ÇÅ(x)</code> en un punto espec√≠fico, es decir, <code>C(P‚ÇÅ(x)) = P‚ÇÅ(x)‚Ä¢(P‚ÇÅ(x)-1)</code></p>
<p>Los grados de los polinomios resultantes de la multiplicaci√≥n son aditivos, por lo que el grado de <code>C(x) = 2 ‚Ä¢ grado de P‚ÇÅ(x)</code></p>
<p>Podemos afirmar que si <code>P‚ÇÅ(x)</code> cumple con esta restricci√≥n para nuestro conjunto <code>S</code>, entonces, como mencionamos anteriormente, existe un polinomio <code>P'(x)</code> tal que:</p>
<ul>
<li><code>C(P‚ÇÅ(x)) = P'(x) ‚Ä¢ V(x)</code></li>
</ul>
<p>Si <code>P‚ÇÅ(x)</code> no cumpliera con la restricci√≥n (por ejemplo, si para un valor de <code>x, P‚ÇÅ(x) = 93</code>), entonces no podr√≠amos encontrar esos polinomios, la igualdad no se cumplir√≠a y habr√≠a un residuo en la ecuaci√≥n anterior.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creando-un-stark"><a class="header" href="#creando-un-stark">Creando un STARK</a></h1>
<p>En los pr√≥ximos cap√≠tulos del Libro de L2 sobre StarkWare, despu√©s de haber explicado algunas propiedades importantes de los polinomios y su relevancia, exploraremos la creaci√≥n de un STARK desde sus fundamentos matem√°ticos m√°s profundos. Para obtener una comprensi√≥n completa de los procesos involucrados y c√≥mo se puede combinar un <code>PCP</code> con criptograf√≠a ligera para obtener un STARK, te recomendamos revisar la serie lanzada por Starkware, la cual ofrece una profundizaci√≥n m√°s detallada desde el inicio.</p>
<p>A continuaci√≥n os dejaremos los enlaces a cinco art√≠culos fundamentales traducidos al espa√±ol que complementar√°n tu aprendizaje:</p>
<ol>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Comienza%20el%20viaje.md">Comienza el Viaje</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Aritmetizaci%C3%B3n%20I.md">Aritmetizaci√≥n I</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Aritmetizaci%C3%B3n%20II.md">Aritmetizaci√≥n II</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Prueba%20de%20bajo%20grado.md">Pruebas de Bajo Grado</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Un%20marco%20para%20STARKs%20eficientes.md">Un Frameword para STARKs Eficientes</a></li>
</ol>
<p>Estos recursos adicionales te brindar√°n una visi√≥n m√°s completa y pr√°ctica del proceso de creaci√≥n de una STARK. Tambi√©n te recomendamos revisar los repositorios relacionados y los videos de creaci√≥n de una STARK en Pioneros Clases 3, un Basecamp descentralizado en Espa√±ol creado por Starknet, o el de ingl√©s impartido por Eli Ben-Sasson</p>
<p>Nos interesa la Integridad Computacional (CI), por ejemplo, saber que el programa de Cairo que escribiste se calcul√≥ correctamente.</p>
<ul>
<li>Tenemos que pasar por una serie de transformaciones desde el trazado de nuestro programa, hasta la prueba.</li>
<li>La primera parte de esto se llama aritmetizaci√≥n, y consiste en tomar nuestra traza y convertirla en un conjunto de polinomios.</li>
<li>Nuestro problema se convierte entonces en uno en el que el prover intenta convencer a un verificador de que el polinomio es de grado bajo.</li>
<li>El verificador est√° convencido de que el polinomio es de grado bajo si y s√≥lo si el c√°lculo original es correcto (salvo una probabilidad infinitesimalmente peque√±a).</li>
</ul>
<p><img src="./assets/Stark_5.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>El uso de la aletoriedad es muy importante para el prover y el verifier, mientras que el prover utiliza la aleatoriedad para alcanzar el conocimiento cero, el verificador utiliza la aleatoriedad al generar consultas al prover, para detectar trampas por parte del prover.</p>
<p>Gran parte del trabajo que se realiza al crear una prueba consiste en garantizar que sea sucinta y que pueda elaborarse y verificarse en un tiempo razonable. Por tanto, nuestro plan consistir√° en:</p>
<ul>
<li>Reformular la traza de ejecuci√≥n como un polinomio,</li>
<li>Extenderlo a un gran dominio,</li>
<li>Transformarlo, utilizando las restricciones polin√≥micas, en otro polinomio que se garantiza que es de grado bajo si y s√≥lo si la traza de ejecuci√≥n es v√°lida.</li>
<li>Queremos lograr una verificaci√≥n sucinta, en la que el verificador de la declaraci√≥n CI requiera exponencialmente menos recursos que los necesarios para la repetici√≥n ingenua.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aritmetizaci√≥n"><a class="header" href="#aritmetizaci√≥n">Aritmetizaci√≥n</a></h1>
<p>Tenemos dos pasos principales en este proceso:</p>
<ol>
<li>Generaci√≥n de una traza de ejecuci√≥n y restricciones polin√≥micas.</li>
<li>Transformar estos dos objetos en un √∫nico polinomio de bajo grado.</li>
</ol>
<p>En t√©rminos de interacci√≥n prover-verifier, realmente lo que ocurre es que entre ambos acuerdan de antemano cu√°les son las restricciones polin√≥micas.</p>
<p>A continuaci√≥n, el prover genera una traza de ejecuci√≥n y, en la interacci√≥n posterior, intenta convencer al verificador de que las restricciones polin√≥micas se cumplen en esta traza de ejecuci√≥n, sin que el verificador lo vea.</p>
<p>La traza de ejecuci√≥n es una tabla que representa los pasos del c√°lculo subyacente, donde cada fila representa un √∫nico paso y el tipo de traza de ejecuci√≥n que buscamos generar debe tener la caracter√≠stica especial de ser sucintamente comprobable:</p>
<ul>
<li>Cada fila puede ser verificada bas√°ndose s√≥lo en las filas que est√°n cerca de ella en la traza, y el mismo procedimiento de verificaci√≥n se aplica a cada par de filas.</li>
</ul>
<p>Por ejemplo, imaginemos que nuestra traza representa un total en ejecuci√≥n, con cada paso de la siguiente manera.</p>
<pre><code class="language-bash">                    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
                    ‚ïë  PASO  ‚ïë  IMPORTE  ‚ïë TOTAL ‚ïë
                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
                    ‚ïë   0    ‚ïë     0     ‚ïë   0   ‚ïë
                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
                    ‚ïë   1    ‚ïë     5     ‚ïë   5   ‚ïë
                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
                    ‚ïë   2    ‚ïë     2     ‚ïë   7   ‚ïë
                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
                    ‚ïë   3    ‚ïë     2     ‚ïë   9   ‚ïë
                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
                    ‚ïë   4    ‚ïë     3     ‚ïë   12  ‚ïë
                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
                    ‚ïë   5    ‚ïë     6     ‚ïë   18  ‚ïë
                    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
</code></pre>
<p>Si representamos la fila como <code>i</code> , y la columna como <code>j</code> , y los valores como <code>A·µ¢,‚±º</code> , podr√≠amos escribir algunas restricciones sobre esto de la siguiente manera:</p>
<ul>
<li><code>A‚ÇÄ,‚ÇÇ=0</code></li>
<li><code>‚àÄ1 &gt;= i &lt;= 5 : A·µ¢,‚ÇÇ ‚àí A·µ¢,‚ÇÅ ‚àí A·µ¢-‚ÇÅ,‚ÇÇ = 0</code></li>
<li><code>A‚ÇÖ,‚ÇÇ = 18</code></li>
</ul>
<p>Se trata de restricciones polin√≥micas lineales en <code>A·µ¢,‚±º</code></p>
<p>N√≥tese que aqu√≠ estamos consiguiendo cierta concisi√≥n porque podr√≠amos representar un n√∫mero mucho mayor de filas con s√≥lo estas 3 restricciones.</p>
<p>El sistema de restricciones aritm√©ticas define al menos dos tipos de restricciones sobre la traza de ejecuci√≥n algebraica:</p>
<ol>
<li><strong>Restricciones de contorno:</strong> al principio o al final del c√°lculo, un registro indicado tiene un valor determinado.</li>
<li><strong>Restricciones de transici√≥n:</strong> dos tuplas de estado consecutivas cualesquiera evolucionan de acuerdo con la funci√≥n de transici√≥n de estado. En conjunto, estas restricciones se conocen como representaci√≥n algebraica intermedia o AIR.</li>
</ol>
<p>Las STARKs avanzadas pueden definir m√°s tipos de restricciones para tratar con la memoria o con la consistencia de los registros dentro de un ciclo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polinomio-para-nuestra-traza"><a class="header" href="#polinomio-para-nuestra-traza">Polinomio para nuestra traza</a></h1>
<p>Siguiendo el cap√≠tulo anterior, en esta ocasi√≥n continuaremos definiendo un polinomio <code>f(x)</code> en el que los elementos de la traza de ejecuci√≥n se obtienen a trav√©s de  evaluaciones de <code>f</code> en potencias de alg√∫n generador <code>g</code>.</p>
<p>Recordemos que nuestro campo finito tiene generadores, los cuales utilizaremos para indexar los pasos de la traza. Para ello, consideraremos una secuencia de Fibonacci que nos permitir√° establecer restricciones espec√≠ficas, como la siguiente:</p>
<ul>
<li><code>‚àÄ x ‚àà {1,g¬≤,g¬≥...g‚Åµ‚Å∞‚Åπ}: f(g¬≤x) ‚Çã f(gx) ‚Çã f(x) = 0</code></li>
</ul>
<p>Esto restringe los valores entre las filas subsiguientes. Tambi√©n significa que los valores g son ra√≠ces de este polinomio.</p>
<p>Por lo tanto, podemos utilizar el enfoque que vimos anteriormente para proporcionar el polinomio de fuga utilizando el t√©rmino <code>(x - g‚Å±)</code> y a partir de √©l creamos la Composici√≥n Polinomial.</p>
<p>El hecho b√°sico sobre polinomios y sus ra√≠ces es que si <code>p(x)</code> es un polinomio, entonces <code>p(a)=0</code> para alg√∫n valor espec√≠fico a, si y s√≥lo si existe un polinomio <code>q(x)</code> tal que <code>(x-a)q(x)=p(x)</code>, y <code>deg(p)=deg(q)+1.</code></p>
<p>Esta expresi√≥n coincide con el polinomio de grado 2 como m√°ximo si nuestra traza de ejecuci√≥n ha sido correcta, es decir, ha obedecido a la restricci√≥n de paso que hemos definido.</p>
<p>Si la traza difiere de eso, entonces es poco probable que esta expresi√≥n produzca un polinomio de bajo grado.</p>
<h1 id="composici√≥n-polinomial"><a class="header" href="#composici√≥n-polinomial">Composici√≥n Polinomial</a></h1>
<p>El Polinomio de Composici√≥n en su traducci√≥n tambi√©n conocido como Composici√≥n Polinomial (CP), se realiza para demostrar eficazmente la validez del rastro de ejecuci√≥n, nos esforzamos por alcanzar los dos objetivos siguientes:</p>
<ol>
<li>Componer las restricciones sobre los polinomios de la traza para hacerlas cumplir en la traza.</li>
<li>Combinar las restricciones en un √∫nico polinomio (m√°s grande), denominado Composici√≥n Polinomial, de modo que se pueda utilizar una √∫nica prueba de grado bajo para atestiguar su grado bajo.</li>
</ol>
<h1 id="ampliando-el-polinomio"><a class="header" href="#ampliando-el-polinomio">Ampliando el polinomio</a></h1>
<p>Como hemos visto antes, los polinomios pueden utilizarse para construir buenos c√≥digos de correcci√≥n de errores, ya que dos polinomios de grado d, evaluados en un dominio considerablemente mayor que d, son diferentes en casi todas partes.</p>
<p>Observando esto, podemos extender la traza de ejecuci√≥n pensando en ella como una evaluaci√≥n de un polinomio en alg√∫n dominio, y evaluando este mismo polinomio en un dominio mucho mayor. Extendiendo de manera similar una traza de ejecuci√≥n incorrecta, se obtiene una cadena muy diferente, lo que a su vez hace posible que el verificador distinga entre estos casos utilizando un peque√±o n√∫mero de consultas.</p>
<h2 id="de-restricciones-polin√≥micas-al-problema-de-las-pruebas-de-bajo-grado"><a class="header" href="#de-restricciones-polin√≥micas-al-problema-de-las-pruebas-de-bajo-grado">De restricciones polin√≥micas al problema de las pruebas de bajo grado</a></h2>
<p>En general, si nuestro c√°lculo implica <code>N</code> pasos, la traza de ejecuci√≥n estar√° representada por polinomios de grado inferior a <code>N</code></p>
<ul>
<li><code>f(X) = c‚ÇÄ + c‚ÇÅX + c‚ÇÇX¬≤ +‚ãØ+ c…¥-‚ÇÅX·¥∫‚Åª¬π</code></li>
</ul>
<p>Los coeficientes <code>c·µ¢</code> est√°n en el campo <code>ùîΩ</code> y el l√≠mite <code>N</code> en el grado es t√≠picamente grande, quiz√° del orden de unos pocos millones. A pesar de ello, estos polinomios se denominan de bajo grado.</p>
<p>Esto se debe a que el punto de comparaci√≥n es el tama√±o del campo. Por interpolaci√≥n, toda funci√≥n sobre <code>ùîΩ</code> puede representarse mediante un polinomio.</p>
<p>La mayor√≠a de ellos tendr√°n un grado igual al tama√±o total del campo, por lo que, comparado con √©ste, <code>N</code> es realmente bajo.</p>
<p>Este tipo de funciones, coherentes con un polinomio de bajo grado, tambi√©n se conocen como c√≥digos <code>Reed-Solomon</code>.</p>
<p>Tras la generaci√≥n de la traza, el prover se compromete con ella. Recordemos que no queremos enviar los polinomios al verificador como un todo, pero necesitamos que el prover se comprometa con ellos.</p>
<p>En todo el sistema, los compromisos se ejecutan construyendo √°rboles de Merkle sobre las series de elementos de campo y enviando las ra√≠ces de Merkle al verificador.</p>
<p>Queremos que un verificador plantee al prover un n√∫mero muy reducido de preguntas y decida si acepta o rechaza la prueba con un alto nivel de precisi√≥n garantizado. Idealmente, al verificador le gustar√≠a pedir al prover que proporcione los valores en unos pocos lugares (aleatorios) en la traza de ejecuci√≥n, y comprobar que las restricciones polin√≥micas se mantienen para estos lugares.</p>
<p>Una traza de ejecuci√≥n correcta pasar√° naturalmente esta prueba.</p>
<p>Sin embargo, no es dif√≠cil construir una traza de ejecuci√≥n completamente err√≥nea (especialmente si sab√≠amos de antemano qu√© puntos se comprobar√≠an), que viole las restricciones s√≥lo en un punto de la traza √∫nico y, al hacerlo, llegar a un resultado completamente alejado y diferente. Identificar este fallo mediante un peque√±o n√∫mero de consultas aleatorias es altamente improbable.</p>
<p>Pero recuerda que los polinomios tienen algunas propiedades √∫tiles aqu√≠:</p>
<ul>
<li>Dos polinomios (diferentes) de grado <code>d</code> evaluados en un dominio considerablemente mayor que <code>d</code> son diferentes en casi todas partes.</li>
</ul>
<p>As√≠ que si tenemos un prover deshonesto, que crea un polinomio de bajo grado representando su traza (que es incorrecta en alg√∫n punto) y lo eval√∫a en un dominio grande, ser√° f√°cil ver que este es diferente al polinomio correcto.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pruebas-de-bajo-grado"><a class="header" href="#pruebas-de-bajo-grado">Pruebas de Bajo Grado</a></h1>
<p>Las pruebas de bajo grado son realmente el coraz√≥n del proceso de verificaci√≥n.</p>
<p>El supuesto de comprobaci√≥n de bajo grado establece la existencia de un verificador probabil√≠stico que comprueba si una funci√≥n f es de grado como m√°ximo d ‚â™ |ùîΩ|. El verificador debe distinguir entre los dos casos siguientes:</p>
<ol>
<li><strong>La funci√≥n <code>f</code> es igual a un polinomio de bajo grado:</strong> es decir, existe un polinomio <code>p(x)</code> sobre <code>ùîΩ</code>, de grado menor que <code>d</code>, que coincide con <code>f</code> en todas partes.</li>
<li><strong>La funci√≥n <code>f</code> est√° lejos de TODOS los polinomios de bajo grado:</strong> por ejemplo, necesitamos modificar al menos el <strong>10%</strong> de los valores de <code>f</code> antes de obtener una funci√≥n que concuerde con un polinomio de grado inferior a <code>d</code>.</li>
</ol>
<p>La aritmetizaci√≥n muestra que un prover honesto que trate con una afirmaci√≥n verdadera caer√° en el primer caso, mientras que un prover (posiblemente malicioso) que intente <strong>&quot;probar&quot;</strong> una afirmaci√≥n falsa caer√°, con alta probabilidad, en el segundo caso.</p>
<p>Otra forma de ver esto es que el polinomio de traza correcto combinado con las restricciones ser√° necesariamente de grado bajo, el grado proviene del n√∫mero de pasos en nuestra traza (probablemente unos pocos millones), y la combinaci√≥n de esto con los polinomios de restricci√≥n (probablemente &lt; 10).</p>
<p>En general, cabr√≠a esperar que los polinomios <strong>&quot;correctos&quot;</strong> tuvieran un grado de alrededor de <code>10‚Å∑</code> , mientras que un prover tramposo que eligiera puntos al azar del campo <code>ùîΩ</code> obtendr√≠a, tras la interpolaci√≥n, polinomios de grado comparable al tama√±o del campo, es decir, del orden de <code>2¬≤‚Åµ‚Å∂</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fri"><a class="header" href="#fri">FRI</a></h1>
<p>FRI son las siglas de <a href="https://eccc.weizmann.ac.il/report/2017/134/">Fast Reed-Solomon IOP of Proximity</a>, es un protocolo que establece que un polinomio comprometido tiene un grado limitado.</p>
<p>El <a href="https://book.starknet.io/chapter_10/fri.html"><strong>FRI</strong></a> es complejo y gran parte del procesamiento que lo compone est√° dise√±ado para que las pruebas sean factibles y sucintas. Tambi√©n hay mucho procesamiento involucrado con la protecci√≥n contra diversos tipos de ataques que podr√≠an ser realizados por el prover, y garantizar que todo se lleva a cabo en el conocimiento cero.</p>
<p>Su objetivo es encontrar si un conjunto de puntos se encuentran mayoritariamente en un polinomio de bajo grado y puede alcanzar una complejidad de prueba lineal y una complejidad de verificaci√≥n logar√≠tmica.</p>
<p>En general, hay 2 etapas : commit y query, contenidas en los siguientes pasos repetidos.</p>
<ol>
<li>El verifier env√≠a un n√∫mero aleatorio al prover.</li>
<li>El prover genera un nuevo polinomio.</li>
<li>El verifier genera los conjuntos puntuales de consultas y los env√≠a al prover.</li>
<li>El prover eval√∫a los valores polin√≥micos correspondientes.</li>
<li>El verifier realiza una comprobaci√≥n de validez.</li>
</ol>
<p>Aprendamos como FRI es un protocolo entre un probador y un verificador, que establece que una codeword dada pertenece a un polinomio de grado bajo.</p>
<p>El prover conoce expl√≠citamente este codeword, mientras que el verificador s√≥lo conoce su ra√≠z Merkle y las hojas de su elecci√≥n, suponiendo la validaci√≥n satisfactoria de las rutas de autenticaci√≥n que establecen la pertenencia de las hojas al Merkle Tree.</p>
<p>Una de las grandes ideas para los sistemas de pruebas de los √∫ltimos a√±os ha sido la t√©cnica de dividir y doblar. La idea es reducir una afirmaci√≥n a dos afirmaciones de la mitad de tama√±o. A continuaci√≥n, ambas afirmaciones se fusionan en una sola utilizando pesos aleatorios proporcionados por el verificador.</p>
<p>Despu√©s de muchos pasos, la afirmaci√≥n se ha reducido a una de tama√±o trivial que es verdadera si y s√≥lo si (modulo alguna degradaci√≥n de seguridad insignificante) la afirmaci√≥n original era verdadera.</p>
<p>El Verifier inspecciona los Merkle Tree (en concreto: pide al prover que proporcione las hojas indicadas con sus rutas de autenticaci√≥n) de rondas consecutivas para comprobar una relaci√≥n lineal simple.</p>
<p>Para los provers honestos, el grado de los polinomios representados tambi√©n se reduce a la mitad en cada ronda y, por tanto, es mucho menor que la longitud de la codeword. Sin embargo, para los provers maliciosos, este grado es uno menos que la longitud de la codeword. En el √∫ltimo paso, el prover env√≠a una codeword no trivial correspondiente a un polinomio constante.</p>
<p>Despu√©s de explorar los diferentes pasos en la creaci√≥n detr√°s de un STARKs y la importancia de las pruebas de integridad, es evidente que estas pruebas son fundamentales para garantizar la seguridad y confiabilidad de los sistemas del Futuro.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leve-introducci√≥n-cairo"><a class="header" href="#leve-introducci√≥n-cairo">Leve introducci√≥n Cairo</a></h1>
<p>Para concluir esta primera parte del L2 Book sobre Starkware, antes de adentrarnos en los pr√≥ximos temas sobre la arquitectura de Starknet y Cairo, haremos una breve introducci√≥n a Cairo y su relaci√≥n con la CVM (M√°quina Virtual de Cairo). En este contexto, es relevante comprender c√≥mo todos los pasos de un c√°lculo pueden ser representados mediante polinomios, utilizando lo que se conoce como la Representaci√≥n Algebraica Intermedia (AIR).</p>
<p>Los bloques de c√°lculo pueden ser representados como AIR y tienen la capacidad de combinarse entre s√≠, lo que se convierte en la base de Cairo. Para ilustrarlo mediante una analog√≠a con el hardware:</p>
<ul>
<li><strong>ASIC (AIR)</strong></li>
<li><strong>CPU (varias AIR)</strong></li>
</ul>
<p>El nombre <strong>Cairo</strong> deriva de una CPU construida a partir de AIRs:</p>
<ul>
<li><strong>(CPU-AIR, Oh genial -&gt; CAIRO)</strong></li>
</ul>
<p>Cairo es un lenguaje funcional de alto nivel, no determinista y Turing completo, que cuenta con un modelo de memoria basado en registros y un compilador que produce una tabla de pasos computacionales llamada traza.</p>
<blockquote>
<p>En los programas escritos en Cairo, se especifican los resultados que se consideran aceptables, no c√≥mo obtenerlos.</p>
</blockquote>
<p>En los cap√≠tulos anteriores, hemos visto c√≥mo, en el proceso de construcci√≥n de pruebas STARK, el prover utiliza esta traza para crear Representaciones Algebraicas Intermedias (AIRs). Posteriormente, estas AIRs se combinan y convierten en pruebas STARK.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusi√≥n"><a class="header" href="#conclusi√≥n">Conclusi√≥n</a></h1>
<p>Con esto, concluimos nuestro profundo viaje por el mundo de la criptograf√≠a, explorando la generaci√≥n de claves privadas y p√∫blicas, as√≠ como sus diversas implementaciones. Hemos aprendido c√≥mo Starknet y los esquemas de firmas pueden prevenir ataques criptoanal√≠ticos, y hemos visto c√≥mo las STARKs han sido dise√±adas desde su inicio para brindar seguridad matem√°tica frente a ataques cu√°nticos, siguiendo sus principios fundamentales.</p>
<p>Starknet est√° sentando las bases de la criptograf√≠a moderna y creando un ecosistema escalable, √≠ntegro y seguro por una de las mayores descentralizada como Ethereum, escalemos juntos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducci√≥n-parte-2"><a class="header" href="#introducci√≥n-parte-2">Introducci√≥n Parte 2</a></h1>
<p>¬°Hola comunidad! üëã</p>
<p>Nos complace presentar la segunda parte del libro <strong>L2 en Espa√±ol sobre StarkWare</strong>. En estos cap√≠tulos, nos enfocaremos en la fascinante arquitectura de Starknet y el poderoso lenguaje de programaci√≥n, Cairo. Antes de profundizar en ello, agradecemos a los expertos y colaboradores que han aportado su valioso conocimiento para enriquecer este documento y han sido parte activa en el √©xito de esta investigaci√≥n sobre la arquitectura de StarkWare.</p>
<p>En esta etapa, estamos emocionados de adentrarnos en el desarrollo detr√°s de StarkWare, un ecosistema en el que brillantes mentes trabajan en conjunto para alcanzar logros extraordinarios.</p>
<p>¬øTe sientes inspirado para ser parte de esta comunidad de mentes brillantes? Si es as√≠, te animamos a acompa√±arnos en este viaje. Nos sumergiremos en los detalles m√°s profundos, exploraremos algunos conceptos clave para establecer una s√≥lida base y contextualizar los componentes como StarkEx, Starknet, SHARP, Secuenciadores, Starknet Stack y mucho m√°s.</p>
<p>¬°Prep√°rate para un emocionante recorrido por el mundo de Starknet y Cairo! ¬°Comencemos! üöÄ</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arquitectura-starknet-y-cairo"><a class="header" href="#arquitectura-starknet-y-cairo">Arquitectura Starknet y Cairo</a></h1>
<p>Starknet es una soluci√≥n escalabilidad de de capa 2 para ETH que ofrece transacciones r√°pidas, seguras y de bajo costo. Funciona como un Validity Rollup (confundidos o mal nombrados a veces como ZK Rollup) que utiliza sistemas criptogr√°ficos llamados STARKs para reducir los costos de computaci√≥n.</p>
<p>Starknet introduce una innovadora soluci√≥n de Capa 2 para ETH, que aprovecha la tecnolog√≠a de STARKs para revolucionar la escalabilidad y seguridad. En este documento ofreceremos informaci√≥n sobre la estructura de Starknet y Cairo, en los primeros cap√≠tulos daremos una visi√≥n t√©cnica detallada de la arquitectura de la red Starknet y sus componentes clave <code>Sequencers</code>, <code>Provers</code> y <code>Nodes</code>. Estos actores trabajan en armon√≠a, impulsando el procesamiento eficiente de la red y asegurando la integridad de las transacciones. Aunque Starknet se encamina hacia la descentralizaci√≥n total, actualmente se enfoca en el desarrollo para alcanzar este objetivo final. </p>
<h2 id="caracter√≠sticas-generales-de-starknet"><a class="header" href="#caracter√≠sticas-generales-de-starknet">Caracter√≠sticas Generales de Starknet</a></h2>
<p>Veamos algunas car√°teristicas b√°sicas antes de pasar a componente y su arquitectura.</p>
<ul>
<li><strong>Bajos costos de transacci√≥n:</strong> Los costos de transacci√≥n en Starknet son significativamente inferiores a los de Ethereum. Con pr√≥ximas mejoras como Volition (disponibilidad de datos fuera de la cadena) y la implementaci√≥n de EIP 4844 en L1, se espera que estos costos disminuyan a√∫n m√°s.</li>
<li><strong>Plataforma amigable para desarrolladores:</strong> Starknet proporciona un entorno que empodera a los desarrolladores para construir aplicaciones descentralizadas utilizando STARKs y el lenguaje de programaci√≥n Cairo.</li>
<li><strong>Alto rendimiento y baja latencia:</strong> Las futuras versiones de Starknet tienen como objetivo aumentar el rendimiento de la red, reducir la latencia de las transacciones y disminuir los costos de las mismas.</li>
<li><strong>La Filosof√≠a de Starknet:</strong> La filosof√≠a de Starknet se centra en ser amigable para los desarrolladores. La red est√° dise√±ada con un claro enfoque en proporcionar a los desarrolladores una plataforma robusta, segura y poderosa para construir el futuro de la infraestructura y las aplicaciones descentralizadas.</li>
<li><strong>Rendimiento:</strong> Starknet ofrece mayor rendimiento, menor latencia y costos de transacci√≥n reducidos, facilitando as√≠ la creaci√≥n de aplicaciones intensivas en c√≥mputo.</li>
<li><strong>Cairo:</strong> El lenguaje de programaci√≥n central de Starknet, Cairo, se actualiza constantemente y se mejora para brindar a los desarrolladores las mejores herramientas para aprovechar las pruebas de validez y la tecnolog√≠a zk-STARKs.</li>
<li><strong>Enfoque en la comunidad:</strong> Starknet mantiene canales activos de comunicaci√≥n y retroalimentaci√≥n con la comunidad de desarrolladores a trav√©s de plataformas como Telegram y Discord.</li>
<li><strong>Creatividad:</strong> Starknet tiene como objetivo eliminar limitaciones y empoderar a los desarrolladores para construir el futuro de las aplicaciones descentralizadas. Permite crear cosas que nunca antes se pudieron construir debido a las limitaciones de la tecnolog√≠a subyacente.</li>
<li><strong>Herramientas:</strong> Starknet se compromete a proporcionar una amplia gama de herramientas de desarrollo, incluyendo SDKs para diversos lenguajes, un marco de pruebas e implementaci√≥n inspirado en Foundry (Protostar) y administradores de paquetes (Scarb).</li>
</ul>
<p>En la pr√≥xima secci√≥n, nos sumergiremos en la arquitectura de Starknet y sus componentes fundamentales para comprender c√≥mo construir aplicaciones web3 escalables. Te proporcionaremos un conocimiento profundo de los elementos clave de Starknet, lo que te permitir√° desarrollar e implementar dApps de manera eficiente. Comencemos con una breve descripci√≥n de los componentes fundamentales que desempe√±ar√°n un papel crucial en el funcionamiento de la red y asegurar√°n que el ciclo de las transacciones sea escalable, r√°pido y econ√≥mico.</p>
<h2 id="sequencers"><a class="header" href="#sequencers">Sequencers:</a></h2>
<p>Los Secuenciadores (Sequencers) son componentes esenciales de la red Starknet y juegan un papel central al actuar como puntos de entrada para las transacciones. Son comparables a los validadores en Ethereum, y los ZK Rollups tienen la capacidad √∫nica de delegar ciertas tareas de la red, como la agregaci√≥n y el procesamiento de transacciones, a entidades especializadas. Sin embargo, este proceso demanda recursos significativos debido a los altos requisitos de capacidad y continuidad.</p>
<p>En el ecosistema de Starknet y otras plataformas con ZK Rollups, se observa un paralelo similar. Estas redes externalizan el procesamiento de transacciones a estas entidades especializadas, denominadas <code>Sequencers</code>, quienes luego verifican su trabajo. La delegaci√≥n de tareas a los Sequencers es clave para que los ZK Rollups puedan manejar una gran cantidad de transacciones sin poner en riesgo la seguridad de la red subyacente, y as√≠ los Sequencers desempe√±an un papel esencial para lograr una mayor escalabilidad en Ethereum.</p>
<p>A diferencia de los mineros, cuya funci√≥n es brindar seguridad en otras redes, los Sequencers no aportan seguridad, sino que ofrecen capacidad de transacci√≥n. Su labor consiste en agrupar m√∫ltiples transacciones en un solo batch, procesarlas y generar un bloque. Este bloque ser√° luego verificado por el Verificador, al cual se le proporcionar√° una zk Proof que garantiza la <strong><code>Validez</code></strong> o <strong><code>Integridad</code></strong> de los datos, conocida como <code>Validity Proof</code>, y m√°s concretamente un <code>STARK</code> espec√≠fico de Starknet. El Prover es el encargado de generar este STARK y se asegura de que todos los datos de las transacciones sean correctos. Posteriormente, el Sequencer enviar√° todo a la red de Capa 1 como un <code>rollup</code>, una prueba √∫nica y compacta para que el Verificador compruebe que los datos son correctos y actualice el nuevo estado de la red.</p>
<p>Los Sequencers siguen un m√©todo sistem√°tico para el procesamiento de transacciones:</p>
<ol>
<li><strong>Agregaci√≥n:</strong> Recopilan transacciones de los usuarios.</li>
<li><strong>Procesamiento:</strong> Los Sequencers procesan estas transacciones de acuerdo con las reglas definidas por la red.</li>
<li><strong>Agrupaci√≥n:</strong> Las transacciones se agrupan en batchs o bloques para mayor eficiencia.</li>
<li><strong>Producci√≥n de Bloques:</strong> Los Sequencers producen bloques que contienen lotes de transacciones procesadas.</li>
</ol>
<p>Los Sequencers deben ser confiables y estar altamente disponibles, ya que su funci√≥n es fundamental para el buen funcionamiento de la red. Necesitan m√°quinas potentes y bien conectadas para desempe√±ar su papel de manera efectiva, ya que deben procesar transacciones de manera r√°pida y continua.</p>
<p>La hoja de ruta actual de Starknet incluye la descentralizaci√≥n del rol de secuenciador. Este cambio hacia la descentralizaci√≥n permitir√° que m√°s participantes se conviertan en Sequencers, contribuyendo a la robustez y seguridad de la red.</p>
<h2 id="provers"><a class="header" href="#provers">Provers:</a></h2>
<p>En Starknet, el SHARP (Shared Prover) desempe√±a un papel esencial al realizar m√∫ltiples tareas, incluida la generaci√≥n de la Validity Proof. Detallaremos estas diversas funciones en cap√≠tulos posteriores para comprender su importancia. Podemos entender al Prover como un componente que act√∫a en la segunda l√≠nea de verificaci√≥n del sistema, y una de sus tareas principales es validar el trabajo de los Sequencers, especialmente cuando estos reciben el bloque producido por el Sequencers. Adem√°s, los Provers tambi√©n tienen la responsabilidad de generar pruebas que demuestren que todos estos procesos se llevaron a cabo de manera correcta.</p>
<p>Los Provers necesitan incluso m√°s potencia computacional que los Sequencers, ya que deben calcular y generar pruebas, un proceso que es computacionalmente pesado. Sin embargo, el trabajo de los Provers se puede dividir en varias partes, lo que permite la paralelizaci√≥n y la generaci√≥n eficiente de pruebas. El proceso de generaci√≥n de pruebas es asincr√≥nico, lo que significa que no es necesario que ocurra de inmediato o en tiempo real. Esta flexibilidad permite distribuir la carga de trabajo entre varios Provers, cada uno trabajando en un bloque diferente, lo que facilita la paralelizaci√≥n y una generaci√≥n m√°s eficiente de pruebas.</p>
<p>El dise√±o de Starknet se basa en dos tipos de actores: los Sequencers y los Provers, que trabajan en conjunto para garantizar un procesamiento eficiente y una verificaci√≥n segura de las transacciones.</p>
<p>En cuanto a las funciones de un Prover, podemos destacar:</p>
<ol>
<li><strong>Recepci√≥n de Bloques:</strong> Los Provers obtienen bloques de transacciones procesadas de los Sequencers.</li>
<li><strong>Procesamiento:</strong> Los Provers vuelven a procesar estos bloques para asegurarse de que todas las transacciones dentro del bloque se hayan manejado correctamente.</li>
<li><strong>Generaci√≥n de Pruebas:</strong> Despu√©s del procesamiento, los Provers generan una Validity Proof que demuestra el correcto procesamiento de las transacciones.</li>
<li><strong>Env√≠o de Prueba a Ethereum:</strong> Finalmente, la Validity Proof se env√≠a a la red de Ethereum para su validaci√≥n. Si la Validity Proof es correcta, la red Ethereum acepta el bloque de transacciones.</li>
</ol>
<h2 id="nodos"><a class="header" href="#nodos">Nodos:</a></h2>
<p>Cuando se trata de definir qu√© hacen los nodos en Bitcoin o Ethereum, a menudo se interpreta err√≥neamente su papel como mantener un registro de cada transacci√≥n dentro de la red. Sin embargo, esto no es del todo preciso.</p>
<p>Los nodos act√∫an como auditores de la red, manteniendo el estado de la red, como cu√°nto Bitcoin posee cada participante o el estado actual de un contrato inteligente espec√≠fico. Logran esto procesando transacciones y conservando un registro de todas las transacciones, pero eso es un medio para un fin, no el fin en s√≠ mismo.</p>
<p>En el caso de Validity Rollup, espec√≠ficamente dentro de Starknet, este concepto se invierte en cierta medida. Los nodos no necesariamente tienen que procesar todas las transacciones para obtener el estado. A diferencia de Ethereum o Bitcoin, los nodos de Starknet no est√°n obligados a procesar cada transacci√≥n para mantener el estado de la red.</p>
<p>Existen dos formas principales de acceder a los datos del estado de la red:</p>
<ul>
<li>A trav√©s de una puerta de enlace de API.</li>
<li>Mediante el protocolo RPC para comunicarse con un nodo.</li>
</ul>
<p>Operar su propio nodo suele ser m√°s r√°pido que usar una arquitectura compartida, como la puerta de enlace. A medida que avanza el tiempo, Starknet planea descontinuar las API y reemplazarlas por un est√°ndar JSON RPC, lo que har√° que operar su propio nodo sea a√∫n m√°s beneficioso.</p>
<p>Vale la pena se√±alar que alentar a m√°s personas a ejecutar nodos aumenta la resistencia de la red y evita la sobrecarga del servidor, un problema que ha afectado a otras redes de Capa 2.</p>
<p>Actualmente, existen principalmente tres m√©todos principales para que un nodo lleve un registro del estado de la red: </p>
<ol>
<li><strong>Reproducci√≥n de Transacciones Antiguas:</strong> Al igual que en Ethereum o Bitcoin, un nodo puede tomar todas las transacciones y volver a ejecutarlas. Aunque este enfoque es preciso, no es escalable a menos que se tenga una m√°quina potente capaz de manejar la carga. Si se pueden volver a reproducir todas las transacciones, el nodo puede convertirse en un Sequencer, como puede ser el caso del nuevo enfoque adaptado a Madara con Substrate, actuando como un Sequencer, Full Node o mucho m√°s como veremos en su momento.</li>
<li><strong>Confiar en el Consenso de Capa 2:</strong> Los nodos pueden confiar en que los Secuencer ejecutan la red correctamente. Cuando el Secuencer actualiza el estado y agrega un nuevo bloque, los nodos aceptan la actualizaci√≥n como precisa.</li>
<li><strong>Verificaci√≥n de la Validaci√≥n de Pruebas en L1:</strong> Los nodos pueden monitorear el estado de la red observando L1 y asegur√°ndose de que cada vez que se env√≠a una prueba, reciben el estado actualizado. De esta manera, no tienen que confiar en nadie y solo necesitan realizar un seguimiento de la √∫ltima transacci√≥n v√°lida para Starknet.</li>
</ol>
<p>Podemos encontrarnos una variedad de tipos de nodos, cada uno desempe√±ando un papel esencial en el funcionamiento y cada tipo de configuraci√≥n de nodo presenta sus propios desaf√≠os y oportunidades, ya que vienen acompa√±ados de requisitos de hardware y suposiciones de confianza √∫nicas.</p>
<p>A medida que nos adentramos en este universo descentralizado, es crucial entender c√≥mo estos nodos interact√∫an y c√≥mo contribuyen a la eficiencia y seguridad de Starknet. Desde aquellos que reproducen transacciones con potencia de procesamiento masiva, hasta los que conf√≠an en el consenso de Capa 2 con menor carga computacional, y aquellos que verifican la validaci√≥n de pruebas en L1 con una huella m√°s liviana, cada nodo tiene su lugar y su relevancia en esta red en constante evoluci√≥n.</p>
<h3 id="nodos-que-reproducen-transacciones"><a class="header" href="#nodos-que-reproducen-transacciones">Nodos que Reproducen Transacciones:</a></h3>
<p>Los nodos que reproducen transacciones requieren m√°quinas potentes para rastrear y ejecutar todas las transacciones. Estos nodos no tienen suposiciones de confianza, √∫nicamente conf√≠an en las transacciones que ejecutan, garantizando que el estado en cualquier momento sea v√°lido.</p>
<h3 id="nodos-que-confian-en-el-consenso-de-capa-2"><a class="header" href="#nodos-que-confian-en-el-consenso-de-capa-2">Nodos que Confian en el Consenso de Capa 2:</a></h3>
<p>Los nodos que conf√≠an en el consenso de Capa 2 representan una opci√≥n de menor exigencia en cuanto a potencia computacional. Aunque necesitan un almacenamiento adecuado para mantener el estado, su carga de procesamiento de transacciones es m√°s liviana, dado que se basan en una suposici√≥n de confianza. Inicialmente, Starknet estuvo centrado en un solo secuenciador, pero ha evolucionado hacia una red m√°s descentralizada con la incorporaci√≥n de componentes como Madara y Secuencers de Rust mejorados por Lambda, entre otros, los cuales ser√°n detallados en la secci√≥n de Sequencers.</p>
<p>En este contexto, estos nodos depositan su confianza en que Starkware no interferir√° con la red. Sin embargo, a medida que se implemente un mecanismo de consenso y selecci√≥n de l√≠deres entre los Sequencers, el nivel de confianza se modificar√°. En ese futuro escenario, los nodos solo necesitar√°n confiar en que un Sequencer que ha comprometido su participaci√≥n para producir un bloque no estar√° dispuesto a perderla.</p>
<h3 id="nodos-que-verifican-la-validaci√≥n-de-pruebas-en-l1"><a class="header" href="#nodos-que-verifican-la-validaci√≥n-de-pruebas-en-l1">Nodos que Verifican la Validaci√≥n de Pruebas en L1:</a></h3>
<p>Los nodos que actualizan su estado bas√°ndose √∫nicamente en la validaci√≥n de pruebas en L1 requieren menos hardware y comparten los mismos requisitos que un nodo de Ethereum. Con la futura existencia de nodos ligeros de Ethereum, mantener un nodo de este tipo podr√≠a ser tan sencillo como usar un tel√©fono inteligente. No obstante, existe un compromiso a considerar <code>la latencia</code>. Las pruebas no se env√≠an a Ethereum en cada bloque de manera constante, sino de forma intermitente, lo que provoca actualizaciones de estado retrasadas.</p>
<p>Para aumentar la frecuencia de las pruebas, incluso si no se env√≠an a Ethereum de inmediato, se espera que un avance en el futuro permita que estos nodos reduzcan significativamente su latencia. Sin embargo, es importante tener en cuenta que este desarrollo a√∫n est√° lejos en la hoja de ruta de Starknet</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="componentes"><a class="header" href="#componentes">Componentes</a></h1>
<p>Aprendamos como a medida que te embarcas en el viaje para construir aplicaciones web3 escalables, es esencial comprender la arquitectura de donde est√°s construyendo, en este caso tendr√°s que formarte sobre Starknet y sus diversos componentes. Este cap√≠tulo tiene como objetivo proporcionar una comprensi√≥n profunda de los elementos clave de construcci√≥n de Starknet, lo que te permitir√° desarrollar e implementar aplicaciones descentralizadas (dApps) de manera eficiente.</p>
<p>En este cap√≠tulo, abordaremos temas como:</p>
<ul>
<li>
<p><strong>Nodos L2:</strong> Una visi√≥n general de alto nivel de los diferentes nodos de Starknet (Secuenciador, Full Nodes, Prover e Indexer) y sus funciones dentro de la red.</p>
</li>
<li>
<p><strong>Ciclo de Vida de Transacciones:</strong> Una explicaci√≥n detallada de los diferentes estados por los que pasa una transacci√≥n L2, discutiendo los beneficios y riesgos de considerar un state en particular como <strong>finality</strong>, como se a√±adido con la 0.12.0 directamente el <strong>Accepted_On_L2</strong> eliminando el estado <strong>Pending</strong> y como la 0.12.1 empezar√° a cobrar y a√±adir las <strong>tx Rejected</strong> en el bloque, mejorando la eficiencia y seguridad de la red.</p>
</li>
<li>
<p><strong>SHARP:</strong> Veremos el flujo de trabajo del SHARP, un componente en Starknet que act√∫a como un transporte p√∫blico para las pruebas, permitiendo la agregaci√≥n de m√∫ltiples programas Cairo para reducir costos y aumentar la eficiencia.</p>
<p>Utilizando SHARP, se generan pruebas STARK para programas combinados, lo que facilita el env√≠o de transacciones a una prueba com√∫n. La demostraci√≥n recursiva de SHARP permite la paralelizaci√≥n y optimizaci√≥n, brindando escalabilidad a todas las aplicaciones, y su personalizaci√≥n.</p>
</li>
<li>
<p><strong>Stack de Starknet:</strong> Permite crear sus propias Appchains personalizadas, lo que les proporciona beneficios como protecci√≥n contra la congesti√≥n en la red p√∫blica y la capacidad de implementar caracter√≠sticas que no son compatibles con la cadena p√∫blica, como su propia l√≥gica de mercado de tarifas. Lo que permite valiosos experimentos que pueden aplicarse a otras Appchains o a la red p√∫blica.</p>
</li>
<li>
<p><strong>VM de Cairo:</strong> La CVM forma el n√∫cleo del lenguaje Cairo, brindando capacidades avanzadas de ejecuci√≥n de contratos inteligentes y permitiendo el desarrollo de aplicaciones descentralizadas seguras y eficientes en la cadena de bloques.</p>
</li>
<li>
<p><strong>Storage Proof:</strong> Estas Pruebas de Almacenamiento proporcionan inherentemente una prueba de autenticidad. Las Storage Proof nos permiten validar el state de una cadena de bloques en cualquier momento utilizando compromisos criptogr√°ficos sin asumir la confianza de un tercero.</p>
</li>
<li>
<p><strong>Cairo:</strong> Cairo es un lenguaje para crear programas verificables mediante STARK para c√°lculos generales, este impulsa a Starknet y StarkEx, escalando aplicaciones.</p>
<p>Cairo est√° inspirado en Rust y permite a los desarrolladores escribir contratos inteligentes para Starknet de manera segura y conveniente.</p>
</li>
</ul>
<p>Al final de esta parte 2 sobre arquitectura de Starknet y Cairo, tendr√°s un conocimiento profundo del funcionamiento y los componentes del ecosistema Starknet, lo que te permitir√° tomar decisiones informadas al construir formarte sobre toda su infraestructura.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secuenciadores"><a class="header" href="#secuenciadores">Secuenciadores</a></h1>
<p>Los secuenciadores desempe√±an un papel crucial en las soluciones blockchain y de Capa 2, ya que son responsables de gestionar el orden y la ejecuci√≥n de las transacciones. En Starknet, los secuenciadores garantizan que las transacciones se ejecuten en un orden espec√≠fico para prevenir el doble gasto y mantener la consistencia del estado de la red.</p>
<p>Los secuenciadores reciben transacciones, las procesan seg√∫n reglas predefinidas y producen una serie de acciones u cambios de estado ordenados. Estas acciones se agrupan en bloques y se incluyen en la cadena de bloques.</p>
<p>Los secuenciadores desempe√±an un papel vital en el rendimiento y la seguridad de Starknet al ejecutar transacciones y aplicar cambios de estado seg√∫n las reglas y requisitos del protocolo.</p>
<p>El secuenciador de Starknet es especialmente relevante debido al uso de pruebas de conocimiento cero (ZKPs, por sus siglas en ingl√©s). El correcto funcionamiento del secuenciador garantiza que las transacciones se ejecuten de manera compatible con la generaci√≥n de ZKPs, lo que contribuye a la escalabilidad y seguridad general de Starknet. Los usuarios interact√∫an con los secuenciadores al enviar transacciones a Starknet, siendo este el primer paso hacia el escalado de STARK. Una vez que un secuenciador ensambla un bloque, el protocolo de consenso lo aprueba y los probadores generan una prueba para la Capa 1 (L1).</p>
<p>En Ethereum, los mineros ordenan y ejecutan las transacciones, mientras que los secuenciadores cumplen un prop√≥sito similar en Starknet. Los secuenciadores procesan las transacciones, las agregan y producen bloques, lo que los convierte en una pieza fundamental de la infraestructura del ecosistema de Starknet.</p>
<p>A medida que Starknet evoluciona, es crucial mejorar el rendimiento de los secuenciadores. Aqu√≠ es donde se vuelve fundamental la transici√≥n a secuenciadores basados en Rust. Al reescribir los componentes principales del secuenciador en Rust, la red puede lograr un mejor rendimiento, mayor capacidad y mayor resistencia.</p>
<p>Algunos ejemplos de implementaciones de secuenciadores incluyen <a href="https://github.com/lambdaclass/starknet_tendermint_sequencer">Starknet Tendermint Sequencer de LambdaClass</a> y <a href="https://github.com/keep-starknet-strange/madara">Madara</a>, un secuenciador de Starknet impulsado por Rust utilizando Substrate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secuenciadores-basados-en-rust"><a class="header" href="#secuenciadores-basados-en-rust">Secuenciadores Basados en Rust</a></h1>
<p>Originalmente, los secuenciadores se escribieron en Python, que result√≥ ineficiente para operaciones a gran escala. A medida que la red alcanz√≥ su capacidad, los desarrolladores buscaron mejorar el rendimiento del secuenciador. El primer hito fue establecer una cadena de bloques en pleno funcionamiento, seguida de un enfoque en la optimizaci√≥n del rendimiento.</p>
<p>La mejora inicial del rendimiento implic√≥ la implementaci√≥n de una concurrencia optimista para la ejecuci√≥n de transacciones paralelas. Sin embargo, el avance m√°s significativo provino de la reescritura de secuenciadores en Rust, un lenguaje m√°s eficiente y m√°s r√°pido.</p>
<p>La reescritura de secuenciadores en Rust ha mostrado resultados prometedores en rendimiento y escalabilidad. Se espera que el rendimiento y la latencia de la red Starknet mejoren dram√°ticamente, beneficiando a la red y a aquellos que trabajan con infraestructura relacionada y herramientas de desarrollo.</p>
<p>Uno de los nuevos secuenciadores se basa en Papyrus, un nodo completo Starknet de c√≥digo abierto responsable de la gesti√≥n del estado. Los primeros puntos de referencia para proyectos como Madara revelan una notable transacci√≥n de 76 TPS ( por segundo ) para transferencias ERC20, mostrando las posibles mejoras que los secuenciadores basados en el √≥xido aportan al ecosistema Starknet.</p>
<p>La implementaci√≥n de concurrencia optimista tambi√©n contribuye a las mejoras en el rendimiento del secuenciador al ejecutar transacciones en paralelo, verificar conflictos en las celdas de almacenamiento tocadas e invalidar transacciones posteriores cuando sea necesario.</p>
<p>A medida que Starknet evoluciona, el desarrollo del secuenciador progresar√°, enfoc√°ndose en mejorar las capacidades y garantizar una integraci√≥n perfecta con la red. Los desarrolladores trabajar√°n en nuevas caracter√≠sticas, como los mecanismos de tarifas, que se implementar√°n en los pr√≥ximos lanzamientos como Memphis.</p>
<p>La mejora continua y la optimizaci√≥n de los secuenciadores son vitales para el crecimiento sostenido de Starknet. La transici√≥n a secuenciadores basados en Rust y los esfuerzos continuos para mejorar su desempe√±o indudablemente contribuir√°n.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="madara---bases-de-su-arquitectura"><a class="header" href="#madara---bases-de-su-arquitectura">Madara - Bases de su arquitectura</a></h1>
<p>Madara es mucho m√°s que un secuenciador, ha sido dise√±ado por el equipo de exploraci√≥n de Starkware, los poderosos <a href="https://github.com/keep-starknet-strange">Keep Starknet Strange</a>. Su enfoque modular, basado en Substrate (SDK) con el poder de Rust, lo convierte en un componente principal para escalar Starknet, ETH y darle al usuario y desarrollador la facilidad de adaptar sus dapps, montando capas 3, 4 o 5 modificables seg√∫n su proyecto. Podr√° utilizar y desplegar una pila de componentes de forma r√°pida y segura gracias a las STARKs y Cairo, usando la Cairo VM y el Blockifier para ejecutar programas o contratos de Cairo en Starknet.</p>
<p>En este cap√≠tulo, exploraremos los cimientos de Madara, definiendo conceptos esenciales que son cruciales para comprender tanto esta arquitectura como otras similares.</p>
<ul>
<li>
<p><strong>Substrate:</strong> Es un Kit de desarrollo de software (SDK) que le permite construir cadenas de bloques espec√≠ficas de la aplicaci√≥n que pueden ejecutarse como servicios independientes o en paralelo con otras cadenas.</p>
</li>
<li>
<p><strong>Blockifier:</strong> Es una implementaci√≥n de Rust para el componente de ejecuci√≥n de transacciones en el secuenciador Starknet, a cargo de crear diferencias de estado <code>state distaff</code> y bloques, su funci√≥n engloba:</p>
<ul>
<li>Realizar la ejecuci√≥n de un bloque y generar  un state distaff.</li>
<li>Integrarse con el secuenciador Starknet actual, reemplazando su componente de bloqueo de transacciones, escrito en Python.</li>
<li>Implementar la concurrencia optimista de la ejecuci√≥n de transacciones.</li>
<li>Ampliar el Blockifier para convertirlo en un secuenciador Starknet completo, escrito en Rust, sustituyendo al actual en uso.</li>
</ul>
</li>
<li>
<p><strong>Pallet:</strong> El n√∫cleo de Madara reside en el starknet pallet, que proporciona una capa de compatibilidad Starknet para Substrate. Esto permite una ejecuci√≥n fluida del c√≥digo existente de Cairo. Este pallet no solo incluye un m√≥dulo RPC, sino que tambi√©n posibilita la emulaci√≥n de bloques Starknet, valida las transacciones codificadas por Starknet y facilita la implementaci√≥n de una Starknet DApp sin necesidad de modificaciones.</p>
</li>
<li>
<p><strong>Paridad de bloques:</strong> Wrapper Block es una estrategia en Substrate dise√±ada para procesar bloques que no fueron originariamente concebidos con Substrate en mente, este enfoque fue pionero por Parity en la capa de compatibilidad EVM para Substrate.</p>
</li>
<li>
<p><strong>Stack de Madara:</strong> El Stack de Madara consta de tres componentes clave: Ejecuci√≥n, Asentamiento y Secuenciaci√≥n.</p>
<ul>
<li>
<p><strong>Ejecuci√≥n:</strong> Define el procedimiento para la ejecuci√≥n de bloques y la creaci√≥n de diferencias de estado. Permite cambiar entre Blockifier (por Starkware) y starknet_in_rust (por LambdaClass) para una mayor optimizaci√≥n con el tiempo.</p>
</li>
<li>
<p><strong>Settlement:</strong> Permite construir el estado de la cadena Madara solo mirando su capa de asentamiento. No hace suposiciones sobre la capa de asentamiento elegida y permite establecer la finalidad Hard y Soft seg√∫n el contexto.</p>
</li>
<li>
<p><strong>Sequencing:</strong> Realizada por Madara, se puede modificar para satisfacer diferentes necesidades. Puede ser un FCFS, PGA simple o esquemas m√°s complejos como Narwhall &amp; Bullshark o HotStuff, que se basa en el protocolo PBFT.</p>
</li>
</ul>
</li>
<li>
<p><strong>Gobernanza:</strong> La gobernanza en Madara se basa principalmente en la SnapShot X, un sistema totalmente en cadena que utiliza Storage Proof. Adem√°s, se est√°n explorando otros mecanismos de gobernanza,  como el pallet nativo de gobernanza en Substrate.</p>
</li>
</ul>
<p>Con estos aspectos clave, hemos buscado fortalecer los fundamentos esenciales de Madara y evitar limitarnos a considerarlo √∫nicamente como un secuenciador. Su enfoque modular, adaptado a Starknet y centrado en el concepto de escalado fractal, abre las puertas a fusiones de componentes que trascienden las expectativas convencionales. Adem√°s, esta arquitectura posibilita optimizaciones y mejoras m√°s efectivas en diversos desarrollos, como el impresionante Starknet Stack desarrollado por Lambda, que contribuye a la eficiencia global del sistema.</p>
<p>Este enfoque estrat√©gico de Madara en Substrate no solo nos permite la creaci√≥n de nuevas cadenas subyacentes, abordando diversas estrategias de almacenamiento de datos y variados protocolos de consenso, incluyendo opciones como Celestia. Tambi√©n nos brinda la capacidad de implementar una gama diversa de arquitecturas, como la prometedora fusi√≥n potencial con Kakarot, un zkEVM que interpreta el lenguaje de programaci√≥n Solidity y lo ejecuta en el entorno Cairo. Esta colaboraci√≥n inteligente proporciona una mayor flexibilidad y la opci√≥n de afinarla como un zkEVM de tipo 1. Adem√°s, Madara sienta las bases para el desarrollo de motores de juegos completos al estilo de Unity, como se demuestra claramente con el ejemplo de Dojo en el entorno de Starknet. Estas capacidades no solo permiten una creaci√≥n √°gil y adaptable a necesidades espec√≠ficas, sino que tambi√©n destaca la versatilidad de Madara m√°s all√° de su papel inicial como secuenciador, tal como mencionamos al principio.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-kraken-sequencer-"><a class="header" href="#starknet-kraken-sequencer-">Starknet Kraken Sequencer üöß</a></h1>
<p>En este cap√≠tulo, exploraremos Kraken, uno de los Secuenciadores que busca optimizar y mejorar el rendimiento. Kraken es una implementaci√≥n descentralizada de un secuenciador dise√±ado por Lambda Class con el prop√≥sito de escalar Starknet. </p>
<blockquote>
<p><strong>Nota:</strong> El c√≥digo actual de consenso se basa en gran medida en la implementaci√≥n de <a href="https://github.com/asonnino/hotstuff/">Albert Sonnino's (asonnino) implementation</a>, la cual se centr√≥ en la investigaci√≥n en lugar de la aplicaci√≥n. Las modificaciones fueron realizadas por Lambda Class, principalmente en la estructura del nodo, para permitir el procesamiento de transacciones para bloques confirmados.</p>
</blockquote>
<p>En este an√°lisis detallaremos sus diferentes m√≥dulos y posibles implementaciones, analizemos como el secuenciador puede dividirse en (aproximadamente) 3 m√≥dulos intercambiables:</p>
<h2 id="m√≥dulo-mempool"><a class="header" href="#m√≥dulo-mempool">M√≥dulo Mempool</a></h2>
<p>El m√≥dulo Mempool, conocido como <a href="https://arxiv.org/pdf/2105.11827.pdf"><strong>Narwhal</strong></a>, almacena las transacciones recibidas. Narwhal se especializa en la difusi√≥n y el almacenamiento de historias causales de transacciones. Est√° dise√±ado para funcionar con alta eficiencia en la difusi√≥n y almacenamiento de transacciones, tolerando incluso fallas en la red. Narwhal es escalable y puede ser implementado con m√∫ltiples trabajadores en cada validador, con un alto rendimiento demostrado. La investigaci√≥n en Narwhal y Tusk propone la separaci√≥n de la difusi√≥n confiable de transacciones de su ordenamiento, habilitando un consenso de alto rendimiento y tolerancia a fallas bizantinas. La combinaci√≥n de Narwhal con un protocolo de consenso parcialmente sincr√≥nico (Narwhal-HotStuff) mejora significativamente el rendimiento, manteniendo alta tolerancia a fallos.</p>
<p>Seg√∫n los datos del Whitepaper, Narwhal-Hotstuff logra m√°s de 130,000 tx/sec con una latencia inferior a 2 segundos en una WAN, en comparaci√≥n con 1,800 tx/sec a 1 segundo de latencia para Hotstuff. La adici√≥n de trabajadores aumenta linealmente el rendimiento a 600,000 tx/sec sin aumento de latencia. Adem√°s, el protocolo Tusk ha sido dise√±ado para trabajar con Narwhal y lograr un rendimiento √≥ptimo incluso bajo condiciones de fallo.</p>
<h2 id="m√≥dulo-de-consenso"><a class="header" href="#m√≥dulo-de-consenso">M√≥dulo de Consenso</a></h2>
<p>En el funcionamiento del secuenciador Kraken, el m√≥dulo de consenso desempe√±a un papel fundamental al ofrecer diversas alternativas para lograr acuerdos en el estado compartido. Estas opciones abarcan desde enfoques simples hasta esquemas m√°s complejos, como el <strong>FCFS (First-Come, First-Served)</strong>, que organiza tareas seg√∫n su recepci√≥n, <strong>PGA (Practical Byzantine Fault Tolerance)</strong>, un algoritmo que busca acuerdos en sistemas distribuidos a pesar de fallos o nodos maliciosos, y tambi√©n esquemas m√°s sofisticados como <strong>Bullshark</strong>, <strong>Tendermint</strong> y <strong>Hotstuff</strong>.</p>
<ul>
<li>
<p><a href="https://arxiv.org/pdf/1803.05069.pdf"><strong>HotStuff:</strong></a> es un protocolo de consenso basado en el algoritmo PBFT que destaca por su enfoque en la optimizaci√≥n de la latencia y el rendimiento. Su dise√±o permite la replicaci√≥n de estado a alta velocidad en sistemas distribuidos. Introduciendo un enfoque basado en tolerancia a fallos bizantinos, HotStuff capacita a un l√≠der confiable para guiar el protocolo hacia el consenso en l√≠nea con el retraso real de la red, en contraposici√≥n al retraso m√°ximo, obteniendo una propiedad denominada capacidad de respuesta. Este logro se complementa con una complejidad de comunicaci√≥n lineal en funci√≥n del n√∫mero de r√©plicas involucradas. En la esencia de su estructura, HotStuff supera el desaf√≠o de la replicaci√≥n de la m√°quina de estado (SMR), logrando aplicar comandos de manera secuencial y coherente. En el n√∫cleo de SMR reside un protocolo que rige la determinaci√≥n de un registro en crecimiento de solicitudes de comandos procedentes de los clientes. De manera conjunta, un grupo de r√©plicas de la m√°quina de estado lleva a cabo la ejecuci√≥n de estos comandos en orden secuencial y coherente. Si bien gran parte de la discusi√≥n excluye al cliente, la literatura est√°ndar aborda aspectos relativos a la numeraci√≥n y deduplicaci√≥n de solicitudes de clientes.</p>
</li>
<li>
<p><a href="https://arxiv.org/pdf/2201.05677.pdf"><strong>Bullshark:</strong></a> BullShark es un protocolo de difusi√≥n at√≥mica asincr√≥nica basado en gr√°ficos ac√≠clicos dirigidos (DAG) que est√° optimizado para el caso sincr√≥nico com√∫n. A diferencia de otros protocolos asincr√≥nicos basados en DAG, BullShark proporciona una ruta r√°pida de baja latencia que explota per√≠odos sincr√≥nicos y elimina la necesidad de mecanismos de cambio de vista y sincronizaci√≥n de vista notoriamente complejos. BullShark logra esto manteniendo todas las propiedades deseables de su predecesor DAG-Rider, incluyendo una complejidad de comunicaci√≥n amortizada √≥ptima, equidad y vida asincr√≥nica, y garantizando la seguridad incluso ante un adversario cu√°ntico.</p>
</li>
</ul>
<p>Mediante esta gama de opciones de consenso, Kraken se adapta con flexibilidad a diversos escenarios y requerimientos.</p>
<h2 id="m√≥dulo-de-ejecuci√≥n"><a class="header" href="#m√≥dulo-de-ejecuci√≥n">M√≥dulo de Ejecuci√≥n</a></h2>
<p>Ahora enfoqu√©monos en el motor de ejecuci√≥n, el componente esencial encargado de procesar las transacciones en la m√°quina de estado. En Starknet, el sistema operativo est√° implementado en Rust, y la ejecuci√≥n puede llevarse a cabo mediante <a href="https://github.com/lambdaclass/cairo_native">Cairo Native</a> (un compilador que transforma el c√≥digo de representaci√≥n intermedia &quot;Sierra&quot; de Cairo en c√≥digo de m√°quina a trav√©s de MLIR y LLVM) o <a href="https://github.com/lambdaclass/cairo-vm">Cairo-rs</a> (una implementaci√≥n m√°s r√°pida y segura de la m√°quina virtual de Cairo en Rust). Esta adaptabilidad a trav√©s de m√∫ltiples opciones garantiza una operaci√≥n eficiente y segura en el procesamiento de las transacciones.</p>
<h3 id="m√≥dulos-intercambiables"><a class="header" href="#m√≥dulos-intercambiables">M√≥dulos Intercambiables</a></h3>
<p>Una caracter√≠stica clave de Kraken es su capacidad de intercambiar m√≥dulos. Esto implica que la implementaci√≥n subyacente en la comunicaci√≥n del Mempool, el protocolo de Consenso o el Motor de Ejecuci√≥n puede personalizarse y adaptarse seg√∫n las necesidades espec√≠ficas de la red.</p>
<p>Adem√°s, para mantener y persistir el estado, Kraken utiliza un m√≥dulo de Estado que implementa <a href="https://github.com/photondb/photondb">PhotonDB</a> en una primera iteraci√≥n. PhotonDB, un motor de almacenamiento de alto rendimiento dise√±ado para hardware y plataformas modernas, asegura una gesti√≥n adecuada y segura de los datos en el entorno descentralizado de Kraken.</p>
<p>En resumen, Kraken emerge como un poderoso secuenciador descentralizado dise√±ado por Lambda Class para abordar los desaf√≠os de escalabilidad en Starknet. A trav√©s de su enfoque en m√≥dulos intercambiables, Kraken ofrece flexibilidad y personalizaci√≥n, permitiendo adaptar su funcionamiento a diferentes necesidades y contextos. Adem√°s, su incorporaci√≥n de tecnolog√≠as avanzadas como Narwhal, HotStuff, Bullshark o PhotonDB que contribuyen a mantener la coherencia y seguridad del estado en la red distribuida. </p>
<p>En √∫ltima instancia, el secuenciador Kraken no solo demuestra su capacidad para procesar transacciones eficientemente, sino que tambi√©n juega un papel esencial en la b√∫squeda continua de la descentralizaci√≥n en el Starknet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="full-nodes---starknet-stack"><a class="header" href="#full-nodes---starknet-stack">Full Nodes - Starknet Stack</a></h1>
<p>En el contexto de Ethereum y blockchain, un nodo es una parte integral de la red que valida y retransmite transacciones. Los nodos descargan una copia de toda la cadena de bloques y est√°n interconectados con otros nodos para mantener y actualizar el estado de la cadena de bloques. Hay diferentes tipos de nodos, como nodos completos, nodos ligeros y nodos de miner√≠a, cada uno con roles y responsabilidades diferentes dentro de la red.</p>
<h2 id="starknet-stack"><a class="header" href="#starknet-stack">Starknet Stack</a></h2>
<p>La red de nodos de Starknet est√° compuesta por nodos que sincronizan y procesan transacciones, contribuyendo a la seguridad y descentralizaci√≥n general de la red.</p>
<p>La pila de Starknet se puede dividir en varias capas, al igual que los modelos OSI o TCP/IP. El modelo m√°s apropiado depende de tu comprensi√≥n y requisitos. Una versi√≥n simplificada de la pila modular de blockchain podr√≠a verse as√≠:</p>
<ul>
<li><strong>Capa 1 - Capa de Datos:</strong> La Capa 1 en la pila de Starknet es la Capa de Datos, que se refiere a la cadena de bloques subyacente en Ethereum. Esta capa proporciona la seguridad y la integridad de los datos subyacentes a Starknet. Aqu√≠ es donde se almacenan los contratos inteligentes y se realizan las transacciones en Ethereum.</li>
<li><strong>Capa 2 - Capa de Ejecuci√≥n:</strong> La Capa 2 en la pila de Starknet es la Capa de Ejecuci√≥n. Aqu√≠ es donde se lleva a cabo la ejecuci√≥n de los contratos inteligentes utilizando el entorno de ejecuci√≥n de Cairo. Cairo es un lenguaje de programaci√≥n espec√≠fico de Starknet que facilita la escritura y ejecuci√≥n de contratos inteligentes complejos. En esta capa, se procesan las transacciones y se realizan las operaciones computacionales necesarias para ejecutar los contratos inteligentes.</li>
<li><strong>Capa 3 - Capa de Aplicaci√≥n:</strong> La Capa 3 en la pila de Starknet es la Capa de Aplicaci√≥n. Aqu√≠ es donde se desarrollan y despliegan las aplicaciones descentralizadas (dApps) en Starknet. Las dApps pueden incluir una amplia gama de aplicaciones, como juegos, finanzas descentralizadas, intercambios descentralizados y m√°s. Esta capa permite a los desarrolladores aprovechar la escalabilidad y las capacidades de ejecuci√≥n de Starknet para construir aplicaciones m√°s r√°pidas y eficientes.</li>
<li><strong>Capa 4 - Capa de Transporte:</strong> La Capa 4 en la pila de Starknet es la Capa de Transporte. Esta capa se encarga de la comunicaci√≥n y el transporte de datos entre los diferentes nodos de Starknet. Proporciona la infraestructura necesaria para que los nodos se sincronicen y compartan informaci√≥n, lo que contribuye a la seguridad y descentralizaci√≥n general de la red.</li>
</ul>
<p>Estas son las cuatro capas principales en la pila de Starknet. Cada capa desempe√±a un papel crucial en el funcionamiento y la escalabilidad de Starknet, permitiendo a los desarrolladores aprovechar las capacidades de Capa 2 para construir aplicaciones m√°s r√°pidas y eficientes en Ethereum.</p>
<p>En cuanto a por qu√© el c√≥mputo verificable constituye un movimiento tecnol√≥gico con un impacto amplio, creemos en tres cualidades esenciales: inmutable, inalterable, componibilidad.</p>
<ul>
<li><strong>Nivel 8 - Interfaces de usuario:</strong> Las interfaces de usuario parecen fuera de lugar en la pila de c√≥mputo verificable a primera vista. La clave aqu√≠ es reconocer la ventaja poco explorada de ejecutar la generaci√≥n de pruebas en el lado del cliente.</li>
<li><strong>Nivel 7 - Hiperestructura y aplicaciones:</strong> Aqu√≠ es donde participar√°n directamente las pr√≥ximas olas de desarrolladores y creadores. Para una definici√≥n, consulta las <a href="https://jacob.energy/hyperstructures.html">Hiperestructuras</a>.</li>
<li><strong>Nivel 6 - Bibliotecas de bajo nivel:</strong> Aqu√≠ es donde se encuentran bibliotecas como numpy, scipy, onnx. Por ejemplo, consulta <a href="https://twitter.com/gizatechxyz">Giza</a>.</li>
<li><strong>Nivel 5 - Lenguaje de programaci√≥n y compilador:</strong> Aqu√≠ es donde los programas / intenciones de dise√±o escritos en notaciones accesibles y ergon√≥micas en los niveles 5-7 se transforman en objetos estandarizados (por ejemplo, con respecto a algunas arquitecturas de conjuntos de instrucciones) que son susceptibles a aritmetizaci√≥n. Por ejemplo, consulta <a href="https://eprint.iacr.org/2021/1063.pdf">Cairo</a> y <a href="https://github.com/risc0/risc0">Risc0</a>.</li>
<li><strong>Nivel 4 - Aritm√©tica y arquitectura:</strong> Aqu√≠ es donde los objetos estandarizados del nivel 5 se transforman en restricciones polinomiales. Por ejemplo, consulta <a href="https://eprint.iacr.org/2021/582.pdf">ethSTARK</a>.</li>
<li><strong>Nivel 3 - Generaci√≥n y verificaci√≥n de pruebas:</strong> Aqu√≠ es donde las restricciones polinomiales se transforman en pruebas (sucintas, de conocimiento cero) que pueden ser verificadas (de manera eficiente y recursiva), donde los calificadores entre par√©ntesis son m√©tricas a las que se aspira. Por ejemplo, consulta <a href="https://arxiv.org/pdf/1903.12243.pdf">DEEP-FRI</a> y <a href="https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf">KZG</a>.</li>
<li><strong>Nivel 2 - Sistema distribuido:</strong> Aqu√≠ es donde pertenece el dise√±o de la arquitectura del sistema de blockchain o rollup. Por ejemplo, consulta <a href="https://community.starknet.io/t/starknet-decentralization-tendermint-based-suggestion/998">Descentralizaci√≥n de Starknet</a>.</li>
<li><strong>Nivel 1 - Aceleraci√≥n de hardware:</strong> Autoexplicativo. Por ejemplo, consulta <a href="https://www.ingonyama.com/">Ingonyama</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pathfinder"><a class="header" href="#pathfinder">Pathfinder</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="juno"><a class="header" href="#juno">Juno</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deoxys"><a class="header" href="#deoxys">Deoxys</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="papyrus"><a class="header" href="#papyrus">Papyrus</a></h1>
<p>Papyrus es una implementaci√≥n en Rust de un nodo completo de Starknet. Proporcionar√° las bases para el nuevo Sequencer de Starknet, que mejorar√° dr√°sticamente el rendimiento de Starknet. Papyrus ayudar√° a mejorar el rendimiento y la descentralizaci√≥n de Starknet, que son las principales prioridades de desarrollo.</p>
<p>El nodo completo de Papyrus realizar√° un seguimiento del estado de Starknet a medida que evoluciona con el tiempo y permitir√° a los usuarios y desarrolladores consultar este estado a trav√©s de Starknet's JSON-RPC.</p>
<p>Papyrus proporcionar√° al Sequencer de Starknet una capa de almacenamiento eficiente, lo que mejorar√° el rendimiento. Esto significa que el secuenciador mantendr√° una base de datos local en lugar de una base de datos en la nube, y tambi√©n almacenar√° un almacenamiento plano de clave/valor, lo que interactuar√° directamente con el estado.</p>
<p>Papyrus se une a otros nodos completos de Starknet, Pathfinder y Juno, para fortalecer la descentralizaci√≥n y redundancia. Al ser de c√≥digo abierto, Papyrus contribuye a la variedad de implementaciones de clientes, lo que es crucial para una red descentralizada.</p>
<p>Actualmente, Papyrus permite sincronizarse con el estado de Starknet y acceder a toda su historia. Aunque el soporte JSON-RPC est√° parcialmente implementado, el equipo de Papyrus trabajar√° para alcanzar la compatibilidad completa y contribuir√° a formar la base de la capa P2P de Starknet, lo que permitir√° una mayor descentralizaci√≥n. El objetivo final es que diferentes nodos puedan comunicarse y sincronizarse a trav√©s de esta capa P2P, mejorando significativamente los tiempos de sincronizaci√≥n.</p>
<p>En resumen, Papyrus es el tercer nodo completo en unirse al ecosistema de Starknet. Es de c√≥digo abierto bajo la licencia Apache 2.0 y ser√° una parte crucial de la infraestructura de Starknet descentralizado.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sharp"><a class="header" href="#sharp">SHARP</a></h1>
<p>SHARP (SHARed Prover) opera como el transporte p√∫blico para las pruebas en Starknet, permitiendo la agregaci√≥n de m√∫ltiples programas Cairo con el fin de reducir costos y aumentar la eficiencia. Mediante SHARP, se generan pruebas STARK para los programas de Cairo combinados, lo que facilita que cualquier aplicaci√≥n pueda enviar transacciones a la misma prueba. Adem√°s, SHARP emplea pruebas recursivas que permiten la paralelizaci√≥n y optimizaci√≥n, lo que lo convierte en una opci√≥n m√°s accesible para todos los usuarios.</p>
<blockquote>
<p>Imagina que SHARP funciona como un servicio de reparto tipo StarknetUber para las Pruebas STARK. Es como cuando un grupo de amigos se re√∫ne y cada uno realiza compras en diferentes tiendas, pero todos comparten el mismo servicio de entrega para recibir sus pedidos y compartir el gasto. </p>
</blockquote>
<p>De manera similar, SHARP permite que m√∫ltiples programas Cairo se unan y compartan el mismo proceso de generaci√≥n de pruebas STARK. Cada programa puede ser como una compra individual en diferentes tiendas, pero al utilizar el servicio de reparto compartido de SHARP, los costos de generaci√≥n de la prueba se distribuyen entre todos los programas. Esta din√°mica de &quot;reparto de entregas&quot; garantiza que incluso las aplicaciones m√°s peque√±as puedan acceder al enorme poder de escalabilidad que ofrece STARK. Si un programa est√° escrito en Cairo, SHARP puede demostrarlo, sin importar qu√© tan diversas sean las aplicaciones (dApps) que lo utilizan</p>
<ul>
<li>El procesamiento de SHARP agrupa aproximadamente 220,000 transacciones en una sola prueba en la red Ethereum Mainnet. </li>
<li>La demostraci√≥n recursiva con SHARP permite el procesamiento y la verificaci√≥n paralela de m√∫ltiples pruebas STARK, mejorando la escalabilidad y la eficiencia. </li>
<li>La personalizaci√≥n de SHARP, <code>Dynamic Layouts</code>, promete una reducci√≥n adicional de hasta un 30% en las tarifas de gas.</li>
</ul>
<p>Veamos una analog√≠a para ilustrar c√≥mo funciona SHARP, seg√∫n un documento oficial de StarkWare:</p>
<blockquote>
<p>Imagina que t√∫ y tu hermana est√°n comprando regalos para tus padres: un nuevo tel√©fono, una taza y una camiseta. Cada regalo se ordena en l√≠nea a un minorista diferente y se entregar√° en sus respectivos hogares en diferentes fechas, variando en tama√±o y embalaje. Su plan es envolver cada art√≠culo y enviarlos a sus padres por correo.</p>
</blockquote>
<blockquote>
<p>Sin embargo, hay un problema en la oficina de correos. Las cajas peque√±as y medianas no est√°n disponibles, solo hay cajas grandes de tama√±o √∫nico. Esto presenta dos opciones:</p>
</blockquote>
<ul>
<li>
<p><strong>Opci√≥n 1:</strong> Empacar y enviar cada art√≠culo por separado en su propia caja grande tan pronto como llegue. Si bien esto puede acelerar el env√≠o de regalos individuales, requiere el esfuerzo adicional de empacar tres cajas separadas y hacer tres viajes a la oficina de correos para enviar tres paquetes diferentes. Como resultado, este m√©todo no resulta eficiente en t√©rminos de tiempo ni econ√≥mico.</p>
</li>
<li>
<p><strong>Opci√≥n 2:</strong> Empacar y enviar todos los art√≠culos juntos en una sola caja grande. Esto significa que solo manejar√°n una caja en lugar de tres.</p>
</li>
</ul>
<blockquote>
<p>En este ejemplo, SHARP es la Opci√≥n 2, lo que permite el uso eficiente de los recursos y una gesti√≥n del tiempo m√°s fluida.</p>
</blockquote>
<p>SHARP es un sistema potente que est√° dise√±ado para generar pruebas STARK para programas de Cairo agrupados. Cairo, un lenguaje de programaci√≥n de computaci√≥n general, permite la acomodaci√≥n de diversas l√≥gicas de c√≥digo en una sola prueba. El objetivo principal de SHARP es mejorar la escalabilidad y la eficiencia dentro de la red de Starknet, aqu√≠ tenemos algunas de sus propiedades y caractrer√≠sticas:</p>
<p><strong>Amortizaci√≥n Exponencial y Eficiencia en Costos:</strong> </p>
<p>Una de las caracter√≠sticas clave de SHARP es su capacidad para reducir costos y mejorar la eficiencia en la generaci√≥n de pruebas STARK. Al agrupar m√∫ltiples trabajos de Cairo (conjuntos individuales de c√°lculos), SHARP aprovecha la amortizaci√≥n exponencial que ofrecen las pruebas STARK. Esto significa que a medida que aumenta la carga computacional de las pruebas, el costo de verificarlas aumenta a una tasa logar√≠tmica m√°s lenta que el crecimiento de la computaci√≥n en s√≠. Como resultado, el costo de cada transacci√≥n dentro del conjunto agregado se reduce significativamente, lo que lo hace m√°s rentable y accesible para los usuarios.</p>
<p><strong>Procesamiento Paralelo y Pruebas Recursivas:</strong> </p>
<p>SHARP utiliza el procesamiento paralelo de declaraciones entrantes, lo que permite sortear las barreras de escalabilidad anteriores que requer√≠an que las declaraciones combinadas se demostraran solo despu√©s de recibir todas las declaraciones individuales. Con la implementaci√≥n de pruebas recursivas, SHARP demuestra cada declaraci√≥n a medida que llega, en lugar de esperar a completar un conjunto de declaraciones para comenzar el proceso de demostraci√≥n. Esto agiliza el proceso de verificaci√≥n y mejora la eficiencia en comparaci√≥n con el c√°lculo en s√≠.</p>
<p>Con la implementaci√≥n de la recursi√≥n, SHARP demuestra las declaraciones entrantes de inmediato. A partir de ah√≠, estas pruebas pueden demostrarse repetidamente y fusionarse en pruebas recursivas. Este proceso de demostraci√≥n recursiva se implementa hasta que, finalmente, la prueba final se env√≠a a un contrato verificador de Solidity en cadena. </p>
<p><strong>Validaci√≥n y Solidity Verifier:</strong> </p>
<p>Las pruebas STARK generadas por SHARP se validan mediante un contrato verificador de Solidity en Ethereum. Antes de enviar las pruebas al verificador de Solidity, se env√≠an inicialmente a un programa Verificador STARK escrito en Cairo. Este programa Verificador STARK genera una nueva prueba que confirma la validez de las pruebas iniciales, permitiendo la generaci√≥n de m√∫ltiples pruebas hasta llegar al Verificador de Solidity en Ethereum.</p>
<p><strong>Acceso a la Escalabilidad de STARK para Todos:</strong> </p>
<p>SHARP permite que incluso las aplicaciones m√°s peque√±as accedan al enorme poder de escalabilidad que ofrece STARK. Si un programa est√° escrito en Cairo, SHARP puede demostrarlo, sin importar qu√© tan diversas sean las aplicaciones (dApps) que lo utilizan.</p>
<p>Con SHARP, los desarrolladores tienen una soluci√≥n efectiva para mejorar la escalabilidad y reducir los costos de transacci√≥n en la red de Starknet. La capacidad de procesar m√∫ltiples programas Cairo en una sola prueba STARK es un avance significativo que abre nuevas posibilidades para la adopci√≥n masiva de la tecnolog√≠a de escalabilidad STARK.</p>
<p><strong>Dynamic Layouts:</strong> </p>
<p>El equipo detr√°s de SHARP est√° desarrollando actualmente Dynamic Layouts como la pr√≥xima personalizaci√≥n de sus servicios. Con Dynamic Layouts, el probador calcular√° los recursos necesarios para cada l√≥gica espec√≠fica y generar√° una prueba a medida en consecuencia.</p>
<p>Haciendo un paralelismo con nuestra analog√≠a anterior, Dynamic Layouts se puede asemejar a la idea de cajas de env√≠o personalizadas. Estas cajas personalizadas acomodan perfectamente la forma de cada regalo, asegur√°ndose de que solo pagues por el tama√±o exacto necesario, evitando tarifas innecesarias. De manera similar, con Dynamic Layouts, crear√°n una prueba adaptada para cada l√≥gica y los recursos de computaci√≥n √∫nicos que requiere, asegur√°ndose de que solo pagues por la computaci√≥n que uses. Si est√° en Cairo, SHARP puede demostrarlo con precisi√≥n.</p>
<p>Al aprovechar el poder de la generaci√≥n de pruebas recursivas basadas en STARK, SHARP se convierte en una tecnolog√≠a que impulsa enormemente la escalabilidad y eficiencia de la red Ethereum. En el pr√≥ximo cap√≠tulo, nos centraremos en analizar m√°s a fondo su arquitectura y componentes, as√≠ como su funcionamiento, en especial la recursividad.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursividad---sharp"><a class="header" href="#recursividad---sharp">Recursividad - SHARP</a></h1>
<p>Una de las caracter√≠sticas m√°s poderosas de SHARP es su uso de pruebas recursivas. En lugar de enviar directamente las pruebas generadas al Verificador de Solidity, primero se env√≠an a un programa Verificador STARK escrito en Cairo. Este Verificador, que tambi√©n es un Programa Cairo, recibe la prueba y crea un nuevo trabajo de Cairo que se env√≠a al Proveedor. El Proveedor luego genera una nueva prueba para confirmar que las pruebas iniciales fueron verificadas. Estas nuevas pruebas se pueden enviar de vuelta a SHARP y al Verificador STARK, reiniciando el proceso.</p>
<p>Este proceso contin√∫a de forma recursiva, enviando cada nueva prueba al Verificador de Cairo hasta que se alcanza un disparador. En este punto, la √∫ltima prueba de la serie se env√≠a al Verificador de Solidity en Ethereum. Este enfoque permite una mayor paralelizaci√≥n de la computaci√≥n y reduce el tiempo y los costos asociados con la generaci√≥n y verificaci√≥n de pruebas.</p>
<p>A primera vista, las pruebas recursivas pueden parecer m√°s complejas y consumir m√°s tiempo. Sin embargo, hay varios beneficios en este enfoque:</p>
<ul>
<li><strong>Paralelizaci√≥n:</strong> Las pruebas recursivas permiten la paralelizaci√≥n del trabajo, reduciendo la latencia del usuario y mejorando la eficiencia de SHARP.</li>
<li><strong>Menores costos en la cadena:</strong> La paralelizaci√≥n permite que SHARP cree pruebas m√°s grandes, que anteriormente se limitar√≠an por la disponibilidad de m√°quinas en la nube grandes (que son escasas y limitadas). Como resultado, los costos en la cadena se reducen.</li>
<li><strong>Menores costos en la nube:</strong> Dado que cada trabajo es m√°s corto, se reduce la memoria requerida para el procesamiento, lo que resulta en menores costos en la nube.</li>
<li><strong>Optimizaci√≥n:</strong> Las pruebas recursivas permiten que SHARP se optimice para varios factores, incluyendo la latencia, los costos en la cadena y el tiempo de prueba.</li>
<li><strong>Compatibilidad con Cairo:</strong> Las pruebas recursivas solo requieren soporte en Cairo, sin necesidad de agregar soporte en el Verificador de Solidity.</li>
</ul>
<p>La latencia en Starknet abarca el tiempo que lleva procesar, confirmar e incluir transacciones en un bloque. Est√° afectada por factores como la congesti√≥n de la red, las tarifas de transacci√≥n y la eficiencia del sistema. Minimizar la latencia garantiza un procesamiento de transacciones m√°s r√°pido y una retroalimentaci√≥n del usuario m√°s r√°pida.</p>
<p>El tiempo de prueba, por otro lado, se refiere espec√≠ficamente a la duraci√≥n requerida para generar y verificar pruebas criptogr√°ficas para transacciones u operaciones.</p>
<p>Desde SHARP 4.0 se agregaron dos nuevos componentes importantes: keccack y Poseid√≥n.</p>
<p>Keccack es importante para las aplicaciones y Poseidon tambi√©n se usa en el propio estado de Starknet (para el nuevo c√°lculo de hash de clases de Cairo 1 y para el nuevo estado de clases).</p>
<p>La arquitectura del backend de SHARP consiste en varios servicios que trabajan en conjunto para procesar trabajos de Cairo y generar pruebas. Estos servicios incluyen:</p>
<ul>
<li><strong>Gateway:</strong> Los trabajos de Cairo ingresan a SHARP a trav√©s del gateway.</li>
<li><strong>Job Creator:</strong> Evita la duplicaci√≥n de trabajos y garantiza que el sistema funcione de manera consistente, independientemente de las solicitudes m√∫ltiples id√©nticas.</li>
<li><strong>Validator:</strong> Este es el primer paso importante. El servicio de validaci√≥n realiza verificaciones en cada trabajo para asegurarse de que cumplan con los requisitos y puedan adaptarse a las m√°quinas probadoras. Los trabajos inv√°lidos se etiquetan como tales y no contin√∫an hacia el Prover.</li>
<li><strong>Scheduler:</strong> El servicio de planificaci√≥n crea &quot;trains&quot; que agregan trabajos y los env√≠an al Prover. Los trabajos recursivos se emparejan y se env√≠an juntos al Prover.</li>
<li><strong>Cairo Runner:</strong> Este servicio ejecuta Cairo para las necesidades del Prover. El servicio Cairo Runner ejecuta programas de Cairo, realizando los c√°lculos necesarios y generando el rastro de ejecuci√≥n como resultado intermedio. El Prover luego utiliza este rastro de ejecuci√≥n.</li>
<li><strong>Prover:</strong> El Prover calcula las pruebas para cada trains (que contiene varios trabajos).</li>
<li><strong>Dispatcher:</strong> El Dispatcher cumple dos funciones en el sistema SHARP.
<ul>
<li>
<p>En el caso de una prueba recursiva, el Dispatcher ejecuta el programa Cairo Verifier en la prueba que ha recibido del Prover, lo que resulta en un nuevo trabajo de Cairo que vuelve al Validador.</p>
</li>
<li>
<p>En el caso de una prueba que debe ir a la cadena (por ejemplo, a Ethereum), el Dispatcher crea &quot;paquetes&quot; a partir de la prueba, que luego se pueden enviar al Escritor de la Cadena de Bloques.</p>
</li>
</ul>
</li>
<li><strong>Blockchain Writer:</strong> Una vez que el Dispatcher ha creado los paquetes, los env√≠a al Escritor de la Cadena de Bloques. El Escritor de la Cadena de Bloques se encarga de enviar los paquetes a la cadena de bloques correspondiente (por ejemplo, Ethereum) para su verificaci√≥n. Este es un paso importante en el sistema SHARP, ya que garantiza que las pruebas se verifiquen correctamente y que las transacciones se registren de forma segura en la cadena de bloques.</li>
<li><strong>Catcher:</strong> El Catcher monitorea las transacciones de la cadena de bloques (por ejemplo, Ethereum) para asegurarse de que hayan sido aceptadas. Si bien el Catcher es relevante para fines de monitoreo interno, es importante tener en cuenta que si una transacci√≥n falla, el hecho no se registrar√° en el registro de hechos de la cadena. Como resultado, la integridad del sistema se mantiene incluso sin el Catcher.</li>
</ul>
<p>SHARP est√° dise√±ado para ser sin estado (cada trabajo de Cairo se ejecuta en su propio contexto y no depende de otros trabajos), lo que permite una mayor flexibilidad en el procesamiento de trabajos.</p>
<p>Actualmente, los principales usuarios de SHARP incluyen:</p>
<ul>
<li>StarkEx</li>
<li>Starknet</li>
<li>Usuarios externos que utilizan el Cairo Playground</li>
</ul>
<p>Optimizar el Proveedor implica numerosos desaf√≠os y proyectos potenciales en los que el equipo de Starkware y la comunidad est√°n trabajando actualmente:</p>
<ul>
<li><strong>Exploraci√≥n de funciones hash m√°s eficientes:</strong> SHARP est√° constantemente explorando funciones hash m√°s eficientes para Cairo, el Proveedor y Solidity.</li>
<li><strong>Investigaci√≥n de campos m√°s peque√±os:</strong> La investigaci√≥n de campos m√°s peque√±os para los pasos de prueba recursiva podr√≠a conducir a c√°lculos m√°s eficientes.</li>
<li><strong>Ajuste de varios par√°metros:</strong> SHARP est√° ajustando constantemente varios par√°metros del protocolo STARK, como los par√°metros FRI y los factores de bloque.</li>
<li><strong>Optimizaci√≥n del c√≥digo de Cairo:</strong> SHARP est√° optimizando el c√≥digo de Cairo para hacerlo m√°s r√°pido, lo que resulta en un Proveedor recursivo m√°s r√°pido.</li>
<li><strong>Desarrollo de dise√±os din√°micos:</strong> Esto permitir√° a los programas de Cairo adaptar los recursos seg√∫n sus necesidades.</li>
</ul>
<p>Mejora del algoritmo de programaci√≥n: Este es otro camino de optimizaci√≥n que se puede tomar. No est√° dentro del Proveedor en s√≠.</p>
<p>En particular, los Dynamic Layouts o dise√±os din√°micos, permitir√°n que los programas de Cairo adapten los recursos seg√∫n sus necesidades. Esto puede llevar a una computaci√≥n m√°s eficiente y a una mejor utilizaci√≥n de los recursos. Los dise√±os din√°micos permiten a SHARP determinar los recursos necesarios para un trabajo espec√≠fico y ajustar el dise√±o en consecuencia en lugar de depender de dise√±os predefinidos con recursos fijos. Este enfoque puede proporcionar soluciones personalizadas para cada trabajo, mejorando la eficiencia general.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="componentes---sharp"><a class="header" href="#componentes---sharp">Componentes - SHARP</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="playground"><a class="header" href="#playground">Playground</a></h1>
<p>El Playground de Cairo es una herramienta que te permite crear y probar c√≥digos de Cairo de manera interactiva. Con esta plataforma, puedes desarrollar y probar tus programas de Cairo antes de implementarlos en una cadena de bloques.</p>
<p>El proceso de prueba en el Playground de Cairo consta de varios pasos. Primero, cuando escribes tu c√≥digo en Cairo, el Playground lo compila y ejecuta para crear un rastro de ejecuci√≥n. Este rastro se env√≠a a la red de Cairo para su evaluaci√≥n.</p>
<p>En la etapa de prueba, el sistema de Cairo, conocido como SHARP, recopila m√∫ltiples trazas de ejecuci√≥n de programas (incluso programas no relacionados) y los combina en un lote llamado &quot;tren&quot;. Al igual que un tren no sale de la estaci√≥n a pedido, el tren de Cairo puede tardar un tiempo en ser enviado al probador. SHARP esperar√° hasta acumular un lote lo suficientemente grande de trazas de programas o hasta que haya transcurrido cierto tiempo, lo que ocurra primero.</p>
<p>Una vez que se ha formado el tren de pruebas, SHARP env√≠a este conjunto al verificador en cadena (actualmente en Goerli). Para cada programa en el tren, el contrato SHARP registra un hecho en el Registro de hechos que certifica la validez de la ejecuci√≥n y su salida particular. Con esto, se cierra el ciclo y tu aplicaci√≥n en la cadena de bloques puede utilizar la salida del programa.</p>
<p>Durante todo este proceso, puedes monitorear el estado de tu trabajo haciendo clic en el enlace en el panel de salida del Playground. Se abrir√° una nueva pesta√±a que se actualizar√° autom√°ticamente y te mostrar√° en qu√© etapa se encuentra tu trabajo.</p>
<p>Adem√°s, puedes acceder al contrato compartido para ver el hecho de tu trabajo utilizando el m√©todo isValid().</p>
<div style="break-before: page; page-break-before: always;"></div><p>https://github.com/patrickbiel01/Cairo_Verifier</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quantum-leap"><a class="header" href="#quantum-leap">Quantum Leap</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="versiones"><a class="header" href="#versiones">Versiones</a></h1>
<p>Puede <a href="https://www.starknet.io/en/roadmap">consultar el roadmap</a> con cada uno de sus estados desde la p√°ginal oficial, les dejamos un resumen de lo m√°s importante.</p>
<p><strong>Versi√≥n 0.12.1:</strong> en esta versi√≥n se introdujo otra mejora significativa al incluir transacciones fallidas en el bloque. Anteriormente, en versiones anteriores a la 0.12, las transacciones fallidas no se inclu√≠an en el bloque, lo que resultaba en problemas para el Sequencer al no poder cobrar tarifas ni avanzar el nonce correspondiente a esas transacciones. Esta situaci√≥n generaba inconvenientes en la experiencia de usuario para los desarrolladores, ya que deb√≠an monitorear constantemente el estado de las transacciones antes de enviar nuevas transacciones, sin poder confiar en el avance del nonce. Con esta actualizaci√≥n, el Sequencer queda protegido de usuarios que intentan llenar el sistema con transacciones fallidas sin pagar por ellas.</p>
<p><strong>Versi√≥n 0.13:</strong> en este lanzamiento previsto en su hoja de ruta para 2023, tiene como objetivo reducir significativamente los costos de transacci√≥n mediante la introducci√≥n del modo Volition, lo que permitir√° una gama m√°s amplia de casos de uso y empoderando a los desarrolladores y usuarios. El compromiso de reducir costos se alinea con la misi√≥n de Starknet de proporcionar una infraestructura escalable, flexible y rentable para aplicaciones descentralizadas.</p>
<p>El modo Volition permitir√° a los desarrolladores construir aplicaciones con un enfoque h√≠brido de DA, que incorpora tanto datos en cadena como fuera de cadena.</p>
<p>Al aprovechar el modo Volition, Starknet prev√© una reducci√≥n dr√°stica en el costo de los datos. Se espera que esta reducci√≥n se logre a trav√©s de dos factores clave: la implementaci√≥n del EIP-4844 de Ethereum (Shard Blob Transaction) y la introducci√≥n de Volition en s√≠.</p>
<p><strong>Versi√≥n 0.14:</strong> en esta versi√≥n se introducir√° un mercado de tarifas, conocido como &quot;Fee Market&quot;, para mejorar la experiencia del usuario durante la congesti√≥n de la red. Actualmente, cuando hay congesti√≥n, los tiempos de espera de las transacciones aumentan para todos. Para abordar este problema, Starknet planea implementar un mercado de tarifas en la versi√≥n 0.14.0. Este mercado permitir√° asignar eficientemente los recursos limitados de Starknet en base a la disposici√≥n de los usuarios para pagar por una transacci√≥n, en lugar de simplemente seguir el orden de las transacciones en l√≠nea. El objetivo de este mercado de tarifas es proporcionar a los usuarios una experiencia m√°s predecible y fluida, incluso en momentos de alta actividad en la red.</p>
<p><strong>Versi√≥n 0.15:</strong> esta actualizaci√≥n permitir√° un mejor manejo de las transacciones fallidas, destacando especialmente la implementaci√≥n de Sierra para demostrar dichas transacciones. Esta adici√≥n garantiza una experiencia de red m√°s confiable y robusta al reducir la frecuencia de las transacciones fallidas y mejorar la eficiencia general del procesamiento de transacciones.</p>
<p>Adem√°s, Starknet aborda el problema de la variabilidad en los intervalos de bloque, que genera tiempos de espera impredecibles para las transacciones, a partir de la versi√≥n 0.15.0, se introducir√°n intervalos de bloque constantes y m√°s cortos.</p>
<p>Al desvincular la relaci√≥n 1:1 entre un bloque de Starknet y su prueba, las pruebas podr√°n verificar la integridad de uno o m√°s bloques de Starknet. Esta modificaci√≥n establecer√° intervalos de bloque fijos, lo que garantizar√° un comportamiento de red m√°s consistente y predecible. El objetivo de la introducci√≥n de intervalos de bloque m√°s cortos y fijos es mejorar significativamente la experiencia general del usuario en Starknet al reducir los tiempos de espera y permitir un procesamiento de transacciones m√°s fluido y eficiente.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-stack-1"><a class="header" href="#starknet-stack-1">Starknet Stack</a></h1>
<p>TL;DR (Too Long; Didn't Read):</p>
<p>El Stack de Starknet est√° experimentando un crecimiento vertiginoso y permitir√° lanzar tu propia instancia personalizada de Starknet para satisfacer tus necesidades. Starknet ya es la capa 2 m√°s eficiente en t√©rminos de rendimiento, con la comunidad de desarrolladores de m√°s r√°pido crecimiento y la pila Rollup m√°s descentralizada, que incluye infraestructura clave desarrollada por m√∫ltiples equipos independientes. Pronto se lanzar√° la primera Starknet Appchain en Mainnet.</p>
<p>Introducci√≥n:</p>
<p>Actualmente, hay un renacimiento de las cadenas p√∫blicas de capa 2 sobre Ethereum. Starknet, en particular, ha florecido con una comunidad de desarrolladores activos que abordan emocionantes casos de uso en juegos, DeFi, NFTs, IA y m√°s.</p>
<p>La necesidad de Appchains, cadenas de bloques espec√≠ficas de aplicaciones dise√±adas para satisfacer las necesidades de una aplicaci√≥n espec√≠fica, ha sido evidente durante varios a√±os y ahora est√° recibiendo una mayor atenci√≥n. La oferta de servicios SaaS de StarkWare, StarkEx, ha impulsado el √©xito de las Appchains de capa 2 m√°s exitosas en funcionamiento en Ethereum, como dYdX y Sorare. A la fecha (julio de 2023), StarkEx ha liquidado alrededor de $1 bill√≥n en operaciones acumuladas y procesado m√°s de 500 millones de transacciones. Las Appchains de Starknet son el entorno personalizado donde las aplicaciones pueden adaptar una instancia de Starknet para lograr un mayor control sobre las especificaciones, reducir costos, aumentar la escala y ofrecer privacidad opcional. El Stack de Starknet tiene como objetivo permitir que cualquier aplicaci√≥n despliegue su propia Appchain de Starknet de forma descentralizada.</p>
<p>El Stack de Starknet:</p>
<p>Los bloques de construcci√≥n de Starknet atraen a una amplia gama de aplicaciones y casos de uso, que incluyen pruebas STARK, el lenguaje de programaci√≥n Cairo y Abstracci√≥n de Cuenta nativa. Con la actualizaci√≥n de Starknet a la versi√≥n 0.12.0 en Mainnet, Starknet se convirti√≥ en la capa 2 m√°s eficiente en t√©rminos de TPS. Se espera que la ventaja de rendimiento de Starknet sobre otras capas 2 y, en particular, sobre las capas 2 compatibles con EVM, aumente con el tiempo, ya que Starknet no est√° limitado por las restricciones heredadas impuestas por el dise√±o e implementaci√≥n del EVM.</p>
<p>Sin embargo, es natural que algunas aplicaciones requieran ajustes adicionales a su plataforma. El Stack de Starknet les permitir√° hacerlo.</p>
<p>En l√≠nea con el ecosistema de Starknet, se busca mostrar primero y contar despu√©s. Pero dado el desarrollo electrizante dentro de nuestro ecosistema y el ritmo con el que evoluciona el Stack, hemos decidido ofrecer nuestra perspectiva actual sobre el Stack de Starknet. Los esfuerzos de desarrollo est√°n impulsados por el ecosistema de Starknet y orquestados por la Fundaci√≥n Starknet a trav√©s de sus colaboraciones de desarrollo.</p>
<p>Beneficios:</p>
<p>El Stack de Starknet permite a las aplicaciones crear sus propias Appchains personalizadas. Estas proporcionar√°n los beneficios gen√©ricos de las Appchains, como:</p>
<ul>
<li>Protecci√≥n contra la congesti√≥n en la red p√∫blica de Starknet, lo que permite a los usuarios obtener un mejor rendimiento y experiencia de usuario.</li>
<li>Las Appchains pueden implementar caracter√≠sticas que no son compatibles con la cadena p√∫blica, como su propia l√≥gica de mercado de tarifas. Desde la perspectiva de la red p√∫blica, estas nuevas caracter√≠sticas implementadas en las Appchains son valiosos experimentos. Implementarlas en una Appchain proporcionar√≠a conclusiones valiosas que podr√≠an aplicarse a otras Appchains o a la red p√∫blica.</li>
</ul>
<p>Adem√°s de estos beneficios, las Appchains de Starknet tendr√°n ventajas adicionales. Starknet es el rollup m√°s escalable, con la opci√≥n de configurar varios par√°metros, incluidos el consenso, los par√°metros de la cadena de bloques y la disponibilidad de datos.</p>
<p>Descentralizaci√≥n:</p>
<p>El Stack de Starknet se est√° convirtiendo r√°pidamente en la pila L2 m√°s descentralizada. Las blockchains sin permisos se centran en la descentralizaci√≥n como medio para lograr la seguridad y resiliencia de la red. La Fundaci√≥n Starknet est√° enfocada en lograr esta propiedad para Starknet.</p>
<p>&quot;Una pila descentralizada hace que la red sea m√°s segura, resiliente, transparente, escalable e innovadora. Sin un √∫nico punto de falla, sin dependencia de una √∫nica entidad, sin cajas negras y mucho m√°s constructores&quot;.</p>
<p>Diego Oliva
CEO, Starknet Foundation</p>
<p>&quot;Starknet est√° logrando la descentralizaci√≥n org√°nica de la pila: diferentes equipos est√°n produciendo versiones optimizadas de los componentes principales, que luego vuelven a las versiones oficiales (LambdaClass Rust VM) o crean completamente nuevos componentes&quot;.</p>
<p>Nicolas Bacca
Cofundador y CTO, Ledger</p>
<p>Madara:
Un ejemplo reciente de la descentralizaci√≥n del Stack de Starknet es el Secuenciador de Madara. Est√° basado en Substrate y, como tal, se basa en mecanismos de consenso descentralizados de forma nativa. El esfuerzo de desarrollo comunitario comenz√≥ en febrero de 2023. El esfuerzo de ingenier√≠a incluye a 45 desarrolladores de la comunidad, que hasta la fecha (julio de 2023) han realizado m√°s de 740 commits y m√°s de 400 solicitudes de extracci√≥n fusionadas. Este esfuerzo ha producido un Secuenciador compatible con Starknet p√∫blico, con un mempool configurable y m√°s.</p>
<p>LambdaClass:
Otro esfuerzo notable en la construcci√≥n de la pila que permitir√° el lanzamiento de Appchains de Starknet es el trabajo realizado por LambdaClass (que tambi√©n desempe√±√≥ un papel fundamental en las mejoras manifestadas en V0.12.0). LambdaClass est√° construyendo un Stack de Starknet que eventualmente incluir√° un probador, un secuenciador, un motor de ejecuci√≥n y un explorador de red. En un futuro cercano, estos diferentes componentes podr√≠an integrarse con otros componentes del Stack de Starknet y convertirse en una instancia funcional de Starknet.</p>
<p>Por la Comunidad, para la Comunidad:</p>
<p>El ecosistema de Starknet tiene como objetivo tener m√∫ltiples implementaciones de cada componente en el Stack. Aqu√≠ hay una muestra de los diferentes equipos y la infraestructura que est√°n desarrollando:</p>
<p>| Categor√≠a |	Proyecto | Entidad | Estado |
|Nodo completo | Pathfinder | Equilibrium |	En producci√≥n |
Juno	Nethermind	En producci√≥n
Papyrus	StarkWare	Pronto en producci√≥n
Deoxys	KasarLabs	En desarrollo
Motor de ejecuci√≥n	Blockifier	StarkWare	En producci√≥n
starknet_in_rust	LambdaClass	Pronto en producci√≥n
Secuenciador	SW Sequencer	StarkWare	En producci√≥n
Madara	Comunidad	En desarrollo
LC Sequencer	LambdaClass	En desarrollo
Probador	SW Prover	StarkWare	En producci√≥n
LC Prover	LambdaClass	En desarrollo
Sandstorm	Andrew Milson	En desarrollo</p>
<p>Adem√°s de los componentes principales del Stack, hay componentes y servicios complementarios importantes que son necesarios para ejecutar una Appchain (todos en producci√≥n, a menos que se indique lo contrario):</p>
<p>Exploradores de bloques: Starkscan, ViewBlock, Voyager y Explorer de LambdaClass (en desarrollo).
Indexadores: Apibara, Checkpoint, TokenFlow.
Servicios de API: Alchemy, Infura, Blast API, Lava y Chainstack.
Puentes: LayerSwap, Orbiter, StarkGate.
Pasarelas para monedas fiduciarias: Banxa, Ramp.
Billeteras: Argent, Braavos, Cartridge y Metamask‚Äôs Snap (llegar√° en sep 2023).
Marco de desarrollo de aplicaciones espec√≠fico de dominio: Dojo (juegos).
Or√°culos: Pragma y RedStone.</p>
<p>Expresividad:</p>
<p>El Stack de Starknet est√° impulsado por Cairo. Su √∫ltima versi√≥n, similar a Rust y ergon√≥mica, ha generado una tremenda emoci√≥n en la comunidad de desarrolladores.</p>
<p>&quot;Como alguien que nunca ha escrito Rust, lo aprend√≠ hace unas semanas y soy tan eficiente escribiendo contratos Cairo como Solidity. Agregue la capacidad de compartir l√≥gica entre contratos (¬°pr√≥ximamente!) y pruebas de fuzz incorporadas, y ser√° mi entorno preferido para escribir contratos inteligentes&quot;.</p>
<p>Moody Salem
Desarrollador principal de Solidity, Uniswap</p>
<p>Cairo, como un lenguaje de contrato inteligente de prop√≥sito general, con la ventaja adicional de producir c√°lculos demostrables, es utilizado por uno de los ecosistemas de desarrollo de blockchain de m√°s r√°pido crecimiento en la historia. Las aplicaciones pueden encontrar desarrolladores de Starknet con los que asociarse, contratar o externalizar.</p>
<p>&quot;El ecosistema de Starknet se siente como los primeros d√≠as de Ethereum. Atrae al mejor talento en el espacio con su enfoque descentralizado para el desarrollo e innovaci√≥n&quot;.</p>
<p>Itamar Lesuisse
Cofundador y CEO, Argent</p>
<p>El Camino por Delante:</p>
<p>El Stack de Starknet es un trabajo en progreso y continuar√° evolucionando y mejorando con el tiempo. Sin embargo, hoy en d√≠a, las Appchains de Starknet se pueden ejecutar como un servicio alojado, operado por StarkWare. De hecho, la primera Appchain de Starknet se lanzar√° pronto en una versi√≥n beta cerrada en Mainnet.</p>
<p>Esperamos que los equipos de desarrollo del ecosistema de Starknet, como LambdaClass, Nethermind y StarkWare, as√≠ como los proveedores de Rollup como servicio, ofrezcan servicios de alojamiento para las Appchains. Las Appchains elegir√°n qu√© componentes del Stack ejecutar por s√≠ mismas y cu√°les a trav√©s de un servicio de alojamiento (por ejemplo, SHARP de StarkWare). Pueden optar por depender de componentes de c√≥digo abierto estrictamente, o de tecnolog√≠a propietaria. Esta es la belleza de las Appchains: una talla √∫nica no sirve para todos. En cambio, cada aplicaci√≥n tomar√° sus propias decisiones √≥ptimas.</p>
<p>Las Appchains comenzaron como una capa 2 sobre Ethereum, pero no permanecer√°n all√≠ por mucho tiempo. En 2021, StarkWare introdujo el concepto de capa 3. Creemos que, para lograr una mayor escala y menor costo por transacci√≥n, las Appchains de Starknet migrar√°n a la capa 3 y, como tal, se ejecutar√°n sobre la red p√∫blica de Starknet.</p>
<p>Resumen:</p>
<p>El Stack de Starknet est√° experimentando un crecimiento notable. Esperamos que domine el espacio de las Appchains debido a su rendimiento, seguridad y expresividad. El pr√≥spero ecosistema de desarrolladores de Starknet, que ha impulsado la r√°pida evoluci√≥n de este Stack, continuar√° desarroll√°ndolo y satisfaciendo las diversas necesidades de m√°s y m√°s aplicaciones.</p>
<div style="break-before: page; page-break-before: always;"></div><p>https://starkware.co/resource/paradex-starknets-first-appchain/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-stack-2"><a class="header" href="#starknet-stack-2">Starknet Stack</a></h1>
<ol>
<li>
<p><strong>Client</strong>: Es el punto de inicio del ciclo. El cliente env√≠a transacciones de Starknet a trav√©s de la red.</p>
</li>
<li>
<p><strong>Sequencer</strong>: El secuenciador recibe las transacciones enviadas por el cliente y las organiza en bloques que contienen varias transacciones.</p>
</li>
<li>
<p><strong>Watcher-Prover</strong>: Este es un servicio que act√∫a en dos partes: el &quot;Watcher&quot; y el &quot;Prover&quot;.</p>
<ul>
<li><strong>Watcher</strong>: Monitorea la cadena de bloques en busca de bloques confirmados generados por el secuenciador.</li>
<li><strong>Prover</strong>: Genera pruebas (STARK proofs) para cada transacci√≥n dentro de los bloques confirmados. Para hacerlo, utiliza la &quot;Cairo VM&quot; para ejecutar los programas Cairo asociados con cada transacci√≥n y genera las trazas correspondientes.</li>
</ul>
</li>
<li>
<p><strong>Request blocks through RPC</strong>: Despu√©s de que el &quot;Watcher-Prover&quot; identifica un nuevo bloque con transacciones confirmadas, solicita los bloques al secuenciador a trav√©s de un protocolo de comunicaci√≥n remota llamado RPC (Remote Procedure Call).</p>
</li>
<li>
<p><strong>STARK proofs</strong>: Una vez que el &quot;Watcher-Prover&quot; tiene acceso a los bloques confirmados, genera pruebas STARK para cada transacci√≥n dentro de esos bloques utilizando la informaci√≥n obtenida de la ejecuci√≥n de los programas Cairo asociados con cada transacci√≥n.</p>
</li>
<li>
<p><strong>Proof Storage (Db)</strong>: Las pruebas STARK generadas se almacenan en una base de datos (Db) para su posterior uso y consulta. Es importante destacar que el estilo de l√≠nea (stroke-dasharray: 5) indica que esta conexi√≥n es de tipo almacenamiento, es decir, una conexi√≥n de datos m√°s permanente.</p>
</li>
<li>
<p><strong>Cairo Native</strong>: Es la ejecuci√≥n de los programas Cairo asociados con cada transacci√≥n dentro de los bloques confirmados. Estos programas son ejecutados en la &quot;Cairo Native&quot; para obtener resultados y trazas que se utilizar√°n para generar las pruebas STARK.</p>
</li>
<li>
<p><strong>Consensus (C)</strong>: Es la fase del ciclo en la que se realiza el proceso de consenso. Aqu√≠, se acuerda el orden y la validez de las transacciones dentro de los bloques, lo que garantiza que todos los nodos de la red est√©n de acuerdo con el estado actual de la cadena de bloques.</p>
</li>
<li>
<p><strong>Blockchain data</strong>: Una vez que el consenso se ha alcanzado y las transacciones se han confirmado, la informaci√≥n sobre los bloques y las transacciones se almacena en la cadena de bloques. En este punto, la informaci√≥n de la cadena de bloques est√° disponible para ser explorada y verificada.</p>
</li>
<li>
<p><strong>Explorer</strong>: Es una herramienta de exploraci√≥n y verificaci√≥n de la cadena de bloques. Permite a los usuarios navegar por los bloques y transacciones, as√≠ como verificar la validez de las pruebas STARK asociadas con las transacciones.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="watcherprover"><a class="header" href="#watcherprover">WatcherProver</a></h1>
<p>Este es el servicio de watcher-prover para el sistema de pruebas.</p>
<p>La arquitectura consiste en un watcher que monitorea la cadena de bloques en busca de bloques confirmados y un prover que genera pruebas para cada transacci√≥n del bloque. Puede conectarse a cualquier cadena de bloques que admita contratos inteligentes.</p>
<p>Cuando el watcher encuentra una nueva transacci√≥n con un programa, primero llama a <a href="https://github.com/lambdaclass/cairo-rs/">cairo-rs</a> para ejecutar el programa Cairo y generar la traza. Luego, esta traza se env√≠a al prover de Lambdaworks que crea la prueba. La prueba se coloca luego en un bloque posterior en la cadena de bloques.</p>
<p>Inicialmente, estas operaciones se realizar√°n de forma secuencial. Sin embargo, en el futuro, el objetivo es realizarlas en paralelo, escalando horizontalmente.</p>
<p>Al ejecutar los provers en paralelo, la capacidad del sistema de pruebas ser√° tan alta como la capacidad de la cadena de bloques. Sin embargo, existe una latencia del prover y la inclusi√≥n de las pruebas en los bloques.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-avalability"><a class="header" href="#data-avalability">Data Avalability</a></h1>
<p>En la etapa actual de Alpha, Starknet opera en modo ZK-Rollup. Esto significa que al aceptar una actualizaci√≥n de estado en la cadena, la diferencia de estado entre el estado anterior y el nuevo se env√≠a como datos de llamada (calldata) a Ethereum.</p>
<p>Estos datos permiten a cualquiera que observe Ethereum reconstruir el estado actual de Starknet.</p>
<p>Para actualizar el estado de Starknet en L1, es suficiente enviar una prueba v√°lida, sin informaci√≥n sobre las transacciones o los cambios particulares que caus√≥ esta actualizaci√≥n.</p>
<p>Consecuentemente, se debe proporcionar m√°s informaci√≥n para permitir que otras partes rastreen localmente el estado de Starknet.</p>
<p>Datos en la cadena: despu√©s de v0.11.0 Formato v0.11.0 Las diferencias de estado contienen informaci√≥n sobre cada contrato cuyo almacenamiento se ha actualizado, as√≠ como informaci√≥n adicional sobre los despliegues de contratos.</p>
<p>Para cada contrato afectado, tenemos:</p>
<ul>
<li><strong>La direcci√≥n del contrato</strong></li>
<li><strong>Una sola palabra que codifica:</strong>
<ul>
<li>Un indicador de informaci√≥n de clase (0 = solo actualizaciones de almacenamiento / 1 = el contrato fue desplegado o reemplazado en esta actualizaci√≥n de estado). Cuando este indicador est√° activado, habr√° una palabra adicional antes de la secci√≥n de actualizaciones de almacenamiento, que contiene el nuevo hash de clase.</li>
</ul>
</li>
<li><strong>Nonce</strong></li>
<li><strong>num_of_storage_updates</strong> (n√∫mero de actualizaciones de almacenamiento).</li>
</ul>
<p>A continuaci√≥n se muestra </p>
<p><img src="./assets/state.png" alt="graph" /></p>
<div align="center">
<em>As√≠ debe de ser el formato esperado</em>
</div>
<p>Para cada actualizaci√≥n de almacenamiento:</p>
<ul>
<li><strong>clave:</strong> la direcci√≥n dentro del almacenamiento del contrato donde se actualiza el valor</li>
<li><strong>valor:</strong> el nuevo valor</li>
</ul>
<p>A continuaci√≥n, se proporciona informaci√≥n sobre las clases declaradas y el n√∫mero de clases (Cairo 1.0) presentes en el bloque.</p>
<p>Para cada clase, se incluyen los siguientes detalles:</p>
<ol>
<li>Hash de la clase.</li>
<li>Hash de la clase compilada.</li>
</ol>
<h2 id="ejemplos-despu√©s-la-v0110"><a class="header" href="#ejemplos-despu√©s-la-v0110">Ejemplos despu√©s la v0.11.0</a></h2>
<p>A continuaci√≥n, mostramos un ejemplo de datos en la cadena que se extrajeron de L1 y procedemos a decodificarlo seg√∫n el formato mencionado anteriormente.</p>
<pre><code class="language-bash">[
1,
2019172390095051323869047481075102003731246132997057518965927979101413600827,
18446744073709551617,
100,
200,
1,
1351148242645005540004162531550805076995747746087542030095186557536641755046,
558404273560404778508455254030458021013656352466216690688595011803280448032
]
</code></pre>
<ul>
<li>El primer elemento <code>1</code>, es el n√∫mero de contratos cuyo estado se actualiz√≥.</li>
<li>El segundo elemento, <code>2019172390095051323869047481075102003731246132997057518965927979101413600827</code>, es la direcci√≥n del primer (y √∫nico) contrato cuyo estado cambi√≥, recordamos que es un felt su expresi√≥n hexadecimal ser√≠a <code>0x0476cfa27c83ea2498c4fb61972c2b80d2b1cd500986a881ec3c4e5b4f726e3b</code>.</li>
<li>El tercer elemento, 18446744073709551617, que es 2^64+1, codifica lo siguiente:
<ul>
<li>El indicador de informaci√≥n de clase es 0, es decir, el contrato no se despleg√≥ ni se reemplaz√≥, por lo que no debemos tratar la siguiente palabra como el hash de clase.</li>
<li>El nuevo nonce es 1.</li>
<li>Se actualiz√≥ una celda de almacenamiento.</li>
</ul>
</li>
<li>Los dos elementos siguientes, <code>100</code> y <code>200</code>, codifican la actualizaci√≥n de almacenamiento (el valor de la clave 100 se estableci√≥ en 200).</li>
<li>A continuaci√≥n, tenemos la secci√≥n de declaraciones nuevas: <code>1</code> significa que tuvimos una √∫nica declaraci√≥n v2 en esta actualizaci√≥n de estado, y los dos elementos siguientes, codifican el <code>class hash</code> y el <code>class hash compile</code> del <code>class declare</code>.</li>
</ul>
<h2 id="formato-anterior-a-la-011"><a class="header" href="#formato-anterior-a-la-011">Formato Anterior a la 0.11</a></h2>
<p>Las state diffs contienen informaci√≥n sobre cada contrato cuyo storage se ha actualizado, as√≠ como informaci√≥n adicional sobre los despliegues de contratos. Esas diferencias se env√≠an como un arreglo uint256[] como parte de los datos de llamada (calldata), y se codifican de la siguiente manera:</p>
<ul>
<li>N√∫mero de celdas que codifican los despliegues de contratos.</li>
<li>Para cada contrato desplegado, tenemos:
<ul>
<li>contract_address: la direcci√≥n del contrato desplegado.</li>
<li>contract_hash: el hash de la clase.</li>
</ul>
</li>
<li>N√∫mero de contratos cuyo almacenamiento se actualiza.</li>
<li>Para cada contrato de ese tipo, tenemos:
<ul>
<li>contract_address: la direcci√≥n del contrato.</li>
<li>num_of_storage_updates: el n√∫mero de actualizaciones de almacenamiento.</li>
<li>nonce,ŒΩmofs‚Üíra‚â•actualizaciones: un valor uint256 que codifica tanto el n√∫mero de actualizaciones de almacenamiento para ese contrato como el nonce actualizado:</li>
</ul>
</li>
</ul>
<p><img src="./assets/state1.png" alt="graph" /></p>
<div align="center">
<em>As√≠ era el formato esperado antes de 0.11</em>
</div>
<ul>
<li>Para cada actualizaci√≥n de almacenamiento:
<ul>
<li>clave: la direcci√≥n dentro del almacenamiento del contrato donde se actualiza el valor</li>
<li>valor: el nuevo valor</li>
</ul>
</li>
</ul>
<h2 id="ejemplos-antes-la-v0110"><a class="header" href="#ejemplos-antes-la-v0110">Ejemplos antes la v0.11.0</a></h2>
<p>A continuaci√≥n, mostramos un ejemplo de datos en cadena que se extrajeron de L1 y se decodificaron seg√∫n el formato anterior.</p>
<pre><code class="language-bash">[
2,
2472939307328371039455977650994226407024607754063562993856224077254594995194,
1336043477925910602175429627555369551262229712266217887481529642650907574765,
5,
2019172390095051323869047481075102003731246132997057518965927979101413600827,
18446744073709551617,
5,
102,
2111158214429736260101797453815341265658516118421387314850625535905115418634,
2,
619473939880410191267127038055308002651079521370507951329266275707625062498,
1471584055184889701471507129567376607666785522455476394130774434754411633091,
619473939880410191267127038055308002651079521370507951329266275707625062499,
541081937647750334353499719661793404023294520617957763260656728924567461866,
2472939307328371039455977650994226407024607754063562993856224077254594995194,
1,
955723665991825982403667749532843665052270105995360175183368988948217233556,
2439272289032330041885427773916021390926903450917097317807468082958581062272,
3429319713503054399243751728532349500489096444181867640228809233993992987070,
1,
5,
1110,
3476138891838001128614704553731964710634238587541803499001822322602421164873,
6,
59664015286291125586727181187045849528930298741728639958614076589374875456,
600,
221246409693049874911156614478125967098431447433028390043893900771521609973,
400,
558404273560404778508455254030458021013656352466216690688595011803280448030,
100,
558404273560404778508455254030458021013656352466216690688595011803280448031,
200,
558404273560404778508455254030458021013656352466216690688595011803280448032,
300,
1351148242645005540004162531550805076995747746087542030095186557536641755046,
500
]
</code></pre>
<ul>
<li>El primer elemento <code>2</code>, es el n√∫mero de celdas que codifican la implementaci√≥n de contratos.</li>
<li>Los dos siguientes elementos describen una √∫nica implementaci√≥n de contrato con los siguientes par√°metros:
<ul>
<li>direcci√≥n_contrato:</li>
</ul>
</li>
</ul>
<pre><code class="language-bash">2472939307328371039455977650994226407024607754063562993856224077254594995194
</code></pre>
<ul>
<li>hash_contrato:</li>
</ul>
<pre><code class="language-bash">2472939307328371039455977650994226407024607754063562993856224077254594995194
</code></pre>
<ul>
<li>El siguiente elemento <code>5</code> (√≠ndice 3 en el array), es el n√∫mero de contratos cuyo almacenamiento se actualiz√≥. Tomaremos solo el primer contrato como ejemplo.
<ul>
<li>direcci√≥n_contrato:</li>
</ul>
</li>
</ul>
<pre><code class="language-bash">2019172390095051323869047481075102003731246132997057518965927979101413600827
</code></pre>
<ul>
<li>Despu√©s de la direcci√≥n de contrato mencionada anteriormente, tenemos <code>18446744073709551617</code> (√≠ndice 8 en el array), que es <code>2^64+1</code> , por lo tanto:
<ul>
<li>El nuevo nonce del contrato es 1.</li>
<li>Se actualiza una clave de almacenamiento.</li>
<li>El valor en la clave 5 se cambi√≥ a 102.</li>
</ul>
</li>
</ul>
<p>Las siguientes 4 actualizaciones de almacenamiento de contratos se interpretan de la misma manera.</p>
<p>Extracci√≥n desde Ethereum Los datos descritos anteriormente se env√≠an a trav√©s de varias transacciones de Ethereum, cada una de las cuales contiene una parte de esta matriz como calldata. Cada nuevo bloque de Starknet tiene sus transacciones de difusi√≥n de estado asociadas.</p>
<p>Puede encontrar <a href="https://github.com/eqlabs/pathfinder/blob/2fe6f549a0b8b9923ed7a21cd1a588bc571657d6/crates/pathfinder/src/ethereum/state_update/retrieve.rs">el c√≥digo para extraer estos datos</a> de Ethereum en el repositorio de Pathfinder.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evm-vs-zkevm"><a class="header" href="#evm-vs-zkevm">EVM vs zkEVM</a></h1>
<p>El desaf√≠o central con el enfoque zkEVM est√° enraizado en el plan original de EVM, este no fue dise√±ado para funcionar dentro de un contexto de prueba de validez. En consecuencia, los esfuerzos para reflejar su funcionalidad no logran desbloquear todo el potencial de las pruebas de validez, lo que resulta en una eficiencia menos que √≥ptima. Tal ineficiencia finalmente pesa el rendimiento general del sistema. </p>
<p>La compatibilidad del EVM con las pruebas de validez se ve obstaculizada por los siguientes factores:</p>
<ul>
<li>
<p>El EVM emplea un modelo basado en apilamiento, mientras que las pruebas de validez se emplean de manera m√°s efectiva con un modelo basado en registros. La naturaleza basada en la pila del EVM hace que sea inherentemente m√°s dif√≠cil demostrar la exactitud de su ejecuci√≥n y proporcionar soporte directo para su cadena de herramientas nativa.</p>
</li>
<li>
<p>El dise√±o de almacenamiento Ethereum depende en gran medida de Keccak y un gran √°rbol Merkle Patricia, que no son amigables con Validity Proof e imponen una carga de prueba sustancial. Por ejemplo, Keccak es muy r√°pido para las arquitecturas x86 ( sobre las cuales generalmente ejecutamos el EVM ), pero toma 90k pasos para probar ( con una construcci√≥n especial incorporada ). Mientras que Pedersen ( una funci√≥n hash amigable con zk ) da 32 pasos. Incluso con compresi√≥n recursiva, el uso de Keccak en un zkEVM significa altos recursos de prover que terminan siendo pagados por el usuario.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kakarot---bases-de-su-arquitectura"><a class="header" href="#kakarot---bases-de-su-arquitectura">Kakarot - Bases de su arquitectura</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vm-de-cairo"><a class="header" href="#vm-de-cairo">VM de Cairo</a></h1>
<p>La M√°quina Virtual Cairo (CVM) es un componente esencial del lenguaje de programaci√≥n Cairo, utilizado para desarrollar y ejecutar contratos inteligentes en la cadena de bloques. Su arquitectura eficiente y sofisticada permite una gesti√≥n avanzada de la memoria, validaci√≥n de instrucciones y deducci√≥n de valores.</p>
<p>La CVM forma el n√∫cleo del lenguaje Cairo, brindando capacidades avanzadas de ejecuci√≥n de contratos inteligentes y permitiendo el desarrollo de aplicaciones descentralizadas seguras y eficientes en la cadena de bloques. Su dise√±o t√©cnico y eficiente hace posible la ejecuci√≥n de programas complejos y la validaci√≥n precisa de memoria, garantizando la confiabilidad y precisi√≥n en la ejecuci√≥n de los contratos inteligentes.</p>
<p>A continuaci√≥n, se detalla su funcionamiento y estructura t√©cnica:</p>
<h2 id="gesti√≥n-de-memoria-y-segmentos"><a class="header" href="#gesti√≥n-de-memoria-y-segmentos">Gesti√≥n de Memoria y Segmentos</a></h2>
<p>La memoria de Cairo es de solo lectura, y las direcciones de memoria que el programa accede deben ser continuas. Los posibles huecos entre las direcciones son llenados con valores arbitrarios.</p>
<p>La memoria se organiza en segmentos continuos, cuyo tama√±o var√≠a y solo se conoce al finalizar la ejecuci√≥n del programa. Las direcciones absolutas de cada celda dentro de un segmento se determinan utilizando valores <code>Relocatable</code>, que indican el n√∫mero de segmento y el desplazamiento.</p>
<p>Los diferentes segmentos son:</p>
<ol>
<li><strong>Segmento del Programa:</strong> Contiene el bytecode de Cairo, con el <code>Program Counter (pc)</code> iniciando al principio de este segmento.</li>
<li><strong>Segmento de Ejecuci√≥n:</strong> Aqu√≠ se generan datos durante la ejecuci√≥n del programa Cairo y su longitud es variable seg√∫n la entrada del programa. Los <code>Allocation Pointer (ap)</code> y <code>Frame Pointer (fp)</code> comienzan aqu√≠.</li>
<li><strong>Segmento Incorporado:</strong> Cada funci√≥n incorporada tiene su propio espacio continuo en memoria. La longitud es variable.</li>
</ol>
<h2 id="registros"><a class="header" href="#registros">Registros</a></h2>
<p>Los registros son fundamentales para el funcionamiento de la M√°quina Virtual Cairo:</p>
<ol>
<li><strong>Allocation Pointer (ap):</strong> Apunta a una celda de memoria sin usar.</li>
<li><strong>Frame Pointer (fp):</strong> Apunta al marco de la funci√≥n actual. Las direcciones de todas las variables locales y argumentos son relativas al valor de este registro. Al inicio de una <strong>function1</strong>, <code>fp</code> es igual a <code>ap</code> y permanece constante durante su ejecuci√≥n. Cuando una <strong>function2</strong> se llama dentro de una <strong>function1</strong>, el valor de <code>fp</code> cambia para <strong>function2</strong> pero se restaura a su valor original al finalizar <strong>function2</strong> (esto permite rastrear el valor original de <strong>function1</strong>).</li>
<li><strong>Program Counter (pc):</strong> Apunta a la instrucci√≥n actual. Cada instrucci√≥n toma 1 o 2 <code>felts</code>, y <code>pc</code> avanza 1 o 2 despu√©s de cada instrucci√≥n. Los saltos pueden cambiar el valor del <code>pc</code> a un valor absoluto o relativo, seg√∫n las operaciones de salto.</li>
</ol>
<h2 id="validaci√≥n-y-deducci√≥n-de-valores"><a class="header" href="#validaci√≥n-y-deducci√≥n-de-valores">Validaci√≥n y Deducci√≥n de Valores</a></h2>
<p>La M√°quina Virtual Cairo es capaz de deducir valores de memoria y validar la ejecuci√≥n de instrucciones para asegurar la integridad y correctitud del programa. Utiliza pruebas recursivas para optimizar y paralelizar la ejecuci√≥n, lo que mejora la eficiencia y escalabilidad del sistema.</p>
<h2 id="jerarqu√≠a-de-estructuras"><a class="header" href="#jerarqu√≠a-de-estructuras">Jerarqu√≠a de Estructuras</a></h2>
<p>La M√°quina Virtual Cairo se basa en una jerarqu√≠a de estructuras que permiten un manejo complejo de la memoria y las operaciones:</p>
<ol>
<li><strong><code>VirtualMachineBase</code>:</strong> Proporciona la base para la M√°quina Virtual Cairo, con atributos importantes como el contexto de ejecuci√≥n, registros, funciones incorporadas y m√°s.</li>
<li><strong><code>ValidatedMemoryDict</code>:</strong> Contiene una memoria validada con reglas de validaci√≥n y auto-deducci√≥n de valores.</li>
<li><strong><code>auto_deduction</code></strong>: Es un diccionario que mapea un √≠ndice de memoria segmento a una lista de reglas para deducir el valor de una celda de memoria.</li>
</ol>
<h2 id="representaci√≥n-del-programa"><a class="header" href="#representaci√≥n-del-programa">Representaci√≥n del Programa</a></h2>
<p>El programa Cairo se representa mediante la estructura <code>ProgramBase</code>, que contiene informaci√≥n sobre funciones, referencias, constantes y otros elementos del programa. Esta estructura es serializable, lo que facilita su almacenamiento y distribuci√≥n en la cadena de bloques.</p>
<h2 id="air-y-builtins"><a class="header" href="#air-y-builtins">AIR y Builtins</a></h2>
<p>Profundizaremos en la arquitectura de la CVM y su funcionamiento a nivel de ejecutar AIR, optimizaciones usando builtins, instrucciones y sus dise√±os para mejorar pasos y potenciar sus funciones. En ellos, estar√° c√≥mo se organizan los dise√±os lineales o din√°micos para optimizar el rendimiento de un programa de Cairo, y revisaremos las celdas traza.</p>
<p>Este conjunto minimalista de instrucciones se denomina <code>RISC algebraico</code> (Computadora de conjunto de instrucciones reducidas); <code>Algebraico</code> se refiere al hecho de que las operaciones admitidas son operaciones de campo. El uso de un <code>RISC algebraico</code> nos permite construir un AIR para Cairo con solo 51 celdas traza por paso.</p>
<p>Uno de los mejores ejemplos es <a href="https://www.risczero.com/">RISC Zero</a>, que detallaremos m√°s en otras arquitecturas. B√°sicamente, <code>RISC Zero zkVM</code> es un ordenador verificable que funciona como un microprocesador <code>RISC-V</code> real integrado, lo que permite a los programadores escribir pruebas ZK como si escribieran cualquier otro c√≥digo. Tambi√©n destaca que soporta Rust para escribir pruebas ZK y puede admitir cualquier lenguaje que compile en RISC-V.</p>
<h3 id="builtin"><a class="header" href="#builtin">Builtin</a></h3>
<p>Los builtins son unidades de ejecuci√≥n de bajo nivel optimizadas predefinidas que se agregan a la placa de la CPU de Cairo para realizar c√°lculos predefinidos que son costosos de realizar en vainilla Cairo (por ejemplo, verificaciones de rango, hash de Pedersen, ECDSA, ...).</p>
<p>Poseidon es una familia de funciones hash dise√±adas para ser muy eficientes como circuitos algebraicos. Como tales, pueden ser muy √∫tiles en sistemas de prueba ZK como STARK y otros.</p>
<p>La comunicaci√≥n entre la CPU y los builtins se realiza a trav√©s de la memoria: a cada builtin se le asigna un √°rea continua en la memoria y aplica algunas restricciones (dependiendo de la definici√≥n del builtin) en las celdas de memoria en esa √°rea. En t√©rminos de construcci√≥n del AIR, significa que agregar builtins no afecta las restricciones de la CPU. Simplemente significa que la misma memoria se comparte entre la CPU y los builtins.</p>
<p>Para <code>invocar</code> un builtin, el programa de Cairo <code>se comunica</code> con ciertas celdas de memoria, y el builtin impone algunas restricc</p>
<p>iones en esas celdas de memoria.</p>
<p><strong>Gas por builtin:</strong> <a href="https://docs.starknet.io/documentation/architecture_and_concepts/Fees/fee-mechanism/#general_case">Mecanismo de tarifas</a></p>
<p><strong>VM CPU AIR:</strong> Circuitos integrados en Cairo, no hace falta Circom, la aritm√©tica se hace nativa con builtins, Dynamic layout (bosque oscuro...).</p>
<p>Desde Lambda se hicieron pruebas para exportar Circom, Snark, Groth16, Plonk.</p>
<p>Circom: <a href="https://github.com/lambdaclass/circom_export_to_cairo">Export to Cairo</a></p>
<p>Vm en Rust con sequencer en Rust, mejoras de 10x (lanzado en v.0.12 haremos pruebas TPS y MPS en el explorador) posible consenso BFT.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtins-y-mecanismos-de-fee"><a class="header" href="#builtins-y-mecanismos-de-fee">Builtins y Mecanismos de Fee</a></h1>
<p>En esta secci√≥n, revisaremos el mecanismo de tarifas de Starknet Alpha. Si desea omitir la motivaci√≥n y profundizar en el mecanismo.</p>
<p>Los usuarios pueden especificar la m√°xima tarifa que est√°n dispuestos a pagar por una transacci√≥n a trav√©s del campo <code>max_fee</code>.</p>
<p>La √∫nica limitaci√≥n en el secuenciador (impuesta por Starknet OS) es que la tarifa real cobrada est√° acotada por <code>max_fee</code>, pero por ahora, StarkWare‚Äôs secuenciador solo cobrar√° la tarifa requerida para cubrir el costo de la prueba (potencialmente menos que la tarifa m√°xima).</p>
<p>Actualmente, el secuenciador solo tiene en cuenta los costos de L1 relacionados con la presentaci√≥n de la prueba. Hay dos componentes que afectan el rastro de L1 de una transacci√≥n:</p>
<ol>
<li>
<p><strong>Complejidad computacional</strong>: cuanto m√°s pesada sea la transacci√≥n, mayor ser√° su parte en el costo de verificaci√≥n de la prueba.</p>
</li>
<li>
<p><strong>Datos en cadena</strong>: costo de datos de L1 originados por la disponibilidad de datos y mensajes de L2 ‚Üí L1.</p>
</li>
</ol>
<p>Las unidades de tarif est√°n denominadas en <strong>ETH</strong>, <em>(esto puede cambiar en versiones futuras)</em>. Cada transacci√≥n est√° asociada con una estimaci√≥n de gas, y al combinar esto con el precio del gas, se obtiene la tarifa estimada.</p>
<h2 id="descripci√≥n-general-de-alto-nivel"><a class="header" href="#descripci√≥n-general-de-alto-nivel">Descripci√≥n general de alto nivel</a></h2>
<p>Analicemos la m√©trica correcta para medir la complejidad de una transacci√≥n. Para simplificar, ignoraremos las funciones incorporadas de Cairo con fines de explicaci√≥n, y luego veremos c√≥mo abordarlas.</p>
<h3 id="sin-builtins-incorporados"><a class="header" href="#sin-builtins-incorporados">Sin builtins incorporados</a></h3>
<p>Recordemos que la ejecuci√≥n de un programa Cairo produce una traza de ejecuci√≥n. Al probar un bloque de Starknet, agregamos todas las transacciones que aparecen en ese bloque a la traza de ejecuci√≥n.</p>
<p>El Prover de Starknet genera pruebas para trazas de ejecuci√≥n, con una longitud m√°xima <strong><code>L</code></strong>, derivada de las especificaciones de la m√°quina de pruebas y la latencia de la prueba deseada.</p>
<p>Es sencillo hacer un seguimiento de la longitud de la traza de ejecuci√≥n asociada con cada transacci√≥n. Cada operaci√≥n sobre field elements <em>(como verificar la suma/multiplicaci√≥n sobre el field)</em> requiere el mismo n√∫mero constante de celdas de traza (trace cells). </p>
<p>Cuando mencionamos <strong>sin builtin incorporados</strong> nos referimos a un escenario en el que todas las operaciones en el programa Cairo son operaciones b√°sicas y no implican el uso de funciones m√°s complejas, como las que encontramos <strong>con builtin incorporados</strong>. En esta situaci√≥n, la ejecuci√≥n de una operaci√≥n simple, como una suma, requerir√° menos celdas de traza que una operaci√≥n m√°s compleja como la funci√≥n Pedersen. Es evidente que la funci√≥n Pedersen ocupar√° m√°s celdas de traza debido a su naturaleza m√°s compleja en comparaci√≥n con una simple suma.</p>
<h3 id="con-builtins-incorporados"><a class="header" href="#con-builtins-incorporados">Con builtins incorporados</a></h3>
<p>La traza de ejecuci√≥n de Cairo est√° separada, y cada builtin incorporado tiene su propia ranura. Debemos tener en cuenta esta asignaci√≥n de ranura al determinar la tarifa.</p>
<p>Repasemos primero un ejemplo concreto. Imagina que la traza de ejecuci√≥n tiene una capacidad m√°xima que ocupar√° el Prover:</p>
<ul>
<li>500.000.000 pasos de Cairo</li>
<li>20.000.000 hashes de Pedersen</li>
<li>4.000.000 verificaciones de firma</li>
<li>10.000.000 comprobaciones de rango</li>
</ul>
<p>La prueba se cerrar√° y se enviar√° a L1 cuando cualquiera de estos componentes se llene. </p>
<blockquote>
<p>Es importante darse cuenta de que la divisi√≥n en funciones incorporadas debe estar predeterminada. No podemos decidir sobre la marcha tener una prueba con <strong>20.000.001 Pedersen</strong>.</p>
</blockquote>
<p>Supongamos, por ejemplo, que una transacci√≥n utiliza <strong>10.000 pasos de Cairo</strong> y <strong>500 hashes de Pedersen</strong>. Podemos acomodar como m√°ximo <strong>40.000 transacciones</strong> de este tipo en nuestro rastro hipot√©tico <strong>(20.000.000/500)</strong>. Por lo tanto, la tarifa de la transacci√≥n se relaciona con <strong>1/40.000</strong> del costo de enviar la prueba.</p>
<p>Es importante notar que el n√∫mero de pasos de Cairo no es el factor limitante en esta estimaci√≥n del rendimiento de la transacci√≥n <em>(ya que <strong>500,000,000/10,000 &gt; 20,000,000/500</strong>)</em>. Con este ejemplo en mente, ahora podemos formular la tarifa exacta asociada con el c√≥mputo de L2.</p>
<h3 id="caso-general"><a class="header" href="#caso-general">Caso general</a></h3>
<p>Para cada transacci√≥n, el secuenciador calcula un vector <code>CairoResourceUsage</code> que contiene:</p>
<ul>
<li>N√∫mero de pasos de Cairo</li>
<li>N√∫mero de aplicaciones de cada funci√≥n incorporada de Cairo (por ejemplo, cinco comprobaciones de rango y dos hashes de Pedersen)</li>
</ul>
<p>El secuenciador cruza esta informaci√≥n con el vector <code>CairoResourceFeeWeights</code>. Para cada tipo de recurso (paso o una aplicaci√≥n espec√≠fica de funci√≥n incorporada), <code>CairoResourceFeeWeights</code> tiene una entrada que especifica el costo de gas relativo de ese componente en la prueba.</p>
<p>Volviendo al ejemplo anterior, si el costo de enviar una prueba con <strong>20.000.000 hashes de Pedersen</strong> es aproximadamente <strong>5m</strong> de gas, entonces el n√∫mero de pasos de la funci√≥n incorporada de Pedersen es <strong>0.2 gas</strong> por aplicaci√≥n (<strong>5,000,000/20,000,000</strong>). El secuenciador tiene un vector de pasos predefinidos, de acuerdo con los par√°metros de la prueba.</p>
<p>El secuenciador cobrar√° solo seg√∫n el factor limitante. Por lo tanto, la tarifa est√° correlacionada con:</p>
<p><img src="./assets//Fee.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Donde <code>k</code> enumera los componentes de recursos de Cairo, es decir, el n√∫mero de pasos y funciones incorporadas utilizados.</p>
<p>Los pasos son:</p>
<ul>
<li><strong>Paso de Cairo:</strong> 0.01 gas/paso</li>
<li><strong>Pedersen:</strong> 0.32 gas/aplicaci√≥n</li>
<li><strong>Poseidon:</strong> 0.32 gas/aplicaci√≥n</li>
<li><strong>Comprobaci√≥n de rango:</strong> 0.16 gas/aplicaci√≥n</li>
<li><strong>ECDSA:</strong> 20.48 gas/aplicaci√≥n</li>
<li><strong>Bitwise:</strong> 0.64 gas/aplicaci√≥n</li>
<li><strong>EC_OP:</strong> 10.24 gas/aplicaci√≥n</li>
</ul>
<h2 id="datos-on-chain"><a class="header" href="#datos-on-chain">Datos On-Chain</a></h2>
<p>Los datos en cadena asociados con una transacci√≥n est√°n compuestos por tres partes:</p>
<ul>
<li>Actualizaciones de Storage.</li>
<li>Mensajes L2 ‚Üí L1.</li>
<li>Contratos implementados.</li>
</ul>
<h3 id="actualizaciones-de-storage"><a class="header" href="#actualizaciones-de-storage">Actualizaciones de Storage</a></h3>
<p>Cuando una transacci√≥n actualiza una clave en el almacenamiento de alg√∫n contrato, los siguientes datos llegan a L1:</p>
<ul>
<li>Contract_address</li>
<li>N√∫mero de claves actualizadas en ese contrato</li>
<li>Clave para actualizar</li>
<li>Nuevo valor</li>
</ul>
<blockquote>
<p>Nota: Solo el valor m√°s reciente llega a L1. Es decir, la tarifa de la transacci√≥n solo depende del n√∫mero de actualizaciones de storage √∫nicas (si la misma celda de storage se actualiza varias veces dentro de la transacci√≥n, la tarifa sigue siendo la de una √∫nica actualizaci√≥n).</p>
</blockquote>
<p>La tarifa de actualizaci√≥n de storage asociada para una transacci√≥n que actualiza <code>n</code> contratos √∫nicos y <code>m</code> claves √∫nicas es:</p>
<p><img src="./assets//Fee1.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Donde <code>cw</code> es el costo de <code>calldata</code> (en gas) por palabra de 32 bytes.</p>
<blockquote>
<p>Nota: Hay muchas posibles mejoras a la estimaci√≥n pesimista anterior que se presentar√°n gradualmente en futuras versiones de Starknet. Por ejemplo, si diferentes transacciones dentro del mismo bloque actualizan la misma celda de almacenamiento, no es necesario cobrar ambas (solo el valor m√°s reciente llega a L1). En el futuro, Starknet podr√≠a incluir un mecanismo de reembolso para tales casos.</p>
</blockquote>
<h3 id="mensajes-l2--l1"><a class="header" href="#mensajes-l2--l1">Mensajes L2 ‚Üí L1</a></h3>
<p>Cuando se realiza una transacci√≥n que invoca la llamada del sistema <code>send_message_to_l1</code> y se incluye en una actualizaci√≥n de estado, los siguientes datos llegan a la capa L1 (capa de destino):</p>
<ol>
<li>
<p><strong>L2 sender address:</strong> Es la direcci√≥n del remitente en la capa L2, es la direcci√≥n de la entidad o contrato en la capa 2 que inici√≥ la transacci√≥n o envi√≥ el mensaje.</p>
</li>
<li>
<p><strong>L1 destination address:</strong> Es la direcci√≥n de destino en la capa L1. Esta direcci√≥n indica el contrato o entidad en la capa 1 que recibir√° el mensaje enviado desde la capa 2.</p>
</li>
<li>
<p><strong>Payload size:</strong> Es el tama√±o del contenido √∫til o informaci√≥n que se env√≠a en el mensaje. Representa la cantidad de datos que se transmiten desde la capa 2 a la capa 1.</p>
</li>
<li>
<p><strong>Payload <em>(lista de field element)</em>:</strong> Es la lista de elementos o datos que constituyen el contenido √∫til o payload del mensaje enviado desde la capa 2 a la capa 1.</p>
</li>
</ol>
<p>En cuanto a la tarifa asociada con un solo mensaje de la capa L2 a la capa L1, se calcula utilizando la siguiente f√≥rmula:</p>
<p><img src="./assets//Fee2.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Donde:</p>
<ul>
<li><code>gas_price</code> es el precio del gas (unidad de costo) establecido en la transacci√≥n.</li>
<li><code>cw</code> es el costo de calldata (datos de llamada) en gas por palabra de 32 bytes.</li>
<li><code>payload_size</code> es el tama√±o del contenido √∫til o payload del mensaje en bytes.</li>
</ul>
<p>Esta f√≥rmula te permite determinar el costo total de enviar un mensaje desde la capa L2 a la capa L1, tomando en cuenta el precio del gas, el costo de calldata y el tama√±o del contenido enviado.</p>
<h3 id="contratos-implementados"><a class="header" href="#contratos-implementados">Contratos implementados</a></h3>
<p>Cuando una transacci√≥n que eleva la llamada del sistema <code>deploy</code> se incluye en una actualizaci√≥n de estado, los siguientes datos llegan a L1:</p>
<ul>
<li><strong>Direcci√≥n del contrato.</strong></li>
<li><strong>Class Hash.</strong></li>
</ul>
<p>La tarifa asociada con una implementaci√≥n √∫nica es:</p>
<p><img src="./assets//Fee3.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Donde <code>cw</code> es el costo de calldata (en gas) por palabra de 32 bytes.</p>
<h2 id="tarifa-total"><a class="header" href="#tarifa-total">Tarifa total</a></h2>
<p>La tarifa para una transacci√≥n con:</p>
<ul>
<li>La utilizaci√≥n de Cairo se representa mediante el vector <code>v</code>, donde las entradas de <code>v</code> corresponden al n√∫mero de pasos y al n√∫mero de aplicaciones por builtin incorporado.</li>
<li><code>n</code> actualizaciones de contratos √∫nicos</li>
<li><code>m</code> actualizaciones de claves √∫nicas</li>
<li><code>t</code> mensajes con tama√±os de carga <code>q1,...,qt</code></li>
<li><code>‚Ñì</code> implementaciones de contratos</li>
</ul>
<p>Est√° dada por:</p>
<p><img src="./assets//Fee4.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Donde <code>w</code> es el vector de pasos discutido anteriormente y <code>cw</code> es el costo de calldata (en gas) por palabra de 32 bytes.</p>
<p>La tarifa se cobra at√≥micamente durante la ejecuci√≥n de la transacci√≥n en L2. El SO de Starknet realiza una transferencia del ERC-20 asociado con la tarifa, con una cantidad igual a la tarifa pagada, utilizando al remitente de la transacci√≥n como emisor y al secuenciador como receptor.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sierra---ir"><a class="header" href="#sierra---ir">Sierra - IR</a></h1>
<p>En este apartadao detallaremos m√°s la sint√°xis del lenguague que su de finici√≥n de IR, que podra revisar en la <a href="">secci√≥n</a></p>
<ul>
<li><strong>Variables mutables:</strong> En un lenguaje de programaci√≥n tradicional, cada variable est√° asociada con una celda de memoria espec√≠fica, una ubicaci√≥n en la memoria de la computadora donde se almacenan los datos de la variable. Cuando a una variable se le asigna un valor, el valor se almacena en la celda de memoria asociada con esa variable. La variable puede acceder o modificar el valor almacenado en esa celda de memoria durante la ejecuci√≥n del programa.</li>
</ul>
<p>Sin embargo, en Cairo, es imposible modificar el contenido de una celda de memoria a la que ya se ha escrito.</p>
<p>Las variables mutables son el az√∫car sint√°ctico que permite a los desarrolladores de El Cairo modificar y actualizar sin esfuerzo los valores de datos a lo largo de la ejecuci√≥n de un programa sin tener que seguir manualmente la variable declarada anteriormente. Cuando modificamos nuestra variable mutable x, la variable Sierra correspondiente que almacena su valor se descarta primero ya que ya no se usa, y luego se crea una nueva variable con el valor actualizado</p>
<p>Del mismo modo, para una variable no mutable y, cuyo valor est√© sombreado, el procedimiento en Sierra es exactamente el mismo: el valor anterior se cae y uno nuevo se instancia con el valor actualizado asociado con y. Sin embargo, se recomienda usar variables mutables en lugar de sombrear donde sea posible, ya que garantiza la consistencia en los tipos.</p>
<ul>
<li>
<p><strong>Referencias:</strong> En los idiomas tradicionales, ‚Äúpass-by-reference‚Äù es un m√©todo para pasar variables a funciones donde la funci√≥n recibe una referencia a la ubicaci√≥n de memoria de la variable. Esto permite que la funci√≥n modifique el valor de la variable directamente. En Cairo, el equivalente se logra utilizando el ref modificador al definir el par√°metro de funci√≥n. Sin embargo, como se dijo anteriormente, es esencial tener en cuenta que una vez que los valores variables asignados no se pueden modificar directamente en Cairo, a diferencia de otros idiomas.</p>
</li>
<li>
<p><strong>Snapshot:</strong> En el lenguaje de programaci√≥n de Cairo, las instant√°neas se introducen como un tipo de envoltura que crea una vista inmutable de un objeto en un momento dado. Las instant√°neas son √∫tiles cuando necesitamos realizar en tipos no duplicables como matrices. En la implementaci√≥n del tiempo de ejecuci√≥n, las instant√°neas son abstracci√≥n de costo cero debido al modelo de memoria escrita de la Asamblea de Cairo.</p>
</li>
</ul>
<p>En el <a href="https://github.com/starkware-libs/cairo/blob/main/crates/cairo-lang-sierra/src/extensions/modules/snapshot.rs#L37">crates cairo-lang-sierra</a>, aprendemos que una instant√°nea es solo una envoltura alrededor de un objeto que garantiza que el objeto original no se modifique. los snapshot_take libfunc solo devuelve una instant√°nea al tipo si el tipo no se puede copiar. Los tipos duplicables son su propia instant√°nea, ya que la instant√°nea en s√≠ misma es in√∫til si podemos duplicar el valor. Este concepto de instant√°neas solo existe en el nivel Sierra y hace que el sistema de tipo lineal sea efectivo al garantizar que el objeto envuelto en una instant√°nea no pueda modificarse.</p>
<p>Pero, ¬øcu√°ndo encontramos instant√°neas particularmente √∫tiles? Espec√≠ficamente cuando se trabaja con tipos no duplicables como Arrays. En el siguiente c√≥digo, una funci√≥n foo toma como par√°metro una matriz a. Una instant√°nea de esta matriz se pasa a dos funciones, y luego se devuelve la matriz.</p>
<p>Cuando una funci√≥n lleva una instant√°nea a un valor usando @, solo puede leer el valor y no modificarlo. Se comporta como un pr√©stamo inmutable usando &amp; en Rust, que permite que varias partes del programa lean el mismo valor simult√°neamente y se asegura de que no se modifique. Cuando trabaja con objetos no copiables, el uso de instant√°neas le permite retener la propiedad del objeto en el contexto de llamada y garantizar que el objeto permanezca inalterado.</p>
<ul>
<li><strong>Function inlining:</strong> La combinaci√≥n de funciones es una t√©cnica de optimizaci√≥n del compilador que sustituye una llamada de funci√≥n con el c√≥digo real de la funci√≥n que se llama. Elimina la sobrecarga de una llamada de funci√≥n integrando el c√≥digo de la funci√≥n directamente en la funci√≥n de llamada.</li>
</ul>
<p>El compilador de El Cairo reemplazar√° autom√°ticamente las llamadas a funciones marcadas como en l√≠nea directamente con su c√≥digo Sierra. Esta optimizaci√≥n es especialmente √∫til para funciones peque√±as frecuentemente llamadas. Inlining puede reducir la sobrecarga de las llamadas a funciones y conducir a ejecuciones m√°s r√°pidas y optimizadas, ya que los valores no necesitan ser recordados.</p>
<p>Resumen: Hemos explorado algunos conceptos centrales de El Cairo 1, como variables mutables, referencias e instant√°neas. Hemos visto c√≥mo las variables mutables en El Cairo son equivalentes a las variables sombreadas en Sierra y c√≥mo las referencias en El Cairo usan el ref prefijo para pasar variables e impl√≠citamente devolverlas. Adem√°s, hemos visto c√≥mo las instant√°neas en El Cairo son un concepto √∫nico que permite a los desarrolladores mantener la propiedad de los objetos al tiempo que garantiza que el valor original permanezca sin modificar. Finalmente, exploramos c√≥mo los desarrolladores pueden usar la funci√≥n como una t√©cnica de optimizaci√≥n.</p>
<p>Cairo = Mejoras unicas en cairo?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cairo-native---mlir"><a class="header" href="#cairo-native---mlir">Cairo Native - MLIR</a></h1>
<p>MLIR significa <code>(Intermediate Representation for Multi-Level Intermediate Representations)</code>, (Representaci√≥n Intermedia M√∫ltiNivel). Se refiere a un lenguaje de representaci√≥n intermedia dise√±ado para ser flexible y adaptable a diferentes requisitos en una infraestructura unificada.</p>
<p>A diferencia de <a href="https://llvm.org/docs/LangRef.html#introduction">LLVM IR</a>, que tiene una √∫nica representaci√≥n intermedia central que abarca un conjunto completo de instrucciones para representar programas de CPU/GPU, MLIR adopta un enfoque diferente. En MLIR, no existe una √∫nica representaci√≥n intermedia unificada.</p>
<blockquote>
<p>MLIR tiene como objetivo abordar la fragmentaci√≥n del software, mejorar la compilaci√≥n de hardware heterog√©neo, reducir significativamente el costo de construir compiladores espec√≠ficos de dominio y ayudar a conectar compiladores existentes.</p>
</blockquote>
<p>En su lugar, MLIR introduce conceptos abstractos como dialectos, operaciones y regiones. Estos conceptos permiten la definici√≥n de diferentes dialectos o lenguajes especializados, cada uno con su propio conjunto de operaciones y reglas sem√°nticas espec√≠ficas.</p>
<p>La idea detr√°s de MLIR es brindar una infraestructura flexible que pueda adaptarse a m√∫ltiples requisitos y necesidades en el √°mbito de la representaci√≥n intermedia. Esto significa que se pueden definir dialectos espec√≠ficos para diferentes dominios, como procesadores espec√≠ficos, aceleradores o incluso lenguajes de programaci√≥n espec√≠ficos.</p>
<p>En resumen, MLIR busca proporcionar una forma flexible y modular de representar programas en un nivel intermedio, permitiendo la adaptabilidad a diferentes requisitos y escenarios mediante el uso de dialectos y operaciones espec√≠ficas de cada dominio.</p>
<blockquote>
<p>En otras palabras, si LLVM IR est√° centralizado por la naturaleza y favorece los flujos unificados del compilador, la infraestructura MLIR y su ecosistema de dialecto est√°n descentralizados por la naturaleza y favorecen los diversos flujos del compilador. Lo que es bastante poderoso es que MLIR permite representar diferentes niveles utilizando la misma infraestructura, para que el flujo entre diferentes niveles pueda ser continuo.</p>
</blockquote>
<p>La mayor√≠a de los protocolos ZKP implican aritmetizaci√≥n, que es el proceso de representar el c√°lculo en un formato num√©rico que puede utilizar el sistema de prueba, generalmente tomando las instrucciones en el c√°lculo y construyendo un gr√°fico de expresi√≥n de operaciones en bits llamado circuito aritm√©tico y luego generando un seguimiento de ejecuci√≥n, que muy brevemente es una matriz de elementos de campo que representan la evoluci√≥n del c√°lculo a lo largo del tiempo. Este rastro de ejecuci√≥n se alimenta al probador.</p>
<p>Para encapsular estos procesos, las m√°quinas virtuales se han dise√±ado e implementado para generar estos rastros de ejecuci√≥n num√©ricos y proporcionar garant√≠as computacionales, como <a href="https://github.com/0xPolygonMiden/miden-vm?ref=notamonadtutorial.com">Miden</a> y <a href="https://github.com/lambdaclass/cairo-rs/pulls?ref=notamonadtutorial.com">cairo-rs</a>. Una vez que tenga una m√°quina virtual, necesita un compilador y una representaci√≥n intermedia.</p>
<p>Tampoco puede aceptar ning√∫n programa, ya que necesita saber que su ejecuci√≥n es demostrable a menos que est√© dispuesto a asumir la posibilidad de programas no terminales, transacciones inv√°lidas que consumen gas excesivo, la producci√≥n de trazas inv√°lidas o incompletas, y que el probador simplemente renuncie en el medio. La teor√≠a de tipos y las representaciones intermedias dentro de los compiladores se han convertido en una de las herramientas m√°s potentes para producir c√≥digo que tiene propiedades que podemos razonar y verificar mec√°nicamente.</p>
<p>En resumen, la necesidad de ejecutar hardware m√°s diverso, incorporar tecnolog√≠a de lenguaje de programaci√≥n, para permitir el uso f√°cil de primitivas criptogr√°ficas complejas, Para transportar garant√≠as de herramientas de desarrolladores a capas de ejecuci√≥n, todos se han unido para lograr un peque√±o renacimiento de la implementaci√≥n del lenguaje en el mundo criptogr√°fico.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="herodotus---storage-proof"><a class="header" href="#herodotus---storage-proof">Herodotus - Storage Proof</a></h1>
<p>En el mundo de los sistemas descentralizados y la tecnolog√≠a blockchain, garantizar la precisi√≥n y autenticidad de los datos es de suma importancia. A medida que el ecosistema evoluciona, se hace cada vez m√°s necesario compartir informaci√≥n a trav√©s de diferentes cadenas, lo que lleva al desarrollo de soluciones innovadoras para verificar la integridad de los datos sin sacrificar la seguridad o la eficiencia. Una de esas soluciones es el uso de Storage Proof .</p>
<p>Las Storage Proof  ofrecen un m√©todo criptogr√°fico para rastrear y compartir informaci√≥n de blockchain a trav√©s de cadenas, similar a los or√°culos. Sin embargo, la diferencia clave radica en el modelo de confianza.</p>
<p>Las Storage Proof  proporcionan inherentemente una prueba de autenticidad sin depender de la confianza de terceros. En algunas situaciones, incluso pueden reemplazar o complementar los or√°culos, allanando el camino para nuevos casos de uso y aplicaciones en el ecosistema blockchain.</p>
<p>Imagina que tienes un libro gigante lleno de informaci√≥n y quieres demostrar que un dato concreto est√° en ese libro, en lugar de pedir a alguien que revise todo el libro para encontrar la informaci√≥n, se utiliza un sistema inteligente (en nuestro caso, la criptograf√≠a) para crear una peque√±a prueba que pueda demostrar f√°cilmente la presencia de la informaci√≥n en el libro. Esta prueba es lo que llamamos una Storage Proof.</p>
<p>En el contexto de las cadenas de bloques, estos libros gigantes son las bases de datos que almacenan todas las transacciones y datos de la red. Las Storage Proof permiten crear una prueba peque√±a y verificable de que ciertos datos existen dentro del estado del blockchain en un momento determinado. Para ello se utilizan t√©cnicas criptogr√°ficas incorporadas al propio almacenamiento.</p>
<p>Las cadenas de bloques utilizan varias estructuras de datos, como los √°rboles Merkle, los √°rboles Merkle Patricia y los √°rboles Verkle, para comprometer criptogr√°ficamente sus datos. Utilizando estas estructuras de datos, se pueden generar Storage Proof  para demostrar que una informaci√≥n espec√≠fica forma parte de un estado determinado. Sin embargo, cuando se utilizan solas, estas pruebas pueden llegar a ser bastante grandes, lo que las hace poco pr√°cticas para la verificaci√≥n en cadena. Para superar este problema, las Storage Proof  suelen combinarse con t√©cnicas criptogr√°ficas avanzadas, como STARK o SNARK, para crear pruebas m√°s peque√±as y eficientes que puedan verificarse en cualquier dominio sin confiar en terceros. En su lugar, la seguridad y la confianza proceden de la propia blockchain subyacente.</p>
<p>Las Storage Proof  le permiten abrir compromisos criptogr√°ficos de estado. Se pueden optimizar al unirlos con S [ N / T ] ARKS. . Estas pruebas de validez prueban que exist√≠a un estado en particular y que era v√°lido en un bloque en particular en el pasado.</p>
<p>Fundamentalmente, las cadenas de bloques son bases de datos que contienen datos comprometidos criptogr√°ficamente utilizando (√°rboles Merkle, √°rboles Merkle Patricia, √°rboles Verkle, etc. ). Como todos los datos est√°n comprometidos, podemos demostrar que cierta informaci√≥n est√° encapsulada en un estado dado. Sin embargo, con esquemas de compromiso simples, el tama√±o de esta prueba se vuelve m√°s prominente a medida que el tama√±o de los datos que incluye se hace m√°s grande. Verificar tales pruebas en cadena se vuelve demasiado costoso para ser pr√°ctico.</p>
<p>Las Storage Proof , por otro lado, cuando se usan junto con <code>STARK</code> o <code>SNARK</code>, pueden ser relativamente peque√±as y le permiten verificar un estado espec√≠fico, en un momento espec√≠fico y en cualquier dominio,  <code>sin confiar en un tercero</code>. En su lugar, conf√≠an en la seguridad de la cadena subyacente.</p>
<p>¬øPor qu√© es esto importante? Ethereum hoy no es la cadena monol√≠tica simple (L1) que era hace varios a√±os. Con el advenimiento de las soluciones L2, los datos ahora se distribuyen en m√∫ltiples cadenas.</p>
<p>Ya no se pueden hacer suposiciones sincr√≥nicas sobre el estado de la cadena. Muchas soluciones para compartir datos ahora est√°n en vivo, como los sistemas de mensajer√≠a <code>L1 -&gt; L2</code>, puentes entre cadenas y or√°culos. Pero el problema con estas soluciones actuales es que incluyen la confianza en un tercero, como los relevistas, los firmantes multisig y los comit√©s. Las Storage Proof  nos permiten validar el estado de una cadena de bloques en cualquier momento utilizando compromisos criptogr√°ficos sin asumir la confianza de un tercero.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arquitectura-herodotus"><a class="header" href="#arquitectura-herodotus">Arquitectura Herodotus</a></h1>
<p>Cada despliegue de contratos inteligentes de Her√≥doto que admite una cadena espec√≠fica consta de los siguientes contratos:</p>
<ol>
<li><strong>Commitments inbox:</strong>  Este contrato es responsable de procesar y verificar la validez de otros compromisos de la cadena, como bloqueos o ra√≠ces estatales.</li>
<li><strong>Headers store:</strong>  Esto contrata almacena y permite procesar encabezados desde un punto dado hasta la g√©nesis al afirmar que <code>blockhash(x - 1) = parenthash(x)</code>.</li>
<li><strong>Facts registry:</strong> Este contrato realiza la verificaci√≥n de Storage Proof  y almacena los valores solicitados en su estado.</li>
</ol>
<p><img src="./assets/Herodotus.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commitments-inbox"><a class="header" href="#commitments-inbox">Commitments Inbox</a></h1>
<p>Cada vez que se accede a datos provenientes de un dominio diferente en otro dominio, se requiere un compromiso para asegurar su correcci√≥n criptogr√°fica. Estos compromisos pueden ser:</p>
<ol>
<li>State root</li>
<li>Block hash</li>
<li>Transactions root</li>
<li>Receipts root</li>
</ol>
<p>El contrato <code>CommitmentsInbox</code> se encarga de recibir y gestionar estos compromisos. Los compromisos pueden entregarse de diversas formas, como:</p>
<ol>
<li>Recibir mensajes as√≠ncronos.</li>
<li>Validar el consenso de la red de manera verificable (disponible solo para L2 descentralizados).</li>
<li>Utilizar relayers optimistas.</li>
</ol>
<p>Una vez que un compromiso es aceptado por el <code>CommitmentsInbox</code>, se pasa al <code>HeadersStore</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="headers-store"><a class="header" href="#headers-store">Headers Store</a></h1>
<p>El contrato HeadersStore refleja los encabezados de las cadenas admitidas en el almacenamiento del state de este contrato. Estos encabezados solo pueden agregarse si el del encabezado <code>parentHash</code> ya ha sido pasado al <code>CommitmentsInbox</code>.</p>
<p>Cualquier persona puede enviar encabezados, pero un encabezado solo es v√°lido si su hash calculado en la cadena coincide con el hash certificado previamente por el <code>CommitmentsInbox</code>.</p>
<p>Cada vez que se procesa un encabezado, se guarda el hash de su encabezado padre en el estado del contrato para permitir que el encabezado anterior en la cadena se procese de la misma manera.</p>
<p>Al procesar un bloque, sus par√°metros pueden guardarse en el estado inteligente de los contratos. Cada cadena blockchain contiene diferentes par√°metros en su encabezado. Por ejemplo, un encabezado de EVM en Ethereum L1 contiene las siguientes propiedades:</p>
<ul>
<li><a href="https://ethereum.org/en/developers/docs/gas/#base-fee"><strong>baseFeePerGas</strong></a></li>
<li><a href="https://ethereum.org/en/glossary/#difficulty"><strong>difficulty</strong></a></li>
<li><a href=""><strong>extraData</strong></a></li>
<li><a href="https://ethereum.org/en/glossary/#gas-limit"><strong>gasLimit</strong></a></li>
<li><a href=""><strong>gasUsed</strong></a></li>
<li><a href=""><strong>parentHash</strong></a></li>
<li><a href=""><strong>receiptsRoot</strong></a></li>
<li><a href=""><strong>transactionsRoot</strong></a></li>
<li><a href=""><strong>stateRoot</strong></a></li>
<li><a href=""><strong>timestamp</strong></a></li>
<li><a href=""><strong>logsBloom</strong></a></li>
<li><a href=""><strong>nonce</strong></a></li>
<li><a href=""><strong>miner</strong></a></li>
<li><a href=""><strong>mixHash</strong></a></li>
<li><a href=""><strong>sha3Uncles</strong></a></li>
<li><a href=""><strong>number</strong></a></li>
<li><a href=""><strong>extraData</strong></a></li>
</ul>
<p>La especificaci√≥n de los par√°metros que deben guardarse se realiza mediante un valor entero que codifica un mapa desde el √≠ndice del par√°metro hasta si debe guardarse o no. Los √≠ndices para cada par√°metro son:</p>
<ul>
<li><code>PARENT_HASH = 0</code></li>
<li><code>UNCLES_HASH = 1</code></li>
<li><code>MINER = 2</code></li>
<li><code>STATE_ROOT = 3</code></li>
<li><code>TRANSACTION_ROOT = 4</code></li>
<li><code>RECEIPTS_ROOT = 5</code></li>
<li><code>LOGS_BLOOM = 6</code></li>
<li><code>DIFFICULTY = 7</code></li>
<li><code>BLOCK_NUMBER = 8</code></li>
<li><code>GAS_LIMIT = 9</code></li>
<li><code>GAS_USED = 10</code></li>
<li><code>TIMESTAMP = 11</code></li>
<li><code>EXTRA_DATA = 12</code></li>
<li><code>MIX_HASH = 13</code></li>
<li><code>NONCE = 14</code></li>
<li><code>BASE_FEE = 15</code></li>
</ul>
<p>Por ejemplo, para establecer solo la <code>STATE_ROOT</code>, el valor para ese par√°metro ser√≠a 8, ya que su representaci√≥n binaria es <code>000000000001000</code>, lo cual es igual a <code>2^3</code>, donde <code>3</code> es el √≠ndice de la <code>STATE_ROOT</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="facts-registry"><a class="header" href="#facts-registry">Facts Registry</a></h1>
<p>Este es el √∫ltimo contrato en la pila b√°sica de Herodotus y optimiza el proceso de acceso a las propiedades de una cuenta, como:</p>
<p>Nonces (si est√°n disponibles).</p>
<p>Saldos (si est√°n disponibles).</p>
<p>Storage hash.</p>
<p>Code hash.</p>
<p>El primer nivel de almacenamiento en las blockchains basadas en cuentas son las propias cuentas. Para probarlas, es necesario tener acceso a la stateRoot, cuya correcci√≥n se verifica mediante el contrato HeadersStore. Con dicha ra√≠z del estado, se puede verificar una prueba de MPT que demuestra las propiedades mencionadas de una cuenta.</p>
<p>Estas propiedades, de manera similar a HeadersStore, se pueden guardar en el estado para reducir la cantidad de c√°lculos necesarios cada vez que se accede al almacenamiento del contrato inteligente.</p>
<p>Acceso al almacenamiento del contrato</p>
<p>Como se mencion√≥ anteriormente, el primer nivel de almacenamiento son las cuentas. El segundo nivel es el almacenamiento real del contrato. Este almacenamiento se guarda en un √°rbol Merkle Patricia Tree, donde la ra√≠z es el StorageHash de la cuenta. Al ser un √°rbol Merkle Patricia, se puede probar cualquier cosa incluida en √©l.</p>
<p>Esto permite que Herodotus habilite el acceso al almacenamiento de los contratos inteligentes. El almacenamiento de los contratos inteligentes es una base de datos de clave-valor donde cada clave corresponde a 32 bytes de datos.</p>
<p>Para obtener m√°s informaci√≥n sobre c√≥mo asignar un nombre de variable a su clave de almacenamiento, consulte la documentaci√≥n de Solidity. Recomendamos encarecidamente utilizar esta gu√≠a cuando se trabaja con el dise√±o del almacenamiento de contratos inteligentes en Solidity.</p>
<div style="break-before: page; page-break-before: always;"></div><p>El uso de una API para solicitar Storage Proof  es sencillo, pero creemos que todav√≠a no es lo suficientemente simple. Hoy anunciamos Herodotus Turbo üõ∞</p>
<p>Turbo permitir√° una interoperabilidad 100% sin confianza entre las capas 2 de Ethereum con solo escribir una l√≠nea de c√≥digo.</p>
<p>https://twitter.com/HerodotusDev/status/1682400907969822722</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="casos-de-usos"><a class="header" href="#casos-de-usos">Casos de Usos</a></h1>
<p>Dado que las Storage Proof  nos permiten comprimir eficientemente ‚Äú ‚Äù una cadena de bloques y transmitir los datos a otra parte, tienen bastantes aplicaciones. El costo de verificaci√≥n asequible, una propiedad integral de las Storage Proof , permite validar la prueba en el destino cadena, minimizando la necesidad de desarrollar sistemas de mensajer√≠a entre cadenas.</p>
<p>Los casos de uso potencial incluyen:</p>
<ul>
<li><strong>Acceso a informaci√≥n general</strong> de una cadena de otra sobre el estado y las transacciones en la cadena de bloques.</li>
<li><strong>Sistemas de votaci√≥n entre cadenas simplificados</strong> Con frecuencia, los usuarios mantienen sus activos en una cadena A lenta pero m√°s segura, pero se produce una votaci√≥n basada en tokens en una cadena B con transacciones m√°s baratas. Esto obliga al usuario a omitir su voto o pagar enormes tarifas de transacci√≥n para unir sus activos de la A a la B, emitir su voto y luego obligarlos a la A. En tales casos, las Storage Proof  permiten a los usuarios probar su equilibrio de fichas en la cadena A en un bloque dado y emitir su voto a la perfecci√≥n en la cadena B.</li>
<li><strong>Alternativa a los puentes entre cadenas.</strong> Actualmente, los puentes entre cadenas asumen un nivel de confianza en un tercero porque generalmente involucran a un intermediario, como un custodio o una organizaci√≥n aut√≥noma descentralizada ( DAO ). Este intermediario es responsable de garantizar que el intermediario reciba una cierta cantidad de tokens en la cadena de origen y de mantener los activos en la cadena de origen. Posteriormente, las fichas correspondientes se acu√±an en la cadena de destino. Las Storage Proof  pueden permitir puentes sin confianza entre cadenas, ya que una aplicaci√≥n de contrato inteligente en la cadena de destino podr√≠a validar una transacci√≥n en la que los activos se transfirieron al contrato inteligente del puente en la cadena de origen y acu√±ar los activos puenteados. Sin embargo,en muchos casos, la necesidad de transferir activos entre cadenas puede eliminarse ya que la propiedad de los activos en otra cadena podr√≠a demostrarse simplemente con Storage Proof .</li>
<li><strong>UX mejorado para la abstracci√≥n de la cuenta ( AA ) casos de uso.</strong> AA se ha implementado en diferentes cadenas y se considera una innovaci√≥n crucial para incorporar a los primeros mil millones de usuarios al espacio blockchain. Con Storage Proof , las billeteras podr√≠an incluir la funcionalidad adicional de restaurar el acceso solo si la billetera no envi√≥ ninguna transacci√≥n durante una larga duraci√≥n. Tambi√©n se podr√≠an hacer cumplir verificaciones adicionales que requieren que algunos datos se utilicen de otras cadenas.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ejemplos-storage-proof"><a class="header" href="#ejemplos-storage-proof">Ejemplos Storage Proof</a></h1>
<p>Generar Storage Proof en cadenas compatibles con EVM es sencillo. Por ejemplo, la biblioteca Web3.js tiene la funci√≥n <code>getProof</code> que puede generar pruebas del estado de un contrato en Ethereum (y otras cadenas compatibles con EVM como Polygon, BSC, L2 Optimism...). Una direcci√≥n de contrato y la ranura de almacenamiento para el contrato deben ser pasados a la funci√≥n.</p>
<p>En Ethereum, los contratos inteligentes utilizan un almac√©n de clave-valor para almacenar los datos en su almac√©n. Cada dato se almacena en una ubicaci√≥n espec√≠fica conocida como <code>ranura de almacenamiento</code>. Las ranuras de almacenamiento son ubicaciones de memoria dentro del almacenamiento del contrato y se identifican mediante un √≠ndice √∫nico. Veamos un ejemplo de contrato inteligente con el siguiente c√≥digo desplegado en la mainnet de Ethereum.</p>
<p><img src="./assets/storage.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>La variable owner se almacenar√≠a en la ranura <code>0</code>. Ahora, para generar la prueba de que el owner de este contrato era una <code>direcci√≥n A</code>, podemos utilizar la funci√≥n <code>getProof</code> de la siguiente manera:</p>
<p><img src="./assets/storage1.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>El resultado del c√≥digo anterior es algo parecido a esto:</p>
<p><img src="./assets/storage2.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>El <code>storageProof</code> devuelto contiene la prueba de almacenamiento para la variable <code>owner</code>. Dado que Ethereum utiliza Merkle Patricia Trees para comprometer su estado, el estado de las cuentas y su almacenamiento, el almacenamiento generado puede ser utilizado para probar una ranura de almacenamiento (o estado de la cuenta). Sin embargo, como se ha indicado anteriormente, estas pruebas no son lo suficientemente escalables como para discutir las transferencias de mensajes entre cadenas, para ello el uso de complejas matem√°ticas ZK sobre esto puede disminuir el c√°lculo necesario para verificar la prueba.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proyectos-shh-y-hackaton"><a class="header" href="#proyectos-shh-y-hackaton">Proyectos SHH y Hackaton</a></h1>
<ul>
<li><a href="https://devfolio.co/projects/starksight-5d82"><strong>StarkSight:</strong></a> Use Worldcoin (Polygon) on Starknet. Storage proof of storage slot.</li>
<li><a href="https://643b0387a7ab7800083bb427--cosmic-unicorn-126e1a.netlify.app/"><strong>MAID:</strong></a> Proof of OG (Are you a long-time holder of this coin?). Historical storage proof of storage slot</li>
<li><a href="https://www.mergeswap.xyz/"><strong>Merge Swap:</strong></a> Use storage proof on PoW to PoS chain.</li>
</ul>
<h2 id="shh"><a class="header" href="#shh">SHH</a></h2>
<ul>
<li><a href="https://twitter.com/piapark_eth/status/1681312309032128515"><strong>Chess Dojo</strong></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merkle-mountain-ranges-en-cairo"><a class="header" href="#merkle-mountain-ranges-en-cairo">Merkle Mountain Ranges en Cairo</a></h1>
<p>Herodotus ha implementado una nueva estructura de datos criptogr√°fica llamada Merkle Mountain Ranges (MMR) en Cairo. Las MMR son una lista de √Årboles de Merkle, donde cada √°rbol se representa como una monta√±a y la lista completa forma el rango.</p>
<p>Las MMR comparten las propiedades comunes de los √Årboles de Merkle, como el almacenamiento eficiente de datos y la capacidad de generar pruebas de Merkle para demostrar la existencia de un elemento en el √°rbol. Sin embargo, tambi√©n ofrecen ventajas adicionales, como la eficiencia en la adici√≥n y actualizaci√≥n de elementos, detallemos algunas:</p>
<ul>
<li>La adici√≥n de un elemento a un MMR es mucho m√°s eficiente, ya que en la mayor√≠a de los casos no es necesario recorrer todo el √°rbol. La complejidad subyacente es log2(n) <code>puntas de monta√±a</code>.</li>
<li>Las pruebas de Merkle en un MMR se realizan mediante pruebas de tama√±o log2(n) que consisten en una ruta Merkle hasta la punta del √°rbol.</li>
<li>La actualizaci√≥n de un elemento tambi√©n se puede realizar de manera eficiente.</li>
<li>Es posible optimizar a√∫n m√°s al comparar inserciones y actualizaciones.</li>
<li>Tanto las inserciones como las actualizaciones se pueden implementar en cadena, lo que garantiza una total transparencia sobre c√≥mo se actualiza el √°rbol.</li>
</ul>
<p>Con esta nueva estructura de datos en Cairo, buscamos mejorar la eficiencia y verificabilidad del almacenamiento de datos en la plataforma, haci√©ndola √∫til para diversas aplicaciones que requieren almacenamiento y verificaci√≥n de datos en la cadena.</p>
<h2 id="esquema-de-firma-ecdsa-con-umbral"><a class="header" href="#esquema-de-firma-ecdsa-con-umbral">Esquema de firma ECDSA con umbral</a></h2>
<p>Algunas innovaciones que se ir√°n tratando como el esquema de firma ECDSA con umbral en bandeja de entrada de compromisos optimistas. </p>
<p>Para acceder al estado de diferentes cadenas, necesitamos acceder a las cabeceras de bloque, de las que podemos recuperar todo tipo de informaci√≥n (incluido el estado). Tenemos varias estrategias para obtener las cabeceras de bloque de diferentes cadenas, una de las cuales es un protocolo MPC que ejecuta un algoritmo de firma ECDSA de umbral. La salida del protocolo es una √∫nica firma que se validar√° en la cadena. Esto es mejor que tener una firma por parte, lo que es posible gracias a una ceremonia DKG (generaci√≥n de clave distribuida).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-proof-vs-oracle"><a class="header" href="#storage-proof-vs-oracle">Storage Proof Vs Oracle</a></h1>
<p>Las cadenas de bloques est√°n dise√±adas para no generar confianza, lo que significa que no pueden acceder intr√≠nsecamente a datos fuera de la cadena. Esta limitaci√≥n afecta a la capacidad de los contratos inteligentes para tomar decisiones basadas en eventos del mundo real o en informaci√≥n hist√≥rica de la cadena de bloques. Como soluci√≥n, se introdujeron los or√°culos para proporcionar a los contratos inteligentes datos fuera de la cadena o resultados de c√°lculos fuera de la cadena que consumen muchos recursos.</p>
<p>Los or√°culos suelen requerir que un tercero, como una instituci√≥n o una red descentralizada de operadores de nodos, env√≠e datos a la cadena. Aunque esto introduce un nivel de confianza, varios equipos, como Pragma, est√°n trabajando para minimizar este requisito de confianza.</p>
<p>Chainlink es un conocido or√°culo de blockchain que proporciona datos del mundo real, servicios de c√°lculo fuera de la cadena y servicios entre cadenas. Dado que los contratos inteligentes dependen actualmente de los or√°culos para obtener datos del mundo real, los or√°culos se han convertido en una parte crucial del ecosistema blockchain.</p>
<h2 id="pueden-los-or√°culos-ser-sustituidos-o-mejorados-por-storage-proof"><a class="header" href="#pueden-los-or√°culos-ser-sustituidos-o-mejorados-por-storage-proof">¬øPueden los or√°culos ser sustituidos o mejorados por Storage Proof?</a></h2>
<p>En algunos casos, las Storage Proof pueden sustituir a los or√°culos. Algunos datos proporcionados por los or√°culos ya est√°n disponibles en la cadena, y una prueba de almacenamiento puede eliminar la necesidad de confiar en un tercero, permitiendo que los contratos inteligentes se basen por completo en la seguridad de los compromisos criptogr√°ficos. Sin embargo, en otros casos en los que las Storage Proof  no pueden sustituir completamente a los or√°culos, pueden mejorarlos con una funcionalidad adicional:</p>
<ul>
<li>Las Storage Proof permiten realizar c√°lculos sobre datos de diferentes fuentes y exportar los resultados a otras cadenas, haciendo posible que los or√°culos transmitan informaci√≥n a trav√©s de m√∫ltiples cadenas.</li>
<li>Las Storage Proof pueden facilitar una validaci√≥n rentable en las cadenas de destino, ya que la cadena de origen preferida suele tener un c√°lculo barato.</li>
<li>L√≠deres en investigaci√≥n, como Herodotus, permiten el acceso a datos entre dominios a trav√©s de cadenas Ethereum utilizando Storage Proof y matem√°ticas ZK. Pragma planea asociarse con Herodotus para soportar or√°culos entre cadenas en un futuro pr√≥ximo.</li>
<li>Las Storage Proof pueden unificar el estado de m√∫ltiples rollups e incluso permitir lecturas s√≠ncronas entre capas Ethereum.</li>
<li>La recuperaci√≥n fiable de datos hist√≥ricos de la cadena es otra mejora posible gracias a las Storage Proof . Las cadenas de bloques con estado, como Ethereum y Starknet, preservan criptogr√°ficamente su estado a trav√©s de estructuras de datos especializadas, lo que permite probar la inclusi√≥n de datos. Esto permite a los contratos inteligentes acceder a informaci√≥n que se remonta al bloque de g√©nesis.</li>
</ul>
<p>Pragma est√° explorando el desarrollo de un or√°culo L3 en Starknet, que podr√≠a permitir a otras cadenas extraer y verificar datos utilizando Storage Proof. Los beneficios de tener un or√°culo L3 en una red computacionalmente barata como Starknet incluyen:</p>
<ul>
<li>Consenso m√°s r√°pido en bloques debido a la cadena L3 altamente personalizable, reduciendo significativamente la latencia de datos para el or√°culo.</li>
<li>Transferencia as√≠ncrona de datos de baja latencia a otras cadenas al alcanzar el consenso en la cadena de origen, en combinaci√≥n con Storage Proof .</li>
<li>Mayor confianza en los datos mediante un sistema incorporado para penalizar a los proveedores de datos deshonestos. Los proveedores de datos en la L3 podr√≠an poner en juego sus activos como garant√≠a de la exactitud de los datos. Como toda la red L3 debe alcanzar un consenso antes de que otras cadenas puedan utilizar los datos, los datos del or√°culo pueden considerarse garantizados por la apuesta de los validadores en L3.</li>
</ul>
<p>La creciente adopci√≥n de soluciones L2 de Ethereum, como Starknet, Optimism y Arbitrum, ha permitido vislumbrar el futuro del sector. Sin embargo, un reto clave que impide un mayor crecimiento es la implementaci√≥n de un sistema descentralizado de mensajer√≠a entre cadenas, las Storage Proof tienen un enorme potencial para resolver este problema.</p>
<p>En algunos casos, las Storage Proof pueden sustituir o mejorar los or√°culos, facilitando una comunicaci√≥n entre cadenas m√°s eficiente y el acceso a datos hist√≥ricos. Al reducir la dependencia de la confianza en terceros, las Storage Proof  pueden reforzar significativamente la seguridad y la eficiencia de las aplicaciones de blockchain.</p>
<p>A medida que el panorama de las cadenas de bloques siga evolucionando, podemos anticipar nuevos desarrollos e innovaciones en Storage Proof, or√°culos y comunicaci√≥n entre cadenas. Aprovechando estas tecnolog√≠as, el ecosistema blockchain puede mantener su crecimiento y ofrecer m√°s valor tanto a los usuarios como a los desarrolladores.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estado-de-oracles-en-starknet"><a class="header" href="#estado-de-oracles-en-starknet">Estado de Oracles en Starknet</a></h1>
<p>En la red de pruebas de Starknet, Chainlink proporciona datos de precios para siete pares de criptomonedas y se ha asociado con Starkware para acelerar el desarrollo y crecimiento de aplicaciones en el ecosistema de Starknet. Chainlink minimiza los supuestos de confianza a trav√©s de una red descentralizada de nodos, pero la agregaci√≥n de datos se produce fuera de la cadena.</p>
<p>Pragma y Stork Network son dos importantes proveedores de or√°culos en Starknet, que operan tanto en la mainnet como en la testnet. Ofrecen tickers de precios para m√∫ltiples pares de criptomonedas, y Pragma est√° trabajando en la implementaci√≥n de una fuente de aleatoriedad verificable en la mainnet para una aleatoriedad segura en la cadena. Las fuentes de precios de Pragma se basan en env√≠os de grandes instituciones y creadores de mercado, aprovechando la eficiente tecnolog√≠a ZK para la agregaci√≥n de precios en la cadena.</p>
<p>En resumen, tanto las Storage Proof  como los or√°culos son cruciales para facilitar la comunicaci√≥n entre cadenas y el acceso a datos fuera de la cadena. Mientras que los or√°culos son indispensables para los datos del mundo real, las Storage Proof  ofrecen una forma fiable y eficiente de transferir y verificar la informaci√≥n de la cadena de bloques entre cadenas. Juntos, ayudan a crear un ecosistema de cadenas de bloques m√°s s√≥lido e interconectado.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pragma---bases"><a class="header" href="#pragma---bases">Pragma - Bases</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainlink---bases"><a class="header" href="#chainlink---bases">Chainlink - Bases</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="exploradores-de-bloques-"><a class="header" href="#exploradores-de-bloques-">Exploradores de Bloques üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starkscan-"><a class="header" href="#starkscan-">Starkscan üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="voyager-"><a class="header" href="#voyager-">Voyager üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="madara-"><a class="header" href="#madara-">Madara üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elixir-"><a class="header" href="#elixir-">Elixir üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="view-block-"><a class="header" href="#view-block-">View Block üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cairo---arquitectura"><a class="header" href="#cairo---arquitectura">Cairo - Arquitectura</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sint√°xis-b√°sica"><a class="header" href="#sint√°xis-b√°sica">Sint√°xis B√°sica</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cairo-v2---nueva-versi√≥n-del-compilador"><a class="header" href="#cairo-v2---nueva-versi√≥n-del-compilador">Cairo v2 - Nueva versi√≥n del Compilador</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>https://twitter.com/nodeguardians/status/1682410394864832514</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducci√≥n-parte-3"><a class="header" href="#introducci√≥n-parte-3">Introducci√≥n Parte 3</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="otras-arquitecturas"><a class="header" href="#otras-arquitecturas">Otras Arquitecturas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambda-en-starknet-"><a class="header" href="#lambda-en-starknet-">Lambda en Starknet üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-en-rust-"><a class="header" href="#starknet-en-rust-">Starknet en Rust üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambda-prover---platinum-"><a class="header" href="#lambda-prover---platinum-">Lambda Prover - Platinum üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambda-sequencer-"><a class="header" href="#lambda-sequencer-">Lambda Sequencer üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdaworks-"><a class="header" href="#lambdaworks-">LambdaWorks üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="madara---exploraci√≥n-de-su-arquitectura-"><a class="header" href="#madara---exploraci√≥n-de-su-arquitectura-">Madara - Exploraci√≥n de su Arquitectura üöß</a></h1>
<p>En este cap√≠tulo realizaremos un an√°lisis exhaustivo de la arquitectura de Madara, este componente fundamental desempe√±ar√° un papel vital en el ecosistema de Starknet, destac√°ndose por su enfoque en el escalado fractal y la modularidad dentro del mundo de las blockchains. Antes de sumergirnos en las intrincadas capas de Madara, es recomendable revisar los cimientos y las definiciones clave, las cuales est√°n detalladas en el apartado <a href="/Book-Starkware/src/Madara_Base.html#madara---bases-de-su-arquitectura">Base Madara</a> de la Parte 2 del Libro de L2 sobre la Arquitectura de Starknet y Cairo.</p>
<p>La esencia de Madara se fusiona con la plataforma Substrate, un framewrok de innovaci√≥n en la cadena de bloques que se erige como el fundamento de Madara. Las Chains montadas con Substrate se representan como una combinaci√≥n de tres tecnolog√≠as fundamentales: </p>
<ul>
<li>
<p><strong>WebAssembly:</strong> Wasm es un formato binario de instrucciones dise√±ado para una m√°quina virtual basada en pilas. Su principal prop√≥sito es servir como un objetivo de compilaci√≥n port√°til para diversos lenguajes de programaci√≥n, lo que facilita su implementaci√≥n en aplicaciones tanto de cliente como de servidor en la web.</p>
</li>
<li>
<p><strong>Libp2p:</strong> Es una colecci√≥n de protocolos, especificaciones y herramientas que facilitan la construcci√≥n de redes descentralizadas y resistentes a la censura en el √°mbito de la web. Esta biblioteca est√° dise√±ada para brindar una capa de comunicaci√≥n peer-to-peer eficiente y flexible, permitiendo que los nodos se conecten y se comuniquen de manera segura a trav√©s de una variedad de redes y protocolos subyacentes. Libp2p se adapta a una amplia gama de aplicaciones, desde sistemas de almacenamiento distribuido hasta redes de transmisi√≥n de datos, lo que lo convierte en un componente esencial para la arquitectura de Madara y su integraci√≥n con Starknet.</p>
</li>
<li>
<p><strong>GRANDPA:</strong> Es la abreviatura de (GHOST-based Recursive Ancestor Deriving Prefix Agreement), un componente de vital importancia que desempe√±a un rol crucial similar a una &quot;llave maestra&quot; para los clientes de cadenas de bloques basadas en Substrate. Podemos definir este algoritmo de finalizaci√≥n que intenta conseguirel  equilibrio perfecto entre velocidad y seguridad en el intrincado proceso de consenso. Su enfoque innovador se centra en el concepto de votar por bloques v√°lidos y, de manera progresiva y transitiva, aplicar esos votos a lo largo de las generaciones de bloques ancestrales. Esta estrategia inteligente permite la finalizaci√≥n de bloques al lograr una supermayor√≠a de votos, lo que asegura una finalidad asincr√≥nica y, adem√°s, otorga adaptabilidad ante diversas condiciones de la red.</p>
<p>La distinci√≥n de GRANDPA se manifiesta en su capacidad excepcional para finalizar m√∫ltiples bloques de manera simult√°nea, una caracter√≠stica que confirma su resiliencia incluso en circunstancias de particiones prolongadas en la red. En un esfuerzo por mantener la integridad del proceso, aquellos participantes que emiten votos contradictorios son detectados y enfrentan consecuencias mediante un protocolo meticuloso de desaf√≠o y respuesta. Un aspecto digno de menci√≥n es la flexibilidad de GRANDPA para asignar pesos individuales a nodos, considerando factores como la cantidad apostada en el protocolo. Esta capacidad de personalizaci√≥n potencia la influencia de los nodos en el proceso de finalizaci√≥n, contribuyendo a un consenso robusto y equilibrado.</p>
<p>En esencia, GRANDPA fusiona magistralmente la estructura misma de la cadena de bloques con el intrincado proceso de consenso, generando as√≠ un mecanismo seguro y responsable de finalizaci√≥n. La habilidad para concluir m√∫ltiples bloques, adaptarse √°gilmente a condiciones cambiantes en la red y otorgar a los nodos la posibilidad de influir en el proceso, lo sit√∫a como un pilar esencial en la arquitectura din√°mica de Polkadot y en la evoluci√≥n continua de las cadenas de bloques hacia un futuro prometedor.</p>
</li>
</ul>
<h2 id="substrate"><a class="header" href="#substrate">Substrate</a></h2>
<p>Las cadenas Substrate presentan tres caracter√≠sticas distintivas que las califican como &quot;de pr√≥xima generaci√≥n&quot;:</p>
<ul>
<li>Una funci√≥n de transici√≥n de estado din√°mica y autodefinida.</li>
<li>Funcionalidad de cliente ligero desde el primer d√≠a.</li>
<li>Un algoritmo de consenso progresivo con una r√°pida producci√≥n de bloques y una finalidad adaptativa y definida.</li>
</ul>
<p>La funci√≥n de transici√≥n de estado (STF), codificada en WebAssembly, se conoce como el &quot;tiempo de ejecuci√≥n&quot; (runtime). Esta define la funci√≥n <code>execute_block</code>, y puede especificar desde el algoritmo de staking, la sem√°ntica de transacciones, los mecanismos de registro y los procedimientos para reemplazar cualquier aspecto de s√≠ misma o del estado de la cadena (gobernanza). Debido a la total dinamicidad del tiempo de ejecuci√≥n, todos estos elementos pueden cambiarse o actualizarse en cualquier momento. En esencia, una cadena Substrate es comparable a un &quot;organismo vivo&quot;.</p>
<p>Para obtener m√°s informaci√≥n sobre Substrate, puedes <a href="https://www.parity.io/what-is-substrate/">consultar este enlace.</a>.</p>
<h3 id="explorando-las-posibilidades-de-substrate"><a class="header" href="#explorando-las-posibilidades-de-substrate">Explorando las Posibilidades de Substrate</a></h3>
<p>Substrate est√° dise√±ado para ser utilizado de tres maneras diferentes:</p>
<ol>
<li>
<p><strong>Sencilla:</strong> Se ejecuta el binario Substrate y se configura con un bloque g√©nesis que incluye el tiempo de ejecuci√≥n de demostraci√≥n actual. En este caso, simplemente construyes Substrate, configuras un archivo JSON y lanzas tu propia cadena de bloques. Esto te brinda un nivel m√≠nimo de personalizaci√≥n, permiti√©ndote principalmente cambiar los par√°metros g√©nesis de los diversos m√≥dulos de tiempo de ejecuci√≥n, como balances, staking, per√≠odo de bloque, tarifas y gobernanza.</p>
</li>
<li>
<p><strong>Modular:</strong> Se ensamblan paquetes (pallets) con Substrate FRAME para crear un nuevo tiempo de ejecuci√≥n, posiblemente alterando o reconfigurando la l√≥gica de generaci√≥n de bloques del cliente Substrate. Esto te otorga una gran cantidad de libertad sobre la l√≥gica de tu cadena de bloques, permiti√©ndote cambiar los tipos de datos, a√±adir o quitar m√≥dulos y, crucialmente, agregar tus propios m√≥dulos. Gran parte puede modificarse sin afectar la l√≥gica de generaci√≥n de bloques (pues es gen√©rica). En este caso, el binario Substrate existente puede usarse para la generaci√≥n de bloques y sincronizaci√≥n. Si es necesario ajustar la l√≥gica de generaci√≥n de bloques, ser√° necesario construir un nuevo binario de generaci√≥n de bloques modificado como proyecto independiente y utilizarlo para los validadores. Este enfoque se utiliza para la cadena de rel√©s de Polkadot y deber√≠a ser adecuado para la mayor√≠a de las circunstancias a corto y mediano plazo.</p>
</li>
<li>
<p><strong>Gen√©rico:</strong> Es posible ignorar completamente FRAME y dise√±ar e implementar el tiempo de ejecuci√≥n desde cero. Si se desea, esto puede hacerse en un lenguaje distinto de Rust, siempre y cuando pueda apuntar a WebAssembly. Si el tiempo de ejecuci√≥n es compatible con la l√≥gica de generaci√≥n de bloques del cliente existente, simplemente puedes construir un nuevo bloque g√©nesis a partir de tu fragmento de WebAssembly (Wasm) y lanzar tu cadena con el cliente Substrate existente basado en Rust. Si no es as√≠, ser√° necesario ajustar la l√≥gica de generaci√≥n de bloques del cliente seg√∫n corresponda. Esta opci√≥n es probablemente la menos utilizada por la mayor√≠a de los proyectos, pero ofrece una flexibilidad completa que permite un camino de actualizaci√≥n a largo plazo y de amplio alcance para el paradigma Substrate.</p>
</li>
</ol>
<p>Sin embargo, es importante destacar que Substrate tambi√©n establece normas y convenciones, especialmente en relaci√≥n con la Biblioteca de M√≥dulos de Runtime. En t√©rminos generales, estos tipos de datos fundamentales se corresponden con interfaces (&quot;traits&quot;) en lo que respecta al est√°ndar no negociable y estructuras gen√©ricas (&quot;structs&quot;) en lo que respecta a la convenci√≥n.</p>
<ul>
<li><strong>Encabezado:</strong> = Padre + ExtrinsicsRoot + StorageRoot + Digest</li>
<li><strong>Bloque:</strong> = Encabezado + Extrinsics + Justificaciones</li>
</ul>
<p>Con este conocimiento en mente, podemos sumergirnos en las complejidades de Madara y comprender mejor c√≥mo Substrate proporciona una base s√≥lida para su construcci√≥n.</p>
<h2 id="execution"><a class="header" href="#execution">Execution</a></h2>
<p>En la base de esta fascinante estructura se encuentra la capa de Ejecuci√≥n (Execution). Aqu√≠, la ejecuci√≥n de los bloques y la evoluci√≥n del state distaf toman forma. Lo impresionante de Madara es su habilidad para transitar sin esfuerzo entre dos enfoques de ejecuci√≥n: [Blockifier] de Starkware y [starknet_in_rust] de LambdaClass. Esta flexibilidad promete optimizaciones en constante evoluci√≥n, con la posibilidad de consolidar en un √∫nico enfoque a medida que el tiempo avance.</p>
<h2 id="settlement-eficiente"><a class="header" href="#settlement-eficiente">Settlement Eficiente</a></h2>
<p>En la din√°mica de un Validity Rollup, podemos usar la arquitectura de Madara se despliega magistralmente desde su estrato de Settlement. En esta genialidad t√©cnica, Madara no impone restricciones sobre las opciones disponibles para esta capa. </p>
<p>Para ilustrarlo con un ejemplo concreto, consideremos un escenario de nivel L3. </p>
<blockquote>
<p>Madara tiene la capacidad de orquestar la transmisi√≥n de pruebas peri√≥dicas hacia Starknet, espec√≠ficamente para un conjunto de bloques L3. El intervalo de aproximadamente ~ 5 horas para la liquidaci√≥n en Starknet, un par√°metro influenciado por los costos asociados con la liquidaci√≥n en Ethereum, adquiere un matiz de eficiencia extraordinaria. En contraposici√≥n, en una configuraci√≥n L3, se abre la posibilidad de establecer la liquidaci√≥n en Starknet en intervalos a√∫n m√°s frecuentes, lo cual conlleva una disminuci√≥n significativa en los costos operativos.</p>
</blockquote>
<p>Madara es el arquitecto de la cadena que permite erigir la totalidad de su estructura a partir de su capa de asentamiento. Se distingue por su enfoque agn√≥stico respecto a las capas de asentamiento, ofreciendo as√≠ un lienzo en blanco para las decisiones de dise√±o. Asimismo, dentro de este ecosistema, Madara proporciona el marco para establecer tanto la finalidad Hard como la Soft, una dualidad contextual que aporta versatilidad y adaptabilidad a la plataforma.</p>
<h2 id="sequencing-adaptativa"><a class="header" href="#sequencing-adaptativa">Sequencing Adaptativa</a></h2>
<p>La Secuenciaci√≥n (Sequencing), vital en el funcionamiento de Madara, es moldeable seg√∫n las necesidades. Las posibilidades son infinitas: desde esquemas sencillos First-Come-First-Served (FCFS) hasta enfoques m√°s sofisticados como Narwhall &amp; Bullshark o el intrigante HotStuff.</p>
<ul>
<li><strong>HotStuff:</strong> Basado en el protocolo de consenso PBFT (Practical Byzantine Fault Tolerance), HotStuff es una evoluci√≥n de PBFT dise√±ada para optimizar el rendimiento y la latencia. Introduce el &quot;consensus certificate&quot; y utiliza una estructura de √°rbol llamada &quot;fair chain&quot; para agilizar el proceso de consenso. Este enfoque permite lograr consenso con menor latencia y n√∫mero reducido de mensajes.</li>
</ul>
<p>En el contexto de la secuenciaci√≥n, el orden de las transacciones desempe√±a un papel crucial para proteger contra ataques MEV y asegurar una distribuci√≥n equitativa. Las aplicaciones espec√≠ficas pueden incluso implementar estrategias como memorias encriptadas para garantizar un orden equitativo.</p>
<h2 id="fundamentos-de-disponibilidad-de-datos"><a class="header" href="#fundamentos-de-disponibilidad-de-datos">Fundamentos de Disponibilidad de Datos</a></h2>
<p>En Madara, se est√°n explorando diversos esquemas de DA para garantizar la integridad y accesibilidad de la informaci√≥n.</p>
<ul>
<li><strong>Validium:</strong> Este enfoque implica datos con disponibilidad off-chain, administrados por un Comit√© conocido como Data Availability Committee (DAC). Este comit√© se encarga de asegurar que los datos est√©n disponibles y se mantengan fuera de la cadena principal.</li>
<li><strong>Rollup:</strong> Aqu√≠, los datos tienen disponibilidad on-chain, siguiendo una din√°mica similar a lo que estamos familiarizados con los Validity Rollup. En este caso, se almacena la diferencia de estado (state delta) en la cadena Ethereum.</li>
<li><strong>Volition:</strong> Ofrece una alternativa personalizada y h√≠brida, permitiendo a los usuarios decidir qu√© datos desean guardar en la capa L1 de Ethereum y cu√°les mantener off-chain. Adem√°s, brinda la opci√≥n de autohospedar sus propios datos o alojarlos en otros esquemas de gesti√≥n de datos, como <strong>Celestia</strong> o <strong>Eigen DA.</strong></li>
</ul>
<p>Estos enfoques en la disponibilidad de datos no solo demuestran la versatilidad y capacidad de adaptaci√≥n de Madara, sino que tambi√©n allanan el camino hacia soluciones m√°s eficientes y escalables dentro del ecosistema de Starknet y otros entornos. En estos contextos, Madara puede ser empleada como punto de entrada para capitalizar la potencia de Cairo y los STARKs, brindando nuevas oportunidades para impulsar la innovaci√≥n y el crecimiento tecnol√≥gico.</p>
<h2 id="dise√±o-de-gobernanza-robusta-en-madara-y-starknet"><a class="header" href="#dise√±o-de-gobernanza-robusta-en-madara-y-starknet">Dise√±o de Gobernanza Robusta en Madara y Starknet</a></h2>
<p>En el contexto de Starknet y Madara, se est√° llevando a cabo un proceso de descentralizaci√≥n tanto en la infraestructura de red como en la toma de decisiones del protocolo. Esta iniciativa tiene como objetivo primordial fortalecer la participaci√≥n y el empoderamiento de la comunidad en el desarrollo y las decisiones clave.</p>
<p>Uno de los elementos esenciales de Madara es Snapshot X, que establece un sistema completamente en cadena basado en s√≥lidas pruebas de almacenamiento. Esta estrategia de gobernanza ha demostrado su efectividad en diversas situaciones, incluyendo casos como el de Turbo VM. Las pruebas de almacenamiento se presentan como el principal mecanismo de conexi√≥n en el ecosistema de Madara, garantizando la integridad de las resoluciones tomadas por la comunidad.</p>
<p>Adem√°s, Madara se encuentra en proceso de exploraci√≥n de alternativas, tales como el m√≥dulo de gobernanza nativa de Substrate. Aprendiendo de lecciones valiosas provenientes de plataformas exitosas, Madara reconoce la trascendencia de mantener una gobernanza en cadena, en l√≠nea con la filosof√≠a observada en ecosistemas como Cosmos y Polkadot.</p>
<p>En busca de una gobernanza m√°s inclusiva y efectiva, Madara considera la adopci√≥n de herramientas avanzadas como <a href="https://wiki.polkadot.network/docs/learn-polkadot-opengov">OpenGov</a> y <a href="https://docs.rs/pallet-democracy/latest/pallet_democracy/">Pallet Democracy</a>. Estas herramientas permiten una toma de decisiones participativa y adaptable a trav√©s de la delegaci√≥n y la participaci√≥n directa de la comunidad.</p>
<ul>
<li>
<p><strong>OpenGov:</strong> Dentro del ecosistema de Polkadot, OpenGov promueve la inclusi√≥n al permitir que cualquier miembro de la comunidad proponga y vote en referendos. Basado en 15 Trayectorias √∫nicas, cada una con reglas predefinidas, OpenGov permite que las propuestas sean evaluadas y votadas por expertos en √°reas espec√≠ficas. Esto asegura que incluso aquellos menos familiarizados con los aspectos t√©cnicos puedan influir en las decisiones clave.</p>
</li>
<li>
<p><strong>Pallet Democracy:</strong> Este paquete se encarga de la administraci√≥n de las votaciones generales de los stakeholders. A trav√©s de un proceso en dos colas, las propuestas son transformadas en referendos. Cualquier titular de tokens puede votar, utilizando un sistema de bloqueo temporal para expresar su convicci√≥n en las decisiones. La flexibilidad y la adaptabilidad son elementos clave de este enfoque.</p>
</li>
</ul>
<p>Esta convergencia entre Madara y Starknet resalta la vital importancia de la descentralizaci√≥n y la gobernanza activa en la evoluci√≥n de estos ecosistemas. La prometedora trayectoria de ambas plataformas se moldea a trav√©s de la colaboraci√≥n y la participaci√≥n comunitaria en la toma de decisiones.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="madara---fusionando-fuerzas-"><a class="header" href="#madara---fusionando-fuerzas-">Madara - Fusionando Fuerzas üöß</a></h1>
<p>En esta secci√≥n, exploraremos la poderosa alianza entre Madara y Kakarot, culminando en la creaci√≥n de L3 zkEVMs en la red de Starknet. Este hito marca un paso crucial hacia un futuro de escalabilidad y modularidad en el √°mbito de las cadenas de bloques, abriendo la puerta a un panorama en constante evoluci√≥n. Aqu√≠, los equipos pueden implementar cadenas de aplicaciones (dApp Chains) zkEVM y aprovechar las Pruebas de Validez para garantizar transacciones seguras en Starknet.</p>
<p>La asociaci√≥n entre Kakarot y Madara cobra vida como una sinergia cautivadora, a pesar de ser componentes completamente distintos. Pero, ¬øc√≥mo se entrelazan estos elementos en un tejido coherente que impulsa el futuro de la tecnolog√≠a blockchain? La respuesta reside en la capacidad de integrar Kakarot con Madara, lo que nos brinda un abanico de oportunidades diversas.</p>
<p>Imagina a Madara como el s√≥lido cimiento, un sustrato fundamental que establece las bases para futuras dApp Chains, secuenciadores descentralizados y una variedad de opciones en diferentes capas. Detallamos la gesti√≥n en la capa de DA en el cap√≠tulo anterior, que puedes revisar en <a href="/Book-Starkware/src/Madara.html#fundamentos-de-data-availability">Madara - Fundamentos de DA</a>.</p>
<p>Estas bases, que pueden optimizarse desde el componente de Madara gracias a Substrate y los Pallets, logran mejorar las caracter√≠sticas de escalabilidad, modularidad y seguridad, formando as√≠ una plataforma s√≥lida y lista para recibir nuevas capas de innovaci√≥n.</p>
<p>Por otro lado, Kakarot asume el papel de un manto creativo, siendo la zkEVM en Starkent capaz de interpretar el lenguaje de Solidity y ejecutarlo en Cairo. Ambas capas o componentes est√°n protegidos por Validity Proof, donde en este caso, los STARKs aseguran la integridad de los datos, mientras que otros elementos potencian la descentralizaci√≥n y la eficiencia.</p>
<p>Esta simbiosis entre Madara y Kakarot establece los cimientos para un futuro emocionante y din√°mico en el universo de las cadenas de bloques, allanando el camino hacia una mayor adopci√≥n y evoluci√≥n tecnol√≥gica.</p>
<h2 id="la-fusi√≥n-de-madara-y-kakarot"><a class="header" href="#la-fusi√≥n-de-madara-y-kakarot">La Fusi√≥n de Madara y Kakarot</a></h2>
<p>La fusi√≥n de ambos componentes da lugar a una L3 zkEVM. El impacto de L3 zkEVM trasciende la mera innovaci√≥n tecnol√≥gica. Su importancia radica en la descentralizaci√≥n y la seguridad que brinda. Al lograr altos niveles de seguridad sin depender de una multitud de validadores, se establece una nueva norma en la industria. La descentralizaci√≥n se convierte en una poderosa arma contra la censura y la vulnerabilidad, elementos fundamentales a menudo pasados por alto en la b√∫squeda de soluciones de cadena de bloques.</p>
<p>El viaje apenas comienza con L3 zkEVM. La armon√≠a entre Madara y Kakarot allana el camino para futuras evoluciones, incluyendo L4, L5 y m√°s all√°. La modularidad de Substrate otorga a Kakarot la libertad de innovar en protocolos de consenso, mientras que las actualizaciones de tiempo de ejecuci√≥n sin bifurcaciones en Substrate permiten una adaptaci√≥n fluida del EVM.</p>
<p>La colaboraci√≥n entre Madara y Kakarot tambi√©n da lugar a posibilidades avanzadas, como la creaci√≥n de zkEVM tipo 1. Mediante la incorporaci√≥n de las reglas de consenso de Ethereum en Cairo dentro del nodo completo Madara x Kakarot y el cambio a Keccak MPT, Kakarot puede convertirse en un cliente zkEVM tipo 1 capaz de probar bloques L1. Aunque este es un caso de uso m√°s avanzado que depende de la hoja de ruta de Ethereum, muestra c√≥mo la innovaci√≥n puede seguir floreciendo.</p>
<h3 id="optimizando-la-eficiencia-con-l3-zkevm"><a class="header" href="#optimizando-la-eficiencia-con-l3-zkevm">Optimizando la Eficiencia con L3 zkEVM</a></h3>
<p>Un aspecto subestimado pero crucial de L3 zkEVM es su capacidad para desacoplar seguridad y descentralizaci√≥n. Aprovechando el enfoque de Prueba de Validez de Kakarot, los usuarios pueden disfrutar de niveles de seguridad comparables a Ethereum L1 sin requerir la misma cantidad de validadores. La descentralizaci√≥n, con su resistencia y capacidad anti-censura, sigue siendo esencial, y se logra a trav√©s de un secuenciador establecido en cientos en lugar de miles.</p>
<p>La eficiencia se multiplica a√∫n m√°s gracias a la computaci√≥n en capas, lo que resulta en costos de gas exponencialmente m√°s bajos que en L2 y un mayor rendimiento (TPS). Esta escalabilidad acumulativa allana el camino para una escalada m√°s all√° de L3, abriendo la puerta a futuras evoluciones.</p>
<p>Para reducir a√∫n m√°s los costos de gas y mejorar la disponibilidad de datos, se plantea la separaci√≥n de verificaci√≥n de pruebas y DA. Mientras que Starknet L2 puede servir como una capa de verificaci√≥n de prueba segura, soluciones innovadoras como Celestia o EigenDA pueden utilizarse para publicar datos de transacciones de manera rentable.</p>
<h2 id="explorando-horizontes-de-investigaci√≥n"><a class="header" href="#explorando-horizontes-de-investigaci√≥n">Explorando Horizontes de Investigaci√≥n</a></h2>
<p>Madara se destaca como un faro de innovaci√≥n en el vasto oc√©ano de la tecnolog√≠a blockchain. Sus capas y componentes se entrelazan en una sinfon√≠a de eficiencia, seguridad y escalabilidad. Esta colaboraci√≥n con Kakarot da forma a un futuro vibrante, donde los zkEVMs florecen y la cadena de bloques alcanza nuevas alturas. A medida que Madara contin√∫a su evoluci√≥n, anticipamos con entusiasmo las haza√±as que el futuro tiene reservadas para esta extraordinaria creaci√≥n.</p>
<p>El viaje en la arquitectura Madara no se detiene aqu√≠, se est√°n explorando temas intrigantes, como la comunicaci√≥n de cross-rollups aprovechando el protocolo de mensajer√≠a de Substrate. La uni√≥n de Madara y Kakarot representa una sinergia poderosa, sentando las bases para una evoluci√≥n constante en el ecosistema blockchain. Cada avance y cada innovaci√≥n en esta colaboraci√≥n allana el camino para un futuro donde la seguridad, la descentralizaci√≥n y la escalabilidad convergen en un todo armonioso.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sharingan"><a class="header" href="#sharingan">Sharingan</a></h1>
<p>En este cap√≠tulo hablaremos como Sharingan representa una innovadora y transitoria testnet al servicio de Starknet, donde la totalidad de las entidades nodales que conforman la infraestructura son encarnaciones virtuales de Madara. En este entorno de pruebas, la funcionalidad de Starknet es sometida a rigurosas pruebas de campo en un paradigma descentralizado, en el cual los nodos colaboran armoniosamente para determinar la continuaci√≥n de la cadena mediante un proceso de consenso. La arquitectura subyacente de Sharingan se apoya en la utilizaci√≥n de lo que denominamos <strong>secuenciadores</strong>, elementos cruciales responsables de la producci√≥n, validaci√≥n y anexi√≥n de bloques en la cadena de bloques.</p>
<p>No obstante, es importante destacar que algunos nodos dentro de este ecosistema tienen un rol espec√≠fico en el almacenamiento y retenci√≥n de datos, sin involucrarse activamente en las decisiones de consenso.</p>
<p>Si bien Madara se refiere com√∫nmente como el <strong>Secuenciador</strong> en el contexto de Starknet, es relevante establecer una distinci√≥n intr√≠nseca en Sharingan entre dos categor√≠as de nodos:</p>
<ol>
<li><strong>Madara en calidad de Secuenciador</strong>: Part√≠cipe activo en el proceso de consenso y toma de decisiones.</li>
<li><strong>Madara en calidad de Fullnode</strong>: Contribuyente a la persistencia y almacenamiento de datos en la red.</li>
</ol>
<p>El prop√≥sito fundamental que subyace a Sharingan consiste en inaugurar un cap√≠tulo de pruebas descentralizadas para Starknet y, simult√°neamente, proporcionar un acceso inclusivo y participativo a todos los actores interesados en experimentar con la red Starknet.</p>
<p>Para facilitar la interacci√≥n con la red Starknet, los nodos Starknet ofrecen una interfaz de programaci√≥n de aplicaciones (API) en formato JSON RPC. Como consecuencia, cada instancia de Madara que contribuye al entorno de Sharingan posee un puerto expuesto, dise√±ado para admitir la comunicaci√≥n externa.</p>
<p>Se distinguen un total de seis secuenciadores reconocidos dentro del contexto de Sharingan, aunque siempre revise documentaci√≥n ofical para estar actualizados:</p>
<div class="table-wrapper"><table><thead><tr><th>Mantenedor</th><th>ID</th><th>Alias de clave</th><th>IP</th><th>ID de par</th><th>Puerto RPC</th></tr></thead><tbody>
<tr><td>Starkware</td><td>1</td><td>alice</td><td><code>52.7.206.208</code></td><td><code>12D3KooWJytWW4wqhG1xp9ckLb7B15KqDU24Q8HHo8VfwXmFe5ZE</code></td><td><code>9933</code></td></tr>
<tr><td>Starkware</td><td>2</td><td>bob</td><td><code>44.195.161.82</code></td><td><code>12D3KooWHocNfvLz6rgpb8wJsynSpMwkspkcRn6gmN5UiK1tTTeG</code></td><td><code>9933</code></td></tr>
<tr><td>Cartridge</td><td>3</td><td>charlie</td><td><code>208.67.222.222</code></td><td><code>12D3KooWQe2ZtqiyC5CLJKZr9i9xTmEyiAikZcr5J18w3cG1dQAc</code></td><td><code>9933</code></td></tr>
<tr><td>LambdaClass</td><td>4</td><td>dave</td><td><code>65.109.91.29</code></td><td><code>12D3KooWK8QhFjkGYGyMskDuCyaS1nrhfTfadMeRjJkox4SV32co</code></td><td><code>9933</code></td></tr>
<tr><td>Pragma</td><td>5</td><td>eve</td><td><code>13.39.22.82</code></td><td><code>12D3KooWGMCGJ517tFor12U9n2v3ax5WNw1pXFdj48hSHYQe6oyJ</code></td><td><code>9933</code></td></tr>
<tr><td>Kakarot</td><td>6</td><td>ferdie</td><td><code>52.50.242.182</code></td><td><code>12D3KooWHnQ8LC113DgB5cVVyx2mvTN7bBkm75zvzsndr2WhstEE</code></td><td><code>9933</code></td></tr>
</tbody></table>
</div>
<p>Este selecto grupo de secuenciadores desempe√±a un papel crucial en la gobernanza y operaci√≥n de Sharingan, aportando una diversidad de perspectivas y recursos para enriquecer el desarrollo y evoluci√≥n de Starknet en su trayectoria hacia la descentralizaci√≥n.</p>
<h2 id="explorando-los-recursos-de-sharingan"><a class="header" href="#explorando-los-recursos-de-sharingan">Explorando los Recursos de Sharingan</a></h2>
<p>A continuaci√≥n, proporcionamos un enlace hacia una <a href="https://github.com/Nadai2010/Nadai-StarknetEs-Sharingan/blob/master/Gu%C3%ADa-StarknetEs.md">gu√≠a exhaustiva en espa√±ol</a> que le brindar√° una orientaci√≥n detallada sobre su utilizaci√≥n.</p>
<p>Dentro del marco de esta gu√≠a, examinaremos una porci√≥n selecta para ilustrar el funcionamiento. Una vez que hayamos establecido una configuraci√≥n precisa, nos aventuraremos a conectarnos a la interfaz RPC mediante un comando, es importante se√±alar que tenemos la capacidad de configurar cualquiera de los seis operadores previamente mencionados, siempre y cuando est√©n operativos.</p>
<p>Realicemos una demostraci√≥n pr√°ctica al invocar el m√©todo <code>starknet_blockHashAndNumber</code> a trav√©s del operador de Starkware, con el prop√≥sito de obtener informaci√≥n crucial acerca de un bloque en la red.</p>
<pre><code class="language-bash">curl --header &quot;Content-Type: application/json&quot; \
  --request POST \
  --data '{
   &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;starknet_blockHashAndNumber&quot;,
    &quot;params&quot;: [],
    &quot;id&quot;:1
}' http://52.7.206.208:9933
</code></pre>
<p>La respuesta obtenida deber√° proporcionar el hash del bloque m√°s reciente, junto con su n√∫mero de bloque e identificador:</p>
<p><img src="./assets/Sharingan.png" alt="graph" /></p>
<div align="center">
</div>
<p>Avanzando, exploramos otro ejemplo, en este caso, empleamos <code>starknet_getBlockWithTxHashes</code> para obtener el bloque m√°s reciente, acompa√±ado por su hash relacionado, el estado actual de la transacci√≥n, el timestamp (sello de tiempo) y la direcci√≥n del secuenciador.</p>
<pre><code class="language-bash">curl --header &quot;Content-Type: application/json&quot; \
  --request POST \
  --data '{
   &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;starknet_getBlockWithTxHashes&quot;,
    &quot;params&quot;: [
        &quot;latest&quot;
    ],
    &quot;id&quot;:1
}' http://52.7.206.208:9933
</code></pre>
<p>La respuesta a esta consulta deber√° seguir la estrucutra de salida de la siguiente imagen:</p>
<p><img src="./assets/Sharingan2.png" alt="graph" /></p>
<div align="center">
</div>
<p>En √∫ltima instancia, proporcionamos el enlace directo al documento hospedado en el repositorio oficial. Este recurso le permitir√° mantenerse al tanto de las actualizaciones m√°s recientes y acceder al <a href="https://github.com/keep-starknet-strange/madara/blob/main/docs/sharingan-starter-pack.md">Sharingan Starter Pack</a> para examinar los <strong>Comandos y Recomendaciones actualizadas</strong>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="otros-secuenciadores-"><a class="header" href="#otros-secuenciadores-">Otros Secuenciadores üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="katana-"><a class="header" href="#katana-">Katana üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="radius-"><a class="header" href="#radius-">Radius üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="otros-prover-"><a class="header" href="#otros-prover-">Otros Prover üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sandstorm-"><a class="header" href="#sandstorm-">Sandstorm üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kakarot-"><a class="header" href="#kakarot-">Kakarot üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dojo-"><a class="header" href="#dojo-">Dojo: üöß</a></h1>
<p>Este cap√≠tulo nos sumerge en el intrigante universo del motor Dojo y su capacidad para revolucionar los juegos demostrables. Desglosaremos los conceptos emergentes de mundos aut√≥nomos y juegos probables a trav√©s de una secci√≥n especial dedicada a la Teor√≠a. Dojo, impulsado por colaboradores destacados como Cartridge, Realms &amp; BibliothecaDAO, briq y muchos otros, es una iniciativa de c√≥digo abierto con licencia MIT.</p>
<h2 id="un-motor-para-crear-mundos-aut√≥nomos"><a class="header" href="#un-motor-para-crear-mundos-aut√≥nomos">Un Motor para Crear Mundos Aut√≥nomos</a></h2>
<p>Dojo es una herramienta poderosa que trasciende los l√≠mites de un motor de juegos convencional. Su dise√±o est√° enfocado en la creaci√≥n de juegos y mundos aut√≥nomos en la cadena de bloques utilizando la versatilidad de Cairo. Incorpora un sistema innovador de componentes de entidades y adopta el patr√≥n diamante, lo que facilita la construcci√≥n de entornos modulares y escalables. La esencia de Dojo radica en la incorporaci√≥n de Componentes (estado) y Sistemas (l√≥gica) que dan vida a estos mundos digitales. Su arquitectura se inspira en la brillantez del motor Bevy.</p>
<h2 id="caracter√≠sticas-clave-y-futuro-prometedor"><a class="header" href="#caracter√≠sticas-clave-y-futuro-prometedor">Caracter√≠sticas Clave y Futuro Prometedor</a></h2>
<p>Dojo destaca por su Sistema de Componentes de Entidades (ECS) basado en Cairo 1.0, as√≠ como por elementos clave como Sozo, Torii y Katana que impulsan la red y la indexaci√≥n. Adem√°s, Dojo ofrece SDKs tipados para un desarrollo eficiente. Este proyecto de c√≥digo abierto se encuentra en sus fases iniciales de desarrollo y acoge con entusiasmo a colaboradores de todos los niveles. Dojo se erige como una respuesta a las lecciones aprendidas en la b√∫squeda de construir juegos en cadena, aligerando la carga de la infraestructura compleja y permitiendo a los desarrolladores centrarse en la esencia de sus creaciones. Los juegos demostrables demandan propiedades de conocimiento cero (ZK) para su escalabilidad y verificaci√≥n de c√°lculos eficiente. Cairo, un lenguaje vers√°til, es la piedra angular que facilita este proceso, eliminando la complejidad de crear circuitos para integrar SNARKs. As√≠, programar en Cairo se traduce en aplicaciones autom√°ticamente demostrables. Adem√°s, Dojo ofrece una versatilidad excepcional en cuanto a implementaci√≥n. Puedes llevar tus programas a la M√°quina Virtual Cairo (CVM), que es compatible con la Capa 2 de Starknet y las appchains de Starknet. Incluso puedes llevar tus creaciones al navegador a trav√©s de WebAssembly (WASM). Dojo est√° dise√±ado para impulsar el desarrollo de juegos en m√∫ltiples contextos, aportando primitivas de conocimiento cero (ZK). A medida que el proyecto avanza, su objetivo es empoderar a los desarrolladores, acortando dr√°sticamente el tiempo necesario para crear juegos en cadena y Mundos Aut√≥nomos (AWs), convirtiendo semanas de trabajo en un proceso eficiente de horas. Acomp√°√±anos en esta emocionante traves√≠a hacia el futuro del entretenimiento digital con Dojo. ¬°El horizonte de los juegos demostrables y mundos aut√≥nomos espera ser explorado! üåü</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="giza-"><a class="header" href="#giza-">Giza üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orion-"><a class="header" href="#orion-">Orion üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cartridge-"><a class="header" href="#cartridge-">Cartridge üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vistara-"><a class="header" href="#vistara-">Vistara üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="servicios-api-"><a class="header" href="#servicios-api-">Servicios API üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="infura"><a class="header" href="#infura">Infura</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alchemy"><a class="header" href="#alchemy">Alchemy</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexer"><a class="header" href="#indexer">Indexer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checkpoint-"><a class="header" href="#checkpoint-">Checkpoint üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apibara-"><a class="header" href="#apibara-">Apibara üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokenflow-"><a class="header" href="#tokenflow-">TokenFlow üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="torii-"><a class="header" href="#torii-">Torii üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dapp---ecosistema-"><a class="header" href="#dapp---ecosistema-">Dapp - Ecosistema üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="avnu"><a class="header" href="#avnu">Avnu</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursos"><a class="header" href="#recursos">Recursos</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cairo-by-example"><a class="header" href="#cairo-by-example">Cairo by Example</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="challengues"><a class="header" href="#challengues">Challengues</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cairo-book"><a class="header" href="#cairo-book">Cairo book</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-book"><a class="header" href="#starknet-book">Starknet book</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starkli-"><a class="header" href="#starkli-">Starkli üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scarb-"><a class="header" href="#scarb-">Scarb üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oz---wizard-"><a class="header" href="#oz---wizard-">OZ - Wizard üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="remix---starknet-"><a class="header" href="#remix---starknet-">Remix - Starknet üöß</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknetjs-"><a class="header" href="#starknetjs-">Starknet.js üöß</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>

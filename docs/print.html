<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>L2 Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="IntroducciÃ³n.html"><strong aria-hidden="true">1.</strong> IntroducciÃ³n Parte 1</a></li><li class="chapter-item "><a href="Bases_CriptogrÃ¡ficas.html"><strong aria-hidden="true">2.</strong> Bases CriptogrÃ¡ficas</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="CriptografÃ­a_SimÃ©trica.html"><strong aria-hidden="true">2.1.</strong> CriptografÃ­a SimÃ©trica</a></li><li class="chapter-item "><a href="CriptografÃ­a_AsimÃ©trica.html"><strong aria-hidden="true">2.2.</strong> CriptografÃ­a AsimÃ©trica</a></li><li class="chapter-item "><a href="CriptografÃ­a_HÃ­bridas.html"><strong aria-hidden="true">2.3.</strong> CriptografÃ­a HÃ­bridas</a></li><li class="chapter-item "><a href="Firmas_Digitales.html"><strong aria-hidden="true">2.4.</strong> Firmas Digitales</a></li><li class="chapter-item "><a href="Generador_de_Claves.html"><strong aria-hidden="true">2.5.</strong> Generador de Claves</a></li><li class="chapter-item "><a href="Funciones_Hash.html"><strong aria-hidden="true">2.6.</strong> Funciones Hash</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Merkle_Tree_en_Blockchain.html"><strong aria-hidden="true">2.6.1.</strong> Merkle Tree en Blockchain</a></li><li class="chapter-item "><a href="Patricia_Merkle_Trie.html"><strong aria-hidden="true">2.6.2.</strong> Patricia Merkle Trie</a></li><li class="chapter-item "><a href="Sha256.html"><strong aria-hidden="true">2.6.3.</strong> SHA-256</a></li><li class="chapter-item "><a href="Keccak.html"><strong aria-hidden="true">2.6.4.</strong> Keccak - El nuevo SHA-3</a></li></ol></li><li class="chapter-item "><a href="Quantum_Secure.html"><strong aria-hidden="true">2.7.</strong> Quantum Secure</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Grover.html"><strong aria-hidden="true">2.7.1.</strong> Grover</a></li><li class="chapter-item "><a href="Shor.html"><strong aria-hidden="true">2.7.2.</strong> Shor</a></li><li class="chapter-item "><a href="Lattice.html"><strong aria-hidden="true">2.7.3.</strong> Lattice</a></li><li class="chapter-item "><a href="Kyber_Crystal.html"><strong aria-hidden="true">2.7.4.</strong> Kyber Crystal</a></li><li class="chapter-item "><a href="EOA_AA.html"><strong aria-hidden="true">2.7.5.</strong> EOA y AA - Firmantes</a></li></ol></li><li class="chapter-item "><a href="Starknet_AA.html"><strong aria-hidden="true">2.8.</strong> Starknet AA</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Stark_Curve.html"><strong aria-hidden="true">2.8.1.</strong> EC en Cairo - STARK Curve</a></li><li class="chapter-item "><a href="Secp256r1.html"><strong aria-hidden="true">2.8.2.</strong> MyBraavos Secp256r1</a></li><li class="chapter-item "><a href="Stark_Key.html"><strong aria-hidden="true">2.8.3.</strong> CreaciÃ³n de una Stark Key en StarkEx</a></li></ol></li><li class="chapter-item "><a href="Starknet_funciones_hash.html"><strong aria-hidden="true">2.9.</strong> Starknet y Funciones Hash</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Keccak_Starknet.html"><strong aria-hidden="true">2.9.1.</strong> Hash Keccak</a></li><li class="chapter-item "><a href="Pedersen_Starknet.html"><strong aria-hidden="true">2.9.2.</strong> Hash Pedersen</a></li><li class="chapter-item "><a href="Poseidon_Starknet.html"><strong aria-hidden="true">2.9.3.</strong> Hash Poseidon</a></li><li class="chapter-item "><a href="Hashing_Array.html"><strong aria-hidden="true">2.9.4.</strong> Hashing de Array</a></li></ol></li><li class="chapter-item "><a href="Starks.html"><strong aria-hidden="true">2.10.</strong> S-T-ARKs</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Starks_Propiedades.html"><strong aria-hidden="true">2.10.1.</strong> Propiedades de las STARKs</a></li><li class="chapter-item "><a href="Starks_Eficientes.html"><strong aria-hidden="true">2.10.2.</strong> STARKs eficientes</a></li><li class="chapter-item "><a href="Starks_Iops.html"><strong aria-hidden="true">2.10.3.</strong> IOPs</a></li><li class="chapter-item "><a href="Starks_Polinomios.html"><strong aria-hidden="true">2.10.4.</strong> Polinomios</a></li></ol></li><li class="chapter-item "><a href="Starks_Creacion.html"><strong aria-hidden="true">2.11.</strong> CreaciÃ³n de un STARK</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Starks_Aritmetizacion.html"><strong aria-hidden="true">2.11.1.</strong> AritmetizaciÃ³n</a></li><li class="chapter-item "><a href="Starks_Traza.html"><strong aria-hidden="true">2.11.2.</strong> Polinomio y ComposiciÃ³n para nuestra Traza</a></li><li class="chapter-item "><a href="Starks_Bajo.html"><strong aria-hidden="true">2.11.3.</strong> Pruebas de Bajo Grado</a></li><li class="chapter-item "><a href="Starks_Fri.html"><strong aria-hidden="true">2.11.4.</strong> FRI</a></li></ol></li><li class="chapter-item "><a href="Cairo.html"><strong aria-hidden="true">2.12.</strong> Leve introducciÃ³n a Cairo (AIR)</a></li><li class="chapter-item "><a href="ConclusiÃ³n.html"><strong aria-hidden="true">2.13.</strong> Conclusiones</a></li></ol></li><li class="chapter-item "><a href="IntroducciÃ³n2.html"><strong aria-hidden="true">3.</strong> IntroducciÃ³n Parte 2 ğŸš§</a></li><li class="chapter-item "><a href="Arquitectura_Starknet.html"><strong aria-hidden="true">4.</strong> Arquitectura Starknet y Cairo ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Componentes.html"><strong aria-hidden="true">4.1.</strong> Componentes ğŸš§</a></li><li class="chapter-item "><a href="Secuenciadores.html"><strong aria-hidden="true">4.2.</strong> Secuenciadores ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Secuenciadores_Rust.html"><strong aria-hidden="true">4.2.1.</strong> Secuenciadores Basados en RustğŸš§</a></li><li class="chapter-item "><a href="Madara_Base.html"><strong aria-hidden="true">4.2.2.</strong> Madara - Bases de su arquitectura ğŸš§</a></li><li class="chapter-item "><a href="Kraken.html"><strong aria-hidden="true">4.2.3.</strong> Kraken - Secuencenciador descentralizadoğŸš§</a></li></ol></li><li class="chapter-item "><a href="Fullnode.html"><strong aria-hidden="true">4.3.</strong> Full Nodes - Starknet Stack ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Pathfinder.html"><strong aria-hidden="true">4.3.1.</strong> Pathfinder ğŸš§</a></li><li class="chapter-item "><a href="Juno.html"><strong aria-hidden="true">4.3.2.</strong> Juno ğŸš§</a></li><li class="chapter-item "><a href="Deoxys.html"><strong aria-hidden="true">4.3.3.</strong> Deoxys ğŸš§</a></li><li class="chapter-item "><a href="Papyrus.html"><strong aria-hidden="true">4.3.4.</strong> Papyrus ğŸš§</a></li></ol></li><li class="chapter-item "><a href="SHARP.html"><strong aria-hidden="true">4.4.</strong> SHARP ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="SHARP_Recursividad.html"><strong aria-hidden="true">4.4.1.</strong> Recursividad - SHARP ğŸš§</a></li><li class="chapter-item "><a href="SHARP_Componentes.html"><strong aria-hidden="true">4.4.2.</strong> Componentes - SHARP ğŸš§</a></li><li class="chapter-item "><a href="Playground.html"><strong aria-hidden="true">4.4.3.</strong> Playground ğŸš§</a></li><li class="chapter-item "><a href="Cairo_Verifier_Rust.html"><strong aria-hidden="true">4.4.4.</strong> Cairo Verifier - Rust ğŸš§</a></li></ol></li><li class="chapter-item "><a href="Quantum_Leap.html"><strong aria-hidden="true">4.5.</strong> Quantum Leap ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Versiones.html"><strong aria-hidden="true">4.5.1.</strong> Versiones ğŸš§</a></li></ol></li><li class="chapter-item "><a href="Starknet_Stack.html"><strong aria-hidden="true">4.6.</strong> Starknet Stack ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Appchain_Paradex.html"><strong aria-hidden="true">4.6.1.</strong> AppChain Paradex - Starknet Stack ğŸš§</a></li><li class="chapter-item "><a href="Lambda_Stack.html"><strong aria-hidden="true">4.6.2.</strong> Lambda Starknet Stack ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Watcher_Prover.html"><strong aria-hidden="true">4.6.2.1.</strong> Watcher-Prover ğŸš§</a></li></ol></li></ol></li><li class="chapter-item "><a href="DA.html"><strong aria-hidden="true">4.7.</strong> Data Avalability ğŸš§</a></li><li class="chapter-item "><a href="EVM_zkEVM.html"><strong aria-hidden="true">4.8.</strong> EVM vs zkEVM ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Kakarot_Base.html"><strong aria-hidden="true">4.8.1.</strong> Kakarot - Bases de su arquitectura ğŸš§</a></li></ol></li><li class="chapter-item "><a href="VM_Cairo.html"><strong aria-hidden="true">4.9.</strong> VM de Cairo ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Builtins_y_mecanismos_de_fee.html"><strong aria-hidden="true">4.9.1.</strong> Builtins y Mecanismos de Fee ğŸš§</a></li><li class="chapter-item "><a href="Sierra.html"><strong aria-hidden="true">4.9.2.</strong> Sierra - IR ğŸš§</a></li><li class="chapter-item "><a href="Cairo_Native.html"><strong aria-hidden="true">4.9.3.</strong> Cairo Native - MLIR ğŸš§</a></li></ol></li><li class="chapter-item "><a href="Storage_Proof.html"><strong aria-hidden="true">4.10.</strong> Herodotus - Storage Proof ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Arquitectura_Herodotus.html"><strong aria-hidden="true">4.10.1.</strong> Arquitectura Herodotus ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Commitments_Inbox.html"><strong aria-hidden="true">4.10.1.1.</strong> Commitments Inbox ğŸš§</a></li><li class="chapter-item "><a href="Headers_Store.md.html"><strong aria-hidden="true">4.10.1.2.</strong> Headers Store ğŸš§</a></li><li class="chapter-item "><a href="Facts_Registry.html"><strong aria-hidden="true">4.10.1.3.</strong> Facts Registry ğŸš§</a></li></ol></li><li class="chapter-item "><a href="Herodotus_Turbo.html"><strong aria-hidden="true">4.10.2.</strong> Herodotus Turbo ğŸš§</a></li><li class="chapter-item "><a href="Casos_de_uso.html"><strong aria-hidden="true">4.10.3.</strong> Casos de Usos ğŸš§</a></li><li class="chapter-item "><a href="Ejemplos_Storage_Proof.html"><strong aria-hidden="true">4.10.4.</strong> Ejemplos Storage Proof ğŸš§</a></li><li class="chapter-item "><a href="Proyectos_Storage_Proof.html"><strong aria-hidden="true">4.10.5.</strong> Proyectos SHH y Hackaton ğŸš§</a></li><li class="chapter-item "><a href="Merkle_Mountain_Ranges.html"><strong aria-hidden="true">4.10.6.</strong> Merkle Mountain Ranges en Cairo ğŸš§</a></li><li class="chapter-item "><a href="Storage_Proof_Oracle.html"><strong aria-hidden="true">4.10.7.</strong> Storage Proof Vs Oracle ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Estado_Oracle_Starknet.html"><strong aria-hidden="true">4.10.7.1.</strong> Estado de Oracles en Starknet ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Pragma.html"><strong aria-hidden="true">4.10.7.1.1.</strong> Pragma - Bases ğŸš§</a></li><li class="chapter-item "><a href="Chainlink.html"><strong aria-hidden="true">4.10.7.1.2.</strong> Chainlink - Bases ğŸš§</a></li><li class="chapter-item "><a href="Redstone.html"><strong aria-hidden="true">4.10.7.1.3.</strong> Redstone - Bases ğŸš§</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><a href="Exploradores_de_bloques.html"><strong aria-hidden="true">4.11.</strong> Exploradores de Bloques ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Starkscan.html"><strong aria-hidden="true">4.11.1.</strong> Starkscan ğŸš§</a></li><li class="chapter-item "><a href="Voyager.html"><strong aria-hidden="true">4.11.2.</strong> Voyager ğŸš§</a></li><li class="chapter-item "><a href="Madara_Explorer.html"><strong aria-hidden="true">4.11.3.</strong> Madara ğŸš§</a></li><li class="chapter-item "><a href="Elixir.html"><strong aria-hidden="true">4.11.4.</strong> Elixir ğŸš§</a></li><li class="chapter-item "><a href="View_Block.html"><strong aria-hidden="true">4.11.5.</strong> View Block ğŸš§</a></li></ol></li><li class="chapter-item "><a href="Arquitectura_Cairo.html"><strong aria-hidden="true">4.12.</strong> Cairo - Arquitectura ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Sintaxis_Basica.html"><strong aria-hidden="true">4.12.1.</strong> SintÃ¡xis BÃ¡sica ğŸš§</a></li><li class="chapter-item "><a href="Cairov2.html"><strong aria-hidden="true">4.12.2.</strong> Cairo v2 - Nueva versiÃ³n del Compilador ğŸš§</a></li></ol></li><li class="chapter-item "><a href="Node_Guardians.html"><strong aria-hidden="true">4.13.</strong> Node Guardians - Cairo Educacional ğŸš§</a></li></ol></li><li class="chapter-item "><a href="IntroducciÃ³n3.html"><strong aria-hidden="true">5.</strong> IntroducciÃ³n Parte 3 ğŸš§</a></li><li class="chapter-item "><a href="Otras_Arquitecturas.html"><strong aria-hidden="true">6.</strong> Otras Arquitecturas ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Lambda_en_Starknet.html"><strong aria-hidden="true">6.1.</strong> Lambda en Starknet ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Starknet_en_Rust.html"><strong aria-hidden="true">6.1.1.</strong> Starknet en Rust ğŸš§</a></li><li class="chapter-item "><a href="Lambda_Prover_Platinum.html"><strong aria-hidden="true">6.1.2.</strong> Lambda Prover - Platinum ğŸš§</a></li><li class="chapter-item "><a href="Lambda_Sequencer.html"><strong aria-hidden="true">6.1.3.</strong> Lambda Sequencer ğŸš§</a></li><li class="chapter-item "><a href="Lambda_Work.html"><strong aria-hidden="true">6.1.4.</strong> LambdaWorks ğŸš§</a></li></ol></li><li class="chapter-item "><a href="Madara.html"><strong aria-hidden="true">6.2.</strong> Madara ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Madara_Fusionando_Fuerzas.html"><strong aria-hidden="true">6.2.1.</strong> Madara - Fusionando Fuerzas ğŸš§</a></li><li class="chapter-item "><a href="Sharingan.html"><strong aria-hidden="true">6.2.2.</strong> Sharingan ğŸš§</a></li></ol></li><li class="chapter-item "><a href="Otros_Secuenciadores.html"><strong aria-hidden="true">6.3.</strong> Otros Secuenciadores ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Secuenciador_Katana.html"><strong aria-hidden="true">6.3.1.</strong> Katana ğŸš§</a></li><li class="chapter-item "><a href="Secuenciador_Radius.html"><strong aria-hidden="true">6.3.2.</strong> Radius ğŸš§</a></li><li class="chapter-item "><a href="Secuenciador_Kraken.html"><strong aria-hidden="true">6.3.3.</strong> Kraken ğŸš§</a></li></ol></li><li class="chapter-item "><a href="Otros_Prover.html"><strong aria-hidden="true">6.4.</strong> Otros Prover ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Sandstorm.html"><strong aria-hidden="true">6.4.1.</strong> Sandstorm ğŸš§</a></li></ol></li><li class="chapter-item "><a href="Kakarot.html"><strong aria-hidden="true">6.5.</strong> Kakarot ğŸš§</a></li><li class="chapter-item "><a href="Dojo.html"><strong aria-hidden="true">6.6.</strong> Dojo ğŸš§</a></li><li class="chapter-item "><a href="Giza.html"><strong aria-hidden="true">6.7.</strong> Giza ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Orion.html"><strong aria-hidden="true">6.7.1.</strong> Orion ğŸš§</a></li></ol></li><li class="chapter-item "><a href="Cartridge.html"><strong aria-hidden="true">6.8.</strong> Cartridge ğŸš§</a></li><li class="chapter-item "><a href="Visara.html"><strong aria-hidden="true">6.9.</strong> Vistara ğŸš§</a></li><li class="chapter-item "><a href="Servicios_API.html"><strong aria-hidden="true">6.10.</strong> Servicios API ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Infura.html"><strong aria-hidden="true">6.10.1.</strong> Infura ğŸš§</a></li><li class="chapter-item "><a href="Alchemy.html"><strong aria-hidden="true">6.10.2.</strong> Alchemy ğŸš§</a></li></ol></li><li class="chapter-item "><a href="Indexer.html"><strong aria-hidden="true">6.11.</strong> Indexer ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Checkpoint.html"><strong aria-hidden="true">6.11.1.</strong> Checkpoint ğŸš§</a></li><li class="chapter-item "><a href="Apibara.html"><strong aria-hidden="true">6.11.2.</strong> Apibara ğŸš§</a></li><li class="chapter-item "><a href="Tokenflow.html"><strong aria-hidden="true">6.11.3.</strong> TokenFlow ğŸš§</a></li><li class="chapter-item "><a href="Torii.html"><strong aria-hidden="true">6.11.4.</strong> Torii ğŸš§</a></li></ol></li><li class="chapter-item "><a href="dApp_ecosistema.html"><strong aria-hidden="true">6.12.</strong> Dapp - Ecosistema ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Avnu.html"><strong aria-hidden="true">6.12.1.</strong> Avnu ğŸš§</a></li></ol></li><li class="chapter-item "><a href="Recursos.html"><strong aria-hidden="true">6.13.</strong> Recursos ğŸš§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Cairo_by_example.html"><strong aria-hidden="true">6.13.1.</strong> Cairo by Example ğŸš§</a></li><li class="chapter-item "><a href="Challegues.html"><strong aria-hidden="true">6.13.2.</strong> Challengues ğŸš§</a></li><li class="chapter-item "><a href="Cairo_Book.html"><strong aria-hidden="true">6.13.3.</strong> Cairo book ğŸš§</a></li><li class="chapter-item "><a href="Starknet_Book.html"><strong aria-hidden="true">6.13.4.</strong> Starknet book ğŸš§</a></li><li class="chapter-item "><a href="Starkli.html"><strong aria-hidden="true">6.13.5.</strong> Starkli ğŸš§</a></li><li class="chapter-item "><a href="Scarb.html"><strong aria-hidden="true">6.13.6.</strong> Scarb ğŸš§</a></li><li class="chapter-item "><a href="Wizard.html"><strong aria-hidden="true">6.13.7.</strong> OZ - Wizard ğŸš§</a></li><li class="chapter-item "><a href="Remix_Starknet.html"><strong aria-hidden="true">6.13.8.</strong> Remix - Starknet ğŸš§</a></li><li class="chapter-item "><a href="Starknet_js.html"><strong aria-hidden="true">6.13.9.</strong> Starknet.js ğŸš§</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">L2 Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introducciÃ³n"><a class="header" href="#introducciÃ³n">IntroducciÃ³n</a></h1>
<p>Â¡Hola comunidad! ğŸ‘‹</p>
<p>Antes que nada nos gustarÃ­a expresar nuestro mÃ¡s sincero agradecimiento a todos aquellos que han contribuido y hecho posible la realizaciÃ³n de esta exhaustiva investigaciÃ³n y documento sobre criptografÃ­a y como se adaptan en StarkWare. Especial reconocimiento a los expertos que han colaborado en su creaciÃ³n y a <a href="https://twitter.com/0xhasher_">Carlos</a> que ha brindado sus valiosas correcciones y orientaciÃ³n en numerosos aspectos del trabajo. Sus experiencias y conocimientos han sido fundamentales para alcanzar los resultados y conclusiones presentados en este informe.</p>
<p>En esta ocasiÃ³n, estamos emocionados de presentar una serie de artÃ­culos profundos sobre el desarrollo detrÃ¡s de Starkware. Recomendamos a los lectores que previamente hayan leÃ­do otros documentos y tengan conocimientos tÃ©cnicos para una mejor comprensiÃ³n, para este documento en concreto recomendamos:</p>
<p><a href="https://starkware.co/resource/stark-endgame/">Stark END-Game</a> | <a href="https://starkware.co/resource/stark-endgame/">Recursive Stark</a> |  <a href="https://starkware.co/resource/account-abstraction-improving-security-and-user-experience-for-mainstream-crypto-adoption/">Account Abstraction</a> | <a href="https://starkware.co/stark-math-a-very-short-primer/">Intro Maths Starks</a></p>
<p>El panorama actual es complejo, pero nos enorgullece contar con las mentes mÃ¡s brillantes trabajando en el ecosistema, una STARK que los une a todos.</p>
<p>Â¿Eres o serÃ¡s uno de ellos? Antes de sumergirnos, exploraremos una serie de conceptos para establecer bases e historias sobre criptografÃ­a, lo que nos permitirÃ¡ adentrarnos aÃºn mÃ¡s en el ecosistema STARKs. Â¡Comencemos!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bases-criptogrÃ¡ficas"><a class="header" href="#bases-criptogrÃ¡ficas">Bases CriptogrÃ¡ficas</a></h1>
<p>La <a href="https://en.wikipedia.org/wiki/Cryptography"><strong>criptografÃ­a</strong></a> es el campo de estudio y desarrollo de tÃ©cnicas y algoritmos para asegurar la confidencialidad, integridad y autenticidad de la informaciÃ³n. Utilizando claves secretas o pÃºblicas, <strong>la criptografÃ­a transforma los datos en un formato incomprensible para terceros no autorizados</strong>, garantizando que solo los destinatarios legÃ­timos puedan acceder a la informaciÃ³n original. La criptografÃ­a desempeÃ±a un papel vital en la seguridad de las comunicaciones y el almacenamiento de datos, protegiendo la privacidad y la confianza en diversos Ã¡mbitos de la vida moderna.</p>
<ul>
<li>
<p><strong>Encryption:</strong> <a href="https://en.wikipedia.org/wiki/Encryption">el cifrado</a> es el proceso de convertir informaciÃ³n legible en un formato ilegible llamado texto cifrado, mediante el uso de algoritmos y una clave. El objetivo principal del cifrado es proteger la confidencialidad de los datos, asegurando que solo las personas autorizadas puedan acceder y comprender la informaciÃ³n cifrada. Para ello, se aplica una serie de transformaciones matemÃ¡ticas al texto original, lo que dificulta su interpretaciÃ³n sin la clave correspondiente.</p>
</li>
<li>
<p><strong>Cryptographic protocol:</strong> <a href="https://en.wikipedia.org/wiki/Cryptographic_protocol">un protocolo criptogrÃ¡fico</a> o protocolo de seguridad (tambiÃ©n llamado protocolo de cifrado) es un protocolo abstracto o concreto que realiza funciones relacionadas con la seguridad, aplicando mÃ©todos criptogrÃ¡ficos.â€‹ Un protocolo describe la forma en que un algoritmo debe usarse.</p>
</li>
<li>
<p><strong>Algorithm:</strong> <a href="https://es.wikipedia.org/wiki/Algoritmo">un algoritmo</a> de cifrado es un procedimiento que convierte un mensaje de texto plano en un texto cifrado. Los algoritmos modernos utilizan matemÃ¡ticas avanzadas y una o varias claves de cifrado. Esto hace que sea relativamente fÃ¡cil cifrar un mensaje, pero prÃ¡cticamente imposible descifrarlo sin conocer las claves requeridas.</p>
</li>
</ul>
<h2 id="esquema-de-cifrado"><a class="header" href="#esquema-de-cifrado">Esquema de cifrado</a></h2>
<p>Estos esquemas definen cÃ³mo se realiza la transformaciÃ³n de los datos originales en texto cifrado y cÃ³mo se realiza la operaciÃ³n inversa para recuperar los datos originales a partir del texto cifrado. Un esquema de cifrado generalmente consta de los siguientes elementos:</p>
<ul>
<li>
<p><strong>Encryption Algorithm:</strong> vimos que es el conjunto de operaciones matemÃ¡ticas utilizadas para cifrar los datos en texto cifrado.</p>
</li>
<li>
<p><strong>Decryption Algorithm:</strong> es el conjunto de operaciones matemÃ¡ticas inversas utilizadas para descifrar el texto cifrado y recuperar los datos originales.</p>
</li>
<li>
<p><strong>Key:</strong> conocida como clave, es un valor secreto que se utiliza como entrada para el algoritmo de cifrado. La key determina cÃ³mo se realiza la transformaciÃ³n de los datos y es esencial para descifrar el texto cifrado.</p>
</li>
<li>
<p><strong>Protocols:</strong> establecen cÃ³mo se utiliza el esquema de cifrado, incluyendo la generaciÃ³n y distribuciÃ³n segura de claves, el manejo de errores y la gestiÃ³n de la seguridad.</p>
</li>
</ul>
<p>Existen varios tipos de esquemas de cifrado:</p>
<ol>
<li>
<p>El <a href="https://academy.bit2me.com/que-es-criptografia-simetrica/"><strong>cifrado simÃ©trico</strong></a> (donde se utiliza una sola clave tanto para cifrar como para descifrar),</p>
</li>
<li>
<p>El <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_asim%C3%A9trica"><strong>cifrado asimÃ©trico</strong></a> o de clave pÃºblica (donde se utilizan pares de claves pÃºblica y privada)</p>
</li>
<li>
<p>Otras variantes de esquemas de cifrados como de <a href="https://es.wikipedia.org/wiki/Cifrador_de_flujo">flujo</a> y de <a href="https://es.wikipedia.org/wiki/Cifrado_por_bloques">bloque</a>. Cada esquema tiene sus propias caracterÃ­sticas y se utiliza en diferentes contextos segÃºn los requisitos de seguridad y las necesidades especÃ­ficas de la aplicaciÃ³n, pero nos centraremos en las principales para entender su funcionamiento antes de pasar a la evoluciÃ³n de las STARKs.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="criptografÃ­a-simÃ©trica"><a class="header" href="#criptografÃ­a-simÃ©trica">CriptografÃ­a SimÃ©trica</a></h2>
<p>La historia de la criptografÃ­a simÃ©trica se remonta a tiempos antiguos, pero su uso moderno se consolidÃ³ en el siglo XX con el desarrollo de mÃ©todos mÃ¡s sofisticados. Un ejemplo icÃ³nico es la <a href="https://en.wikipedia.org/wiki/Enigma_machine">mÃ¡quina Enigma</a>, utilizada por los alemanes durante la Segunda Guerra Mundial para cifrar y descifrar mensajes, esta mÃ¡quina demostrÃ³ la eficacia de la criptografÃ­a simÃ©trica en entornos militares.</p>
<p>Podemos ver la criptografÃ­a simÃ©trica como una antigua y confiable llave maestra en el mundo de la seguridad informÃ¡tica. Es una tÃ©cnica que ha sido utilizada desde hace mucho tiempo y aÃºn en la actualidad sigue siendo efectiva y segura para proteger informaciÃ³n en diversas situaciones.</p>
<p>ImagÃ­nate una llave que puede tanto cerrar como abrir una puerta. Los algoritmos criptogrÃ¡ficos de clave simÃ©trica funcionan de manera similar, utilizan la misma clave para cifrar el texto original y descifrar el texto cifrado, esta clave compartida es como el secreto que solo tÃº y los destinatarios autorizados conocen.</p>
<p><img src="./assets/simetrico.gif" alt="graph" /></p>
<div align="center">
<em>CriptografÃ­a SimÃ©trica - Ãšnica Key</em>
</div>
<p>Sin embargo, a medida que la tecnologÃ­a avanzaba y las capacidades de cÃ³mputo aumentaban, se hizo evidente que era necesario fortalecer los sistemas de cifrado. Surgieron nuevos desafÃ­os y amenazas que requerÃ­an niveles mÃ¡s altos de seguridad. Es por eso que se desarrollaron otros mÃ©todos criptogrÃ¡ficos, como la criptografÃ­a asimÃ©trica, que utiliza pares de claves diferentes para el cifrado y el descifrado.</p>
<p>Aunque la criptografÃ­a simÃ©trica ha evolucionado con el tiempo, todavÃ­a se utiliza ampliamente en muchos sistemas y aplicaciones. Su simplicidad y eficiencia la convierten en una opciÃ³n popular para proteger datos en redes privadas, sistemas de comunicaciÃ³n y almacenamiento de informaciÃ³n sensible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="criptografÃ­a-asimÃ©trica"><a class="header" href="#criptografÃ­a-asimÃ©trica">CriptografÃ­a AsimÃ©trica</a></h1>
<p>El concepto de algoritmos criptogrÃ¡ficos de clave asimÃ©trica, fue un enfoque revolucionario que introdujo un concepto completamente diferente, <strong>el uso de un par de claves complementarias, una pÃºblica y una privada</strong>, para asegurar la confidencialidad de los datos. Cada clave del par tenÃ­a una funciÃ³n especÃ­fica:</p>
<ul>
<li><strong>Public key</strong>: esta clave pÃºblica se compartÃ­a abiertamente y se utilizaba para cifrar la informaciÃ³n.</li>
<li><strong>Private key:</strong> esta clave privada se guardaba cuidadosamente y se utilizaba para descifrarla.</li>
</ul>
<p>Con la criptografÃ­a de clave pÃºblica, los mensajes cifrados podÃ­an ser transmitidos a travÃ©s de redes inseguras sin el temor de que fueran interceptados y descifrados por personas no autorizadas, pero en este caso diferenciÃ¡ndose de la simÃ©trica en que estos mensajes requerÃ­an un Private key y una Public key. Era como si se hubiera descubierto una nueva forma de comunicaciÃ³n secreta y segura en el mundo digital, fue un avance revolucionario en el campo de la criptografÃ­a.</p>
<p><img src="./assets/asimetrico.gif" alt="graph" /></p>
<div align="center">
<em>CriptografÃ­a AsimÃ©trica - CreaciÃ³n de PK y PB</em>
</div>
<p>Algunos de los mÃ¡s destacados y utilizados son los siguiente:</p>
<ul>
<li>
<p><strong>RSA -</strong> <a href="https://es.wikipedia.org/wiki/RSA"><strong>Rivest-Shamir-Adleman:</strong></a> es un sistema criptogrÃ¡fico asimÃ©trico de clave pÃºblica desarrollado en 1979. Su seguridad radica en el problema de la factorizaciÃ³n de nÃºmeros enteros y se utiliza en diversos Ã¡mbitos de la transmisiÃ³n de datos en Internet debido a su facilidad de uso. Este sistema consta de una clave pÃºblica RSA y una clave privada RSA.</p>
</li>
<li>
<p><strong>ECC -</strong> <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_de_curva_el%C3%ADptica"><strong>Elliptic Curve Cryptography:</strong></a> en la dÃ©cada de 1980 se desarrollÃ³ este enfoque de curva elÃ­ptica criptogrÃ¡fica, una variante de la criptografÃ­a asimÃ©trica o de clave pÃºblica basada en las matemÃ¡ticas de las curvas elÃ­pticas que proporciona niveles de seguridad similares o superiores a RSA pero con claves mÃ¡s cortas.</p>
</li>
<li>
<p><strong>ECDSA -</strong> <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf"><strong>Elliptic Curve Digital Signature Algorithm:</strong></a> en los AÃ±os 1990 naciÃ³ ECDSA, un algoritmo de firma digital y autenticaciÃ³n en criptografÃ­a asimÃ©trica, basado en curvas elÃ­pticas. Se utiliza en criptografÃ­a para garantizar la autenticidad, integridad de los datos. ECDSA se basa en la dificultad computacional de resolver el problema del logaritmo discreto en curvas elÃ­pticas.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="criptografÃ­a-hÃ­brida"><a class="header" href="#criptografÃ­a-hÃ­brida">CriptografÃ­a HÃ­brida</a></h1>
<p>El <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_h%C3%ADbrida"><strong>cifrado hÃ­brido</strong></a> utiliza las propiedades Ãºnicas de la criptografÃ­a de clave pÃºblica para intercambiar informaciÃ³n secreta a travÃ©s de un canal no confiable, combinando la eficacia del cifrado simÃ©trico. Esto proporciona una soluciÃ³n prÃ¡ctica de extremo a extremo para garantizar la privacidad de los datos.</p>
<p>Aunque los algoritmos de clave pÃºblica, como RSA-OAEP, son menos eficientes que los algoritmos simÃ©tricos, generalmente no se utilizan directamente para cifrar los datos. Sin embargo, desempeÃ±an un papel importante en el ecosistema criptogrÃ¡fico al permitir el intercambio seguro de claves.</p>
<p>Para utilizar el cifrado simÃ©trico, las partes deben compartir una clave. Si ya existe un canal seguro, se puede enviar la clave a travÃ©s de Ã©l. Sin embargo, si no hay un canal seguro disponible, se resuelve el problema del intercambio de claves utilizando la criptografÃ­a de clave pÃºblica.</p>
<ul>
<li><strong>DH -</strong> <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"><strong>Diffieâ€“Hellman:</strong></a> el intercambio de claves DH es un algoritmo criptogrÃ¡fico de clave pÃºblica diseÃ±ado especÃ­ficamente para acordar una clave simÃ©trica en ausencia de un canal seguro.
La combinaciÃ³n de criptografÃ­a de clave pÃºblica para el intercambio de claves y el cifrado simÃ©trico para el cifrado de datos en masa se conoce como cifrado hÃ­brido.</li>
</ul>
<p>El cifrado hÃ­brido se utiliza ampliamente en los protocolos de transferencia de datos para la web, como en la capa de seguridad de transporte <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">(TLS)</a>. Cuando te conectas a un sitio web que utiliza <a href="https://en.wikipedia.org/wiki/HTTPS">HTTPS</a> (HTTP seguro con TLS), tu navegador negocia los algoritmos criptogrÃ¡ficos que aseguran la conexiÃ³n. Estos algoritmos incluyen mÃ©todos para el intercambio de claves, cifrado simÃ©trico y firmas digitales.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="firmas-digitales"><a class="header" href="#firmas-digitales">Firmas digitales</a></h1>
<p>Los esquemas de firma digital son un tipo de criptografÃ­a de clave pÃºblica que garantiza la integridad, autenticidad y no repudio de los datos.</p>
<p>Es importante destacar que el esquema de firma digital puede variar dependiendo del algoritmo utilizado, ECDSA, es un ejemplo comÃºn de esquema de firma basado en criptografÃ­a de curva elÃ­ptica. AquÃ­ EC recordemos que representa la curva elÃ­ptica utilizada y <a href="https://en.wikipedia.org/wiki/Digital_Signature_Algorithm"><strong>DSA</strong></a> (una variante de los esquemas de firma <a href="https://en.wikipedia.org/wiki/Schnorr_signature">Schnorr</a> y <a href="https://en.wikipedia.org/wiki/ElGamal_signature_scheme">ElGamal</a>) el algoritmo de firma digital. Cada esquema tiene sus propias caracterÃ­sticas y propiedades de seguridad, y se selecciona segÃºn los requisitos y consideraciones especÃ­ficas de la aplicaciÃ³n.</p>
<p>Cuando se trata de firmas digitales, los pasos generales suelen ser los siguientes:</p>
<ul>
<li>
<p><strong>Key generation:</strong> el Generador de Claves es un protocolo o algoritmo que genera <strong>un Keypar</strong>, un par de claves asimÃ©tricas como se explicÃ³ anteriormente compuestas por una public key y una private key. En el caso de la criptografÃ­a de curva elÃ­ptica (como ECDSA), se generan los parÃ¡metros necesarios para definir la curva y se elige una clave privada aleatoria. A partir de la clave privada, se calcula la clave pÃºblica correspondiente utilizando operaciones matemÃ¡ticas especÃ­ficas.</p>
</li>
<li>
<p><strong>Hash del mensaje:</strong> antes de firmar el mensaje, se aplica una funciÃ³n hash criptogrÃ¡fica al contenido del mensaje. Esto reduce el mensaje a un valor de longitud fija llamado resumen o hash. El objetivo es garantizar la integridad y eficiencia del proceso de firma, ya que es mÃ¡s rÃ¡pido firmar y verificar un resumen mÃ¡s corto que el mensaje completo.</p>
</li>
<li>
<p><strong>Digital Signature:</strong> este proceso tiene el propÃ³sito de realizar una serie de operaciones matemÃ¡ticas utilizando la clave privada y el hash del mensaje para generar la firma digital.</p>
</li>
<li>
<p><strong>Verify Signature:</strong> para verificar la autenticidad de la firma, se necesita la clave pÃºblica del firmante. Se aplica nuevamente la funciÃ³n hash al mensaje original y se utiliza la clave pÃºblica junto con la firma para realizar operaciones matemÃ¡ticas especÃ­ficas. Si el resultado coincide con la firma original, se considera que la firma es vÃ¡lida y se confirma la autenticidad del mensaje y del firmante.</p>
</li>
</ul>
<p>El proceso de firma puede considerarse como el cifrado del archivo mediante la clave privada. Para ello, la persona que firma utiliza su clave privada para producir una firma.</p>
<p>Exploraremos a continuaciÃ³n la relevancia de los diversos esquemas de firmas para garantizar la seguridad de nuestros datos, asÃ­ como la forma en que Starknet usa AA para abstraer la firma de la validaciÃ³n. En este contexto, se pueden diseÃ±ar diferentes esquemas o configuraciones, como el <code>secp256r1</code>, una variante de STARK Curve, la versiÃ³n amigable de ECDSA optimizada en Starknet. Este esquema de firma se puede utilizar para incorporar firmas en dispositivos modernos de manera biomÃ©trica, aislada y abstraÃ­da por naturaleza, lo que mejora significativamente la eficiencia, tal como se discutirÃ¡ en detalle mÃ¡s adelante.</p>
<p>Por lo tanto, resulta crucial abordar el siguiente apartado relacionado con el uso de Key generation que desempeÃ±an un papel fundamental en este contexto.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-generator"><a class="header" href="#key-generator">Key generator</a></h1>
<p>Tenemos que entender cÃ³mo el generador de claves <a href="https://en.wikipedia.org/wiki/Key_generator"><strong>(Key generator)</strong></a> genera el Keypair, para lograrlo, es necesario trabajar con valores pseudoaleatorios que se utilizan en la generaciÃ³n de la private key. Un Key generator se puede implementar en un sistema con el propÃ³sito de generar y autenticar claves.</p>
<p>Key generator puede implementarse en cualquier sistema criptogrÃ¡fico que utilice la curva elÃ­ptica, como es el caso de <code>secp256k1</code> (una curva optimizada basada en las propiedades matemÃ¡ticas de las curvas elÃ­pticas para proporcionar un esquema de firma digital seguro y eficiente), como Bitcoin y Ethereum.</p>
<p>Este generador de claves garantiza que, con alta probabilidad, las claves privadas generadas sean Ãºnicas y seguras, lo que a su vez respalda la integridad y autenticidad de las transacciones realizadas en la red.</p>
<h2 id="generadores-de-nÃºmeros-pseudoaleatorios"><a class="header" href="#generadores-de-nÃºmeros-pseudoaleatorios">Generadores de nÃºmeros pseudoaleatorios</a></h2>
<p>Para garantizar la seguridad usando la pseudoaleatoriedad estadÃ­stica de un <strong>PRNG -</strong> <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator"><strong>Pseudorandom number generator</strong></a>, es crucial contar con una semilla inicial. Si la semilla es fÃ¡cilmente predecible, generarÃ¡ valores predecibles de nÃºmeros y todo el proceso serÃ¡ inseguro.</p>
<p>Para lograr una inicializaciÃ³n segura del generador pseudoaleatorio, es necesario recolectar <a href="https://en.wikipedia.org/wiki/Entropy_(computing)"><strong>EntropÃ­a</strong></a>, que representa la aleatoriedad necesaria en el proceso.</p>
<h2 id="entropÃ­a"><a class="header" href="#entropÃ­a">EntropÃ­a</a></h2>
<p>La entropÃ­a o aleatoriedad impredecible en computaciÃ³n, generalmente se mide en bits. Tenemos varios ejemplos para entender el concepto y grado de aleatoriedad. Si mueve el mouse de su computadora, generarÃ¡ algunos eventos difÃ­ciles de predecir, como la ubicaciÃ³n de inicio y la ubicaciÃ³n final del cursor del mouse.</p>
<blockquote>
<p>Si suponemos que el mouse ha cambiado su posiciÃ³n en el rango de <code>[ 0 ... 255 pÃ­xeles ]</code>, la entropÃ­a recolectada de este movimiento del mouse debe ser de aproximadamente <strong>8 bits</strong>, porque <code>2â¸ = 255</code></p>
</blockquote>
<blockquote>
<p>Si se le pide al usuario que piense en un nÃºmero en el rango <code>[ 0 ... 1000 ]</code>, este nÃºmero tendrÃ¡ alrededor de <strong>9-10 bits</strong> de entropÃ­a porque, <code>2Â¹â° = 1024</code></p>
</blockquote>
<p>Para recolectar 256 bits de entropÃ­a, es decir, para generar de forma segura un nÃºmero entero de 256 bits, deberÃ¡ tener en cuenta una secuencia de varios eventos similares (como movimientos del mouse e interracidades del teclado del usuario).</p>
<p>AquÃ­ la importancia de dÃ³nde y cÃ³mo hemos generado nuestras claves privadas y pÃºblicas y las posibles vulnerabilidades en algunos malos usos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funciones-hash-y-funciones-hash-criptogrÃ¡ficas"><a class="header" href="#funciones-hash-y-funciones-hash-criptogrÃ¡ficas">Funciones hash y funciones hash criptogrÃ¡ficas</a></h1>
<p>Este capÃ­tulo es de suma importancia para comprender el funcionamiento de las funciones hash. A diferencia de los esquemas de cifrado o las firmas, las funciones hash no requieren de una clave. Cualquier persona puede calcular el hash de una entrada determinada, y la funciÃ³n hash siempre producirÃ¡ la misma salida para la misma entrada.</p>
<p>AsÃ­ que podemos definir una <a href="https://en.wikipedia.org/wiki/Hash_function"><strong>funciÃ³n hash</strong></a> como un algoritmo que toma una entrada, como un mensaje o un archivo, y produce una salida de longitud fija llamada hash o resumen. Esta salida es Ãºnica para cada entrada especÃ­fica, lo que permite la verificaciÃ³n de la integridad de los datos y garantiza que cualquier cambio en la entrada resultarÃ¡ en un hash completamente diferente.</p>
<p>Una <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function"><strong>funciÃ³n hash criptogrÃ¡fica</strong></a>, por otro lado, es aquella funciÃ³n hash que se utiliza en el Ã¡mbito de la criptografÃ­a, para evaluar la seguridad de una funciÃ³n de hash criptogrÃ¡fica, se consideran las siguientes propiedades:</p>
<ul>
<li><strong>Resistencia a la preimagen:</strong> partiendo de un valor <code>hash h</code>, es difÃ­cil encontrar un mensaje <code>m</code> que genere ese <code>hash</code>, es decir, <code>h = hash(m)</code>, este concepto estÃ¡ relacionado con el de una funciÃ³n de sentido Ãºnico. Las funciones que carecen de esta propiedad son vulnerables a ataques de preimagen.</li>
<li><strong>Resistencia a la segunda preimagen:</strong> dado un mensaje <code>mâ‚</code>, es difÃ­cil encontrar otro mensaje <code>mâ‚‚</code> distinto a <code>mâ‚</code> que produzca el mismo valor de hash, es decir, <code>hash(mâ‚) = hash(mâ‚‚)</code>. Esta propiedad tambiÃ©n se conoce como resistencia dÃ©bil a colisiones. Las funciones que no cumplen esta propiedad son vulnerables a ataques de segunda preimagen.</li>
<li><strong>Resistencia a colisiones:</strong> es difÃ­cil encontrar dos mensajes diferentes <code>mâ‚</code> y <code>mâ‚‚</code> que produzcan el mismo valor de hash, es decir, <code>hash(mâ‚) = hash(mâ‚‚)</code>. Estas colisiones son conocidas como colisiones criptogrÃ¡ficas de hash. Esta propiedad tambiÃ©n se conoce como resistencia fuerte a colisiones. Se requiere que el tamaÃ±o del hash sea al menos el doble de largo para garantizar la resistencia a la preimagen.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merkle-tree-en-blockchain"><a class="header" href="#merkle-tree-en-blockchain">Merkle Tree en Blockchain</a></h1>
<p>Ahora que hemos comprendido mejor quÃ© es un hash, veamos cÃ³mo en criptografÃ­a y <a href="https://en.wikipedia.org/wiki/Computer_science">ciencias de la computaciÃ³n</a>, un Ã¡rbol hash, tambiÃ©n conocido cÃ³mo <a href="https://en.wikipedia.org/wiki/Merkle_tree"><strong>Merkle Tree o binary Merkle tree</strong></a>, es una <a href="https://en.wikipedia.org/wiki/Data_structure">estructura de datos</a> utilizada para garantizar la integridad de los contenidos almacenados en un sistema, como la tecnologÃ­a blockchain.</p>
<p>Podemos ver los Merkle Trees como una estructura de Ã¡rbol en la que cada &quot;hoja&quot; o nodo terminal, estÃ¡ etiquetado con el hash criptogrÃ¡fico de un bloque de datos. A su vez, cada nodo que no es una hoja, tambiÃ©n conocido como rama, nodo interior o inodo, estÃ¡ etiquetado con el hash criptogrÃ¡fico de las etiquetas de sus nodos secundarios.</p>
<p>La construcciÃ³n de un Merkle Tree implica dividir los datos en bloques mÃ¡s pequeÃ±os y aplicar una funciÃ³n de hash criptogrÃ¡fico a cada uno de ellos. Luego, los bloques hash se combinan en pares y se vuelven a hashear, repitiendo este proceso hasta obtener un Ãºnico hash llamado raÃ­z de Merkle o â€œMerkle rootâ€. Esta raÃ­z se coloca en la cabecera de un bloque o transacciÃ³n y se utiliza como una firma digital que representa y verifica la integridad de todos los datos incluidos en el bloque.</p>
<p><img src="./assets/merkle.gif" alt="graph" /></p>
<div align="center">
<em>Ejemplo de estructura de un Merkle Tree</em>
</div>
<p>Una de las principales ventajas de los Merkle Trees es su capacidad para proporcionar una verificaciÃ³n eficiente y segura de los contenidos de una gran estructura de datos. Como cada nodo intermedio en el Ã¡rbol estÃ¡ etiquetado con el hash criptogrÃ¡fico de las etiquetas de sus nodos secundarios, cualquier cambio realizado en los datos se reflejarÃ¡ en cambios en los hashes correspondientes.</p>
<p>En la tecnologÃ­a blockchain que usan los Merkle Trees, los utilizan para garantizar la integridad de los datos almacenados en cada bloque de la cadena. Cada bloque contiene una lista de transacciones, y el Merkle Tree se construye utilizando los hashes de estas transacciones.</p>
<p>Cuando se agrega un nuevo bloque a la cadena, la raÃ­z de Merkle del bloque anterior se incluye en el nuevo bloque, creando una cadena enlazada de Ã¡rboles de Merkle. Esto permite verificar rÃ¡pidamente la integridad de cualquier bloque en la cadena sin necesidad de verificar todos los datos desde el inicio. AdemÃ¡s, si algÃºn dato se modifica en un bloque, el hash del bloque cambiarÃ¡, lo que afectarÃ¡ la raÃ­z de Merkle y seÃ±alarÃ¡ la alteraciÃ³n en la cadena.</p>
<p>Algunos casos posibles de uso de los binary Merkle Trees para los diferentes esquemas pueden ser:</p>
<ul>
<li><strong>Los binary Merkle Trees:</strong> son estructuras de datos muy eficientes para autenticar informaciÃ³n que se presenta en formato de &quot;lista&quot;, es decir, una secuencia de elementos consecutivos.</li>
<li><strong>Los transaction trees:</strong> tambiÃ©n resultan beneficiosos, ya que una vez creado el Ã¡rbol, no importa cuÃ¡nto tiempo se tarde en editarlo, ya que permanecerÃ¡ inmutable.</li>
<li><strong>Los State trees:</strong> sin embargo, cuando se trata de un Ã¡rbol que almacena estados la situaciÃ³n se vuelve mÃ¡s compleja, el estado en Ethereum, que consiste en un mapa de valores clave donde:
<ul>
<li><strong>Las claves son direcciones</strong></li>
<li><strong>Los valores son las declaraciones de cuenta que incluyen:</strong> saldo, nonce, cÃ³digo y almacenamiento asociados a cada cuenta, r</li>
<li><strong>Requiere la construcciÃ³n de una prueba de transiciÃ³n de estado de Merkle</strong> <a href="https://medium.com/@chiqing/verify-ethereum-account-balance-with-state-proof-83b51ceb15cf">(Merkle state transition proof)</a></li>
</ul>
</li>
</ul>
<p>AsÃ­ que, comprender el funcionamiento de los State Trees y su optimizaciÃ³n de datos es crucial en el contexto actual donde los datos y los hashes desempeÃ±an un papel fundamental. En el caso de Ethereum, uno de los principales actores en el Ã¡mbito de los State Trees, se han incorporado modificaciones interesantes usando Patricia Merkle Trie.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patricia-merkle-trie"><a class="header" href="#patricia-merkle-trie">Patricia Merkle Trie</a></h1>
<p>La especificaciÃ³n de Ethereum define el <a href="https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/"><strong>Modified Merkle Patricia Trie</strong></a> (tambiÃ©n conocido como MPT) este mÃ©todo se utiliza para guardar estados. BÃ¡sicamente, el MPT es una combinaciÃ³n del Patricia trie y el Merkle tree, con algunas optimizaciones adicionales adaptadas a las caracterÃ­sticas de Ethereum.</p>
<p>Patricia trie, <a href="https://en.wikipedia.org/wiki/Radix_tree">(Radix tree o Radix trie)</a>, Ã¡rbol de prefijos compacto <strong>(compact prefix tree)</strong> o Ã¡rbol de prefijos comprimido <strong>(compressed trie)</strong>, es una sofisticada estructura de datos que ofrece una optimizaciÃ³n espacial en la representaciÃ³n de [Tries] (Ã¡rboles de prefijos). Una de las caracterÃ­sticas clave de este tipo de Ã¡rbol es la fusiÃ³n de nodos cuando un nodo es hijo Ãºnico de su padre, lo que contribuye a una mayor eficiencia y rendimiento.</p>
<p>Esta estructura es un tipo de <strong>Ã¡rbol de bÃºsqueda k-ary</strong>, siendo un <a href="https://en.wikipedia.org/wiki/M-ary_tree">m-ary tree</a> (tambiÃ©n conocido como <code>n-ary tree</code>, <code>k-ary tree</code> o <code>k-way tree</code>) un Ã¡rbol raÃ­z en el cual cada nodo tiene como mÃ¡ximo m hijos. Ambas estructuras de datos se utilizan para localizar claves especÃ­ficas dentro de un conjunto.</p>
<p>Estos Ã¡rboles son completamente deterministas, lo que significa que aquellos con las mismas asociaciones de (clave, valor) estÃ¡n garantizados de ser idÃ©nticos, hasta el Ãºltimo byte. Esto asegura que tengan el mismo hash raÃ­z, lo que proporciona la deseada eficiencia de <code>O(log(n))</code> para inserciones, bÃºsquedas y eliminaciones. AdemÃ¡s, son mÃ¡s fÃ¡ciles de entender y programar que alternativas mÃ¡s complejas basadas en comparaciones, como los <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">red-black tree.</a></p>
<p>El Patricia Merkle Trie combina la estructura de un Ã¡rbol de bÃºsqueda binario con la estructura de Ã¡rbol de Merkle, lo cual permite verificar eficientemente la integridad de los datos y proporciona una representaciÃ³n compacta del estado completo de la cadena.</p>
<p>El uso del Patricia Merkle Trie en Ethereum ofrece ventajas significativas en tÃ©rminos de eficiencia y escalabilidad. Permite realizar consultas rÃ¡pidas sobre el estado de las cuentas y los contratos, evitando la necesidad de recorrer todo el estado completo. En cambio, solo es necesario verificar y acceder a los nodos relevantes en el Ã¡rbol, lo que ahorra tiempo y recursos.</p>
<p>AdemÃ¡s, esta estructura de Ã¡rbol facilita la implementaciÃ³n de funciones de snapshot y revert en Ethereum. Estas funciones permiten crear instantÃ¡neas del estado del sistema en momentos especÃ­ficos y revertir cambios en caso de errores o ataques, brindando una capa adicional de seguridad y confiabilidad a la red blockchain.</p>
<p><img src="" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>La comprensiÃ³n de los Merkle Trees y el MPT resulta especialmente relevante al explorar otras estructuras de datos criptogrÃ¡ficas, como las Merkle Mountain Ranges (MMRs) en Herodotus para las Storage Proof. Las MMRs pueden considerarse una lista de Ãrboles de Merkle, donde cada Ã¡rbol se representa como una montaÃ±a y la lista completa forma el rango. La utilizaciÃ³n de funciones hash especÃ­ficas y sus caracterÃ­sticas de seguridad se explorarÃ¡n para comprender cÃ³mo crear estos Ã¡rboles de manera eficiente y Ã³ptima.</p>
<p>Por lo tanto, es crucial comprender a fondo las diferentes funciones hash y sus propiedades para tomar decisiones informadas sobre la selecciÃ³n y optimizaciÃ³n de las mismas en la construcciÃ³n de estructuras de datos criptogrÃ¡ficas mÃ¡s eficientes y seguras en los Ãrboles de Merkle.</p>
<p>Las funciones hash desempeÃ±an un papel fundamental en garantizar la integridad y la seguridad de los datos almacenados en los Ã¡rboles de Merkle, ya que se utilizan para calcular los hashes de los nodos y verificar su integridad durante la construcciÃ³n y la verificaciÃ³n del Ã¡rbol.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sha-256"><a class="header" href="#sha-256">SHA-256</a></h1>
<p>En este capÃ­tulo aprenderemos algunos ejemplos de funciones hash criptogrÃ¡ficas ampliamente utilizadas, un ejemplo es <code>SHA-256</code> <a href="https://es.wikipedia.org/wiki/SHA-2"><strong>(Secure Hash Algorithm 256-bit)</strong></a>, <strong>que es una funciÃ³n de hash criptogrÃ¡fica perteneciente a la familia de algoritmos SHA-2.</strong> Esta funciÃ³n acepta una entrada de cualquier longitud y genera una salida de 256 bits que se considera Ãºnica y asociada de forma irreversible a dicha entrada.</p>
<p>Pueden probar la generaciÃ³n de un hash utilizando cualquier <a href="https://miniwebtool.com/es/sha256-hash-generator/">generador en lÃ­nea</a>. En este caso, <a href="https://bfotool.com/category/encode-decoder">realizamos pruebas</a> utilizando la funciÃ³n hash <code>SHA-256</code> y <code>keccak-256</code>, tambiÃ©n pueden explorar y probar <a href="https://bfotool.com/category/encode-decoder">mÃ¡s funciones hash desde aquÃ­.</a></p>
<p>El cambio de un solo bit causa un efecto avalancha, lo que significa que incluso un cambio mÃ­nimo como un <code>.</code> en la entrada, produce un cambio significativo en la salida. Puedes revisar el hash de <code>L2 en EspaÃ±ol</code> y <code>L2 en EspaÃ±ol.</code></p>
<p><img src="./assets/Sha256.png" alt="graph" /></p>
<div align="center">
<em>Salida de datos completamente diferente aÃ±adiendo un "."</em>
</div>
<p><code>SHA-256</code> se utiliza ampliamente en criptografÃ­a, y cuenta con diversos casos de uso destacados:</p>
<ol>
<li><strong>VerificaciÃ³n de integridad:</strong> <code>SHA-256</code> se utiliza para verificar la integridad de los datos almacenados en un sistema. Al calcular el hash de un archivo o conjunto de datos, se puede comparar con el hash original para detectar cualquier cambio o alteraciÃ³n en los datos.</li>
<li><strong>Firmas digitales:</strong> las firmas digitales se generan mediante algoritmos criptogrÃ¡ficos y se basan en la funciÃ³n SHA-256 para asegurar la autenticidad e integridad de los mensajes. El hash <code>SHA-256</code> se utiliza para resumir y proteger la informaciÃ³n que se firma digitalmente.</li>
<li><strong>Almacenamiento seguro de contraseÃ±as:</strong> en lugar de almacenar contraseÃ±as en texto plano, los sistemas de seguridad suelen almacenar el hash <code>SHA-256</code> de las contraseÃ±as. Cuando un usuario ingresa su contraseÃ±a, se calcula el hash y se compara con el valor almacenado, lo que permite verificar la autenticidad de la contraseÃ±a sin almacenarla directamente.</li>
<li><strong>GeneraciÃ³n de claves criptogrÃ¡ficas:</strong> <code>SHA-256</code> se utiliza en algoritmos de generaciÃ³n de claves criptogrÃ¡ficas para producir claves aleatorias y seguras.</li>
</ol>
<p>En resumen, <code>SHA-256</code> es una funciÃ³n hash criptogrÃ¡fica ampliamente utilizada que forma parte de la familia de algoritmos <code>SHA-2</code>, la hace ideal para verificar la integridad de los datos, generar firmas digitales, almacenar contraseÃ±as de forma segura y generar claves criptogrÃ¡ficas. <code>SHA-256</code> ha demostrado su robustez y eficacia en numerosos casos de uso en criptografÃ­a. Ahora es el turno de explorar otra funciÃ³n hash criptogrÃ¡fica mÃ¡s moderna llamada Keccak.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak---el-nuevo-sha-3"><a class="header" href="#keccak---el-nuevo-sha-3">Keccak - El nuevo SHA-3</a></h1>
<p>Este capÃ­tulo nos centraremos en el <code>SHA-3</code> <a href="https://en.wikipedia.org/wiki/SHA-3"><strong>(Secure Hash Algorithm 3)</strong></a>, es un estÃ¡ndar de funciÃ³n hash criptogrÃ¡fica diseÃ±ado por los criptÃ³grafos Joan Daemen y Gilles Van Assche. El algoritmo utilizado en <code>SHA-3</code> se llama <a href="https://keccak.team/index.html"><strong>Keccak</strong></a>, el cual fue <a href="https://www.federalregister.gov/documents/2015/08/05/2015-19181/announcing-approval-of-federal-information-processing-standard-fips-202-sha-3-standard"><strong>seleccionado como el ganador del concurso</strong></a> organizado por el Instituto Nacional de EstÃ¡ndares y TecnologÃ­a <a href="https://en.wikipedia.org/wiki/National_Institute_of_Standards_and_Technology">(NIST)</a> para encontrar un nuevo estÃ¡ndar de funciÃ³n hash criptogrÃ¡fica.</p>
<p>A diferencia de <code>SHA-256</code>, <code>Keccak</code> utiliza una estructura y operaciones diferentes. En lugar de rondas, <code>Keccak</code> se basa en una construcciÃ³n llamada funciÃ³n de esponja <a href="https://en.wikipedia.org/wiki/Sponge_function">(Sponge function)</a>, que se basa en una funciÃ³n pseudoaleatoria amplia o <a href="https://keccak.team/glossary.html#permutation">(permutation)</a> pseudoaleatorio permitiendo ingresar <strong>&quot;absorbing&quot;</strong> y <strong>&quot;squeezing&quot;</strong>.</p>
<p><code>Keccak-256</code> es una funciÃ³n hash criptogrÃ¡fica utilizada en Ethereum. Pertenece a la familia de algoritmos <code>SHA-3</code> y se emplea ampliamente en la plataforma Ethereum para diversos propÃ³sitos.</p>
<p>Algunos casos de uso de <code>Keccak-256</code> incluyen:</p>
<ul>
<li>Ethereum utiliza <code>Keccak-256</code> para garantizar la integridad de los datos y generar identificadores Ãºnicos (hash) para verificar la autenticidad de los archivos y mensajes en sistemas criptogrÃ¡ficos.</li>
<li>TambiÃ©n se utiliza en la firma criptogrÃ¡fica de pequeÃ±o tamaÃ±o, donde en lugar de firmar la entrada completa, se firma el hash <code>Keccak-256</code> del mensaje o dato.</li>
<li><code>Keccak-256</code> es utilizado para obtener una identificaciÃ³n Ãºnica y determinista de una colecciÃ³n de datos. Por ejemplo, en Ethereum, las direcciones de Ethereum se derivan de claves pÃºblicas o contratos utilizando la funciÃ³n hash unidireccional <code>Keccak-256</code>.</li>
</ul>
<p>Las direcciones Ethereum son nÃºmeros hexadecimales, identificadores derivados de los Ãºltimos 20 bytes del hash <code>Keccak-256</code> de la clave pÃºblica.</p>
<p>A diferencia de las direcciones de Bitcoin, que estÃ¡n codificadas en la interfaz de usuario de todos los clientes para incluir una suma de verificaciÃ³n incorporada para proteger contra direcciones mal escritas, las direcciones de Ethereum se presentan como hexadecimales sin ninguna suma de verificaciÃ³n.</p>
<p><img src="./assets/Keccak.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>El algoritmo <strong>Keccak</strong> utiliza la <a href="https://keccak.team/glossary.html#sponge_construction"><strong>Sponge construction</strong></a> para procesar los datos de entrada de longitud variable para generar una salida de longitud variable. Esta construcciÃ³n se basa en una funciÃ³n interna llamada <code>&quot;F&quot;</code> que opera en un nÃºmero fijo de bits, denotado como <code>&quot;width&quot;</code> <a href="https://keccak.team/glossary.html#width">(anchura)</a>.</p>
<p>La anchura total del algoritmo Keccak se determina sumando dos componentes, el valor de <code>&quot;r&quot;</code> <a href="https://keccak.team/glossary.html#rate">(rate)</a> y el valor de <code>&quot;c&quot;</code> <a href="https://keccak.team/glossary.html#capacity">(capacity)</a>, donde <code>b = r + c</code>.</p>
<ul>
<li>El valor de <code>&quot;r&quot;</code> representa la cantidad de bits absorbidos en cada paso de la funciÃ³n esponja, es decir, <strong>la capacidad de absorciÃ³n de la esponja.</strong> Un valor de <code>&quot;r&quot;</code> mÃ¡s grande permite procesar mÃ¡s informaciÃ³n en cada paso, lo que reduce la cantidad de pasos necesarios para procesar una entrada especÃ­fica.</li>
<li>El valor de <code>&quot;c&quot;</code> representa la capacidad de la esponja, es decir, <strong>la cantidad de bits que se mantienen en el estado interno del algoritmo despuÃ©s de cada paso de absorciÃ³n</strong>. Estos bits se mezclan con los datos de entrada y el resultado de la funciÃ³n interna <code>&quot;F&quot;</code>. La capacidad afecta la resistencia del algoritmo a ataques criptogrÃ¡ficos como colisiones o preimagen.</li>
</ul>
<p>La suma de <code>&quot;r&quot;</code> y <code>&quot;c&quot;</code> da como resultado el nÃºmero total de bits, <code>&quot;b&quot;</code>, utilizados en la funciÃ³n esponja de Keccak. Este valor determina la longitud del estado interno y, por lo tanto, la longitud de la salida generada por el algoritmo.</p>
<h2 id="funcionamiento-keccak"><a class="header" href="#funcionamiento-keccak">Funcionamiento keccak</a></h2>
<p>El algoritmo funciona de la siguiente manera, inicialmente la cadena de entrada se rellena con bits adicionales para enmascarar el mensaje inicial y se divide en bloques de longitud <code>&quot;r&quot;</code> bits. Luego, los <code>&quot;b&quot;</code> bits de estado se inicializan a <code>0</code>, que da inicio a la <strong>Sponge construction</strong> en dos fases <strong>&quot;absorbing&quot;</strong> y <strong>&quot;squeezing&quot;</strong>.</p>
<ul>
<li><strong>Fase Absorbing:</strong> a los bloques de entrada de longitud <code>r-bits</code> se les aplica un <a href="https://en.wikipedia.org/wiki/XOR_cipher">XOR</a> (toma dos bits y devuelve un resultado que es 1 si solo uno de los bits es 1, y 0 en caso contrario) a los primeros <code>r</code> bits del estado, alternÃ¡ndose con la funciÃ³n <code>f</code>. Cuando todos los bloques han sido procesados, se pasa a la siguiente fase.</li>
<li><strong>Fase Squeezing:</strong> los primeros <code>r</code> bits del estado son devueltos como bloques de salida, alternÃ¡ndose con ejecuciones de la funciÃ³n <code>f</code>. El nÃºmero de bloques de salida es seleccionado por el usuario.</li>
</ul>
<p>A continuaciÃ³n os dejamos una tabla que enumeran algunas de las diferencias entre <code>SHA-256</code> y <code>Keccak-256</code>.</p>
<p><img src="./assets/Comparativa_Sha_keccak.png" alt="graph" /></p>
<div align="center">
<em>Algunas diferencias entre SHA-256 y Keccak-256</em>
</div>
<p>Vemos cÃ³mo cada tipo de criptografÃ­a o funciÃ³n hash tiene caracterÃ­sticas distintas. En el contexto actual de la computaciÃ³n cuÃ¡ntica en constante evoluciÃ³n, es crucial abordar las preocupaciones emergentes sobre seguridad. Algunos algoritmos criptogrÃ¡ficos podrÃ­an ser vulnerables a los ataques cuÃ¡nticos en un futuro cercano. Es en este punto donde entra en juego el concepto de criptografÃ­a <a href="https://en.wikipedia.org/wiki/Post-quantum_cryptography">Post-Quantum</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quantum-secure"><a class="header" href="#quantum-secure">Quantum Secure</a></h1>
<p>Recomendamos repasar los episodios previos antes de leer este capÃ­tulo, con el fin de adquirir un mayor conocimiento de algunas definiciones y explorar posibles escenarios teÃ³ricos apocalÃ­pticos que podrÃ­an ocurrir. Pero antes comencemos con una breve descripciÃ³n sobre <a href="https://es.wikipedia.org/wiki/Computaci%C3%B3n_cu%C3%A1ntica">computaciÃ³n cuÃ¡ntica</a> para sumergirnos en el tema. <strong>No es mÃ¡s que un modelo de computaciÃ³n basado en la</strong> <a href="https://es.wikipedia.org/wiki/Mec%C3%A1nica_cu%C3%A1ntica"><strong>fÃ­sica cuÃ¡ntica</strong></a>, que funciona de manera diferente a las computadoras clÃ¡sicas (el tipo de computadoras que usamos habitualmente) y tiene la capacidad de realizar tareas que estas Ãºltimas no pueden, como romper ciertos algoritmos de manera eficiente.</p>
<blockquote>
<p><strong>Â¡AsÃ­ que espera un momento!</strong> Antes de que tu imaginaciÃ³n se desborde y te veas rodeado de supercomputadoras cuÃ¡nticas capaces de solucionar todos nuestros problemas, dÃ©jame contarte una pequeÃ±a anÃ©cdota.</p>
</blockquote>
<blockquote>
<p><em>Ah, las computadoras cuÃ¡nticas, esas criaturas de la fÃ­sica cuÃ¡ntica que nos hacen soÃ±ar con un futuro lleno de posibilidades. Pero, Â¿sabÃ­as que no son mÃ¡quinas mÃ¡gicas capaces de resolver todos nuestros problemas informÃ¡ticos en un abrir y cerrar de ojos?</em></p>
</blockquote>
<blockquote>
<p><strong>Imagina esto:</strong> las computadoras cuÃ¡nticas son como esas personas brillantes que son sÃºper eficientes en ciertas tareas, pero bastante dÃ©biles en otras. Son como el genio matemÃ¡tico que resuelve complicados problemas de cÃ¡lculo en segundos, pero se le olvida cÃ³mo atarse los zapatos.</p>
</blockquote>
<blockquote>
<p><em>Entonces, sÃ­, las computadoras cuÃ¡nticas pueden ser increÃ­blemente poderosas cuando se trata de ciertos problemas especÃ­ficos, como el factorizar nÃºmeros grandes o buscar en enormes bases de datos. Pero cuando se trata de tareas cotidianas, como revisar correos electrÃ³nicos o navegar por la web, bueno, digamos que son como un caracol tratando de correr una maratÃ³n.</em></p>
</blockquote>
<p>DespuÃ©s de esta pequeÃ±a relato, es importante comprender el concepto de criptografÃ­a post-cuÃ¡ntica <a href="https://cryptobook.nakov.com/quantum-safe-cryptography"><strong>(PQC)</strong></a>, tambiÃ©n conocida como <a href="https://cryptobook.nakov.com/quantum-safe-cryptography"><strong>Resistente a la ComputaciÃ³n CuÃ¡ntica</strong></a>, se refiere a algoritmos criptogrÃ¡ficos especialmente algoritmos de clave pÃºblica, que se consideran seguros contra los ataques criptoanalÃ­ticos llevados a cabo por computadoras cuÃ¡nticas.</p>
<p>A medida que avanza la computaciÃ³n cuÃ¡ntica, se espera que algunos algoritmos y tÃ©cnicas criptogrÃ¡ficas tradicionales utilizadas en los sistemas de seguridad actuales sean vulnerables a los ataques cuÃ¡nticos. Esto se debe a la capacidad de las computadoras cuÃ¡nticas para realizar cÃ¡lculos a una escala exponencialmente mayor que las computadoras clÃ¡sicas, lo que podrÃ­a comprometer la seguridad de los sistemas criptogrÃ¡ficos actuales.</p>
<p>Es bien sabido en informÃ¡tica que las computadoras cuÃ¡nticas podrÃ¡n romper algunos algoritmos criptogrÃ¡ficos, especialmente los criptosistemas de clave pÃºblica como <strong>RSA</strong>, el intercambio de llaves <strong>Diffieâ€“Hellman</strong> y <strong>ECDSA</strong>, que dependen del <a href="https://es.wikipedia.org/wiki/Factorizaci%C3%B3n_de_enteros"><strong>IFP</strong></a> (problema de factorizaciÃ³n en nÃºmeros primos), el <a href="https://es.wikipedia.org/wiki/Logaritmo_discreto"><strong>DLP</strong></a> (problema del logaritmo discreto) y el ECDLP (problema del logaritmo discreto de curva elÃ­ptica). Todos estos problemas podrÃ­an resolverse fÃ¡cilmente en una computadora cuÃ¡ntica suficientemente poderosa que ejecute el algoritmo de Shor.</p>
<p>Pero los algoritmos cuÃ¡nticos no significarÃ¡n el fin de la criptografÃ­a, porque:</p>
<ul>
<li>Solo algunos criptosistemas son inseguros frente a la computaciÃ³n cuÃ¡ntica (como RSA, DHKE, ECDSA y ECDH).</li>
<li>Algunos criptosistemas son seguros frente a la computaciÃ³n cuÃ¡ntica y solo se verÃ¡n ligeramente afectados (como los hash criptogrÃ¡ficos, algoritmos <a href="https://es.wikipedia.org/wiki/C%C3%B3digo_de_autenticaci%C3%B3n_de_mensaje">MAC</a> y cifrados de clave simÃ©trica como <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard?wprov=srpw1_0">AES</a>, siempre que se utilicen tamaÃ±os de clave suficientemente grandes).</li>
</ul>
<p>A diferencia de la amenaza que representa la computaciÃ³n cuÃ¡ntica para los algoritmos de clave pÃºblica actuales, <strong>la mayorÃ­a de los algoritmos criptogrÃ¡ficos simÃ©tricos y las funciones hash actuales se consideran relativamente seguros contra ataques de computadoras cuÃ¡nticas.</strong> Si bien el algoritmo cuÃ¡ntico de Grover acelera los ataques contra los cifrados simÃ©tricos, duplicar el tamaÃ±o de la clave puede bloquear eficazmente estos ataques. Por lo tanto, la criptografÃ­a simÃ©trica post-cuÃ¡ntica no necesita diferir significativamente de la criptografÃ­a simÃ©trica actual.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="el-algoritmo-de-grover-y-la-bÃºsqueda-no-estructurada"><a class="header" href="#el-algoritmo-de-grover-y-la-bÃºsqueda-no-estructurada">El algoritmo de Grover y la bÃºsqueda no estructurada</a></h1>
<p>El <a href="https://es.wikipedia.org/wiki/Algoritmo_de_Grover">algoritmo de Grover</a> es un <a href="https://es.wikipedia.org/wiki/Algoritmo_cu%C3%A1ntico">algortimo cuÃ¡ntico</a> para la bÃºsqueda en una secuencia no ordenada de datos con <code>N</code> componentes en un tiempo <a href="https://es.wikipedia.org/wiki/Cota_superior_asint%C3%B3tica">O</a>(NÂ¹/â‚‚), y con una necesidad adicional de espacio de almacenamiento de <code>O(logN)</code>. Fue inventado por Lov K. Grover en <a href="https://es.wikipedia.org/wiki/1996">1996</a>.</p>
<p>Aunque el algoritmo de Grover es eficiente, su paralelizaciÃ³n Ã³ptima resulta complicada y no se espera que las computadoras cuÃ¡nticas actuales tengan suficiente potencia para comprometer la seguridad de esquemas como ECDSA o de funciones de hash como SHA256.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="el-algoritmo-de-shor-teÃ³rico-y-su-impacto-en-ecdsa"><a class="header" href="#el-algoritmo-de-shor-teÃ³rico-y-su-impacto-en-ecdsa">El algoritmo de Shor teÃ³rico y su impacto en ECDSA</a></h1>
<p>El <a href="https://en.wikipedia.org/wiki/Shor&#x27;s_algorithm"><strong>algoritmo de Shor</strong></a> es un algoritmo cuÃ¡ntico desarrollado por Peter Shor en 1994. Este algoritmo es conocido por su capacidad para factorizar grandes nÃºmeros enteros de manera mucho mÃ¡s eficiente que los algoritmos clÃ¡sicos conocidos, lo que tiene implicaciones importantes para la seguridad de algunos sistemas criptogrÃ¡ficos basados en la factorizaciÃ³n de nÃºmeros enteros.</p>
<p>En el contexto de sistemas centralizados, como los sistemas bancarios, ECDSA se utiliza para garantizar la autenticidad de las transacciones, proteger la confidencialidad de la informaciÃ³n y asegurar la integridad de los datos. En el Ã¡mbito de Bitcoin y Ethereum, si bien los algoritmos de bÃºsqueda cuÃ¡ntica, como el algoritmo de Shor, podrÃ­an eventualmente romper la ECDSA, es importante destacar que estos algoritmos aÃºn estÃ¡n en una etapa teÃ³rica.</p>
<p>Cada implementaciÃ³n de algoritmos o protocolos puede ser diversa, ya sea privada o abstracta. Nos hemos centrado en los principios bÃ¡sicos comunes de ECDSA, ademÃ¡s se espera que la implementaciÃ³n prÃ¡ctica de algoritmos de bÃºsqueda cuÃ¡ntica sea un desafÃ­o tÃ©cnico debido a los requisitos de recursos y la necesidad de superar errores cuÃ¡nticos.</p>
<p>AquÃ­ tienes una descripciÃ³n general de en quÃ© consisten algunos problemas que se consideran complejos de resolver mediante la computaciÃ³n clÃ¡sica.</p>
<h2 id="ifp"><a class="header" href="#ifp">IFP</a></h2>
<p>El IFP se refiere al desafÃ­o de descomponer un nÃºmero entero grande en sus factores primos. En el caso de nÃºmeros pequeÃ±os, esto puede hacerse fÃ¡cilmente mediante el uso de algoritmos como <a href="https://yosoytuprofe.20minutos.es/2022/11/09/que-es-la-criba-de-eratostenes-y-cual-es-su-importancia-en-las-matematicas/">el cribado de EratÃ³stenes</a> o <a href="https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm_for_logarithms">el algoritmo de factorizaciÃ³n de Pollard</a>.</p>
<p>A modo de ejemplo simplificado, supongamos que queremos factorizar el nÃºmero compuesto <code>N = 35</code> utilizando el algoritmo de Shor. DespuÃ©s de aplicar el algoritmo, encontrarÃ­amos que los factores primos de <code>N</code> son <code>5 y 7</code>.</p>
<p>Sin embargo, a medida que los nÃºmeros crecen en tamaÃ±o, el IFP se vuelve cada vez mÃ¡s difÃ­cil de resolver. De hecho, la seguridad de muchos sistemas criptogrÃ¡ficos se basa en la dificultad de factorizar nÃºmeros grandes en tiempo razonable, como el popular algoritmo RSA.</p>
<h2 id="dlp"><a class="header" href="#dlp">DLP</a></h2>
<p>Por otro lado, el DLP implica encontrar el exponente desconocido de una potencia modular dada. En tÃ©rminos mÃ¡s sencillos, se trata de resolver la ecuaciÃ³n <code>(y = gË£ mod p)</code> para el exponente desconocido <code>(x)</code>, donde <code>(g)</code> y <code>(p)</code> son nÃºmeros conocidos e <code>(y)</code> es el resultado de la operaciÃ³n de potenciaciÃ³n modular. Para valores pequeÃ±os de <code>(p)</code>, el DLP puede resolverse mediante la aplicaciÃ³n de mÃ©todos exhaustivos como la prueba y error.</p>
<p>A modo de ejemplo simplificado, serÃ­a encontrar el logaritmo discreto de <code>base 2</code> para el nÃºmero <code>5</code> <code>mÃ³dulo 11</code>. Esto implica encontrar el valor de <code>x</code> en la ecuaciÃ³n <code>2Ë£ â‰¡ 5 (mod 11).</code></p>
<p>Realizando los cÃ¡lculos paso a paso:</p>
<ul>
<li>2Â¹ â‰¡ 2 (mod 11)</li>
<li>2Â² â‰¡ 4 (mod 11)</li>
<li>2Â³ â‰¡ 8 (mod 11)</li>
<li>2â´ â‰¡ 5 (mod 11)</li>
</ul>
<p>Entonces, el valor de <code>x</code> que satisface la ecuaciÃ³n <code>2Ë£ â‰¡ 5 (mod 11)</code> es <code>x = 4</code>.</p>
<h2 id="ecdlp"><a class="header" href="#ecdlp">ECDLP</a></h2>
<p>La seguridad de esquemas criptogrÃ¡ficos basados en <strong>ECC</strong>, como <strong>ECDSA</strong>, se basa en la dificultad de resoluciÃ³n del problema del logaritmo discreto de curva elÃ­ptica o <strong>ECDLP</strong>. Las curvas elÃ­pticas son objetos matemÃ¡ticos utilizados en criptografÃ­a de clave pÃºblica, y el <strong>ECDLP</strong> serÃ­a el problema de hallar el valor de <code>â€˜Kâ€™</code> en esta ecuaciÃ³n, <code>P =kâ‹…G</code>, donde <code>P</code> es un punto en la curva, <code>k</code> es el valor que debemos hallar y <code>G</code> es un punto base conocido (el generador).</p>
<p>Al igual que en el caso del <strong>DLP</strong>, el <strong>ECDLP</strong> se vuelve mÃ¡s difÃ­cil de resolver a medida que el tamaÃ±o de los nÃºmeros involucrados en esas expresiones matemÃ¡ticas aumentan</p>
<h2 id="ecdsa"><a class="header" href="#ecdsa">ECDSA</a></h2>
<p>Por Ãºltimo llegamos a un algoritmo ampliamente utilizado y conocido como es el <strong>ECDSA</strong>, que se utiliza comÃºnmente en blockchain. La clave pÃºblica se obtiene multiplicando un punto base conocido (llamado generador) en la curva elÃ­ptica por un entero, que representa la llave privada. El desafÃ­o radica en encontrar ese valor privado a partir del punto pÃºblico conocido en la curva.</p>
<p>La curva elÃ­ptica <strong>secp256k1</strong> estÃ¡ definida por la ecuaciÃ³n: <code>yÂ² = xÂ³ + ax + b</code> sobre <code>ğ”½p</code> donde <code>p</code> es un nÃºmero primo grande.</p>
<p>El algoritmo de Shor, en su versiÃ³n completa y ejecutado en un computador cuÃ¡ntico lo suficientemente grande y estable, podrÃ­a factorizar el nÃºmero primo <code>p</code> en esta ecuaciÃ³n, lo que proporcionarÃ­a informaciÃ³n sobre el orden del subgrupo cÃ­clico relacionado con la curva.</p>
<p>Si se pudiera determinar el orden del subgrupo cÃ­clico relacionado con la curva <code>secp256k1</code> utilizando el algoritmo de <strong>Shor</strong>, serÃ­a posible encontrar el valor privado a partir de la clave pÃºblica. Esto comprometerÃ­a la seguridad de <strong>ECDSA</strong>, ya que la clave privada es fundamental para generar firmas digitales y autenticar transacciones. Es importante destacar que el algoritmo de Shor plantea un desafÃ­o para los sistemas criptogrÃ¡ficos actuales basados en la factorizaciÃ³n de nÃºmeros enteros o en el logaritmo discreto, como <strong>RSA</strong> y <strong>ECDSA</strong>.</p>
<p>No obstante, la implementaciÃ³n prÃ¡ctica de un algoritmo cuÃ¡ntico capaz de realizar estos cÃ¡lculos, como los mencionados ejemplos, todavÃ­a se encuentra en desarrollo y no representa una amenaza inmediata para los sistemas criptogrÃ¡ficos utilizados en la actualidad. La investigaciÃ³n y el desarrollo continuo en criptografÃ­a pos-cuÃ¡ntica son fundamentales para garantizar la seguridad en un entorno tecnolÃ³gico en constante evoluciÃ³n.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="criptografÃ­a-basada-en-lattice-previene-shor"><a class="header" href="#criptografÃ­a-basada-en-lattice-previene-shor">CriptografÃ­a basada en Lattice previene Shor</a></h2>
<p>En este capÃ­tulo aprenderemos cÃ³mo una verificaciÃ³n de esquemas de firmas puede ser lo suficientemente fuerte para prevenirnos contra un posible ataque ejecutado con el algoritmo de Shor, la criptografÃ­a basada en retÃ­culos <a href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_basada_en_ret%C3%ADculos"><strong>(Lattice)</strong></a>, es una forma segura de protegerse frente a muchos algoritmos.</p>
<p>Pensemos en un <a href="https://es.wikipedia.org/wiki/Red_(grupo)">retÃ­culo</a>, como una estructura matemÃ¡tica que se forma mediante una red de puntos en un espacio n-dimensional. Es similar a una cuadrÃ­cula o una rejilla en dos dimensiones, pero se extiende a cualquier nÃºmero de dimensiones. Cada punto en el retÃ­culo estÃ¡ ubicado en una posiciÃ³n determinada y estÃ¡ conectado a los puntos vecinos por lÃ­neas rectas de igual longitud.</p>
<p>En el contexto de la criptografÃ­a basada en retÃ­culos, se utilizan retÃ­culos en <a href="https://es.wikipedia.org/wiki/Teor%C3%ADa_de_n%C3%BAmeros">teorÃ­a de nÃºmeros</a> para construir sistemas criptogrÃ¡ficos. Estos retÃ­culos se definen mediante un conjunto de vectores base, que son combinaciones lineales de vectores de coordenadas con coeficientes enteros. Los retÃ­culos tienen propiedades matemÃ¡ticas interesantes, como la propiedad de ser densos y uniformes en el espacio.</p>
<p>Los problemas computacionales basados en retÃ­culos, como el problema de la aproximaciÃ³n mÃ¡s cercana en retÃ­culos o el problema del vector corto mÃ¡s cercano, se utilizan en criptografÃ­a para establecer la seguridad de los esquemas basados en retÃ­culos. Estos problemas son difÃ­ciles de resolver y se cree que no existen algoritmos eficientes para resolverlos en el caso general, lo que brinda seguridad a los sistemas criptogrÃ¡ficos basados en retÃ­culos.</p>
<p>La criptografÃ­a basada en retÃ­culos es el tÃ©rmino genÃ©rico para las construcciones de primitivas criptogrÃ¡ficas que involucran retÃ­culos, ya sea en la construcciÃ³n misma o en la prueba de seguridad.</p>
<p><strong>Las construcciones basadas en retÃ­culos son actualmente candidatas importantes para la criptografÃ­a post-cuÃ¡ntica.</strong> A diferencia de los esquemas de clave pÃºblica mÃ¡s ampliamente utilizados y conocidos, como RSA, Diffie-Hellman o los criptosistemas de curva elÃ­ptica, que teÃ³ricamente podrÃ­an ser derrotados utilizando el algoritmo de Shor en un computador cuÃ¡ntico, algunas construcciones basadas en retÃ­culos parecen ser resistentes a los ataques tanto de computadoras clÃ¡sicas como cuÃ¡nticas. AdemÃ¡s, muchas construcciones basadas en retÃ­culos se consideran seguras bajo la suposiciÃ³n de que ciertos problemas computacionales bien estudiados en retÃ­culos no pueden ser resueltos.</p>
<p>AquÃ­ hay una breve explicaciÃ³n de las diferencias entre los esquemas de criptografÃ­a basados en retÃ­culos en tÃ©rminos de encriptaciÃ³n, funciones hash y intercambio de claves:</p>
<ol>
<li><strong>EncriptaciÃ³n basada en retÃ­culos:</strong> los esquemas de encriptaciÃ³n basados en retÃ­culos aprovechan las propiedades matemÃ¡ticas de los retÃ­culos para proporcionar seguridad en la comunicaciÃ³n.</li>
<li><strong>Funciones hash basadas en retÃ­culos:</strong> las funciones hash basadas en retÃ­culos utilizan retÃ­culos y operaciones matemÃ¡ticas relacionadas para calcular los hashes y se utilizan en diversas aplicaciones criptogrÃ¡ficas, como la integridad de datos y la firma digital.</li>
<li><strong>Intercambio de claves basado en retÃ­culos:</strong> el intercambio de claves basado en retÃ­culos como el <a href="https://newhopecrypto.org/">(Intercambio NewHope Protocol)</a> implica el establecimiento de una clave compartida entre dos o mÃ¡s partes que desean comunicarse de manera segura. Los protocolos de intercambio de claves basados en retÃ­culos utilizan los retÃ­culos y los problemas computacionales relacionados con ellos para garantizar que las partes puedan acordar una clave sin que un tercero pueda determinarla. Estos esquemas se basan en la dificultad de resolver ciertos problemas matemÃ¡ticos relacionados con los retÃ­culos para asegurar la confidencialidad de la clave compartida.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kyber-crystal"><a class="header" href="#kyber-crystal">Kyber Crystal</a></h1>
<p>En este estudio post-quantum veremos <a href="https://pq-crystals.org/kyber/resources.shtml"><strong>Kyber</strong></a>, antes de entrar dentro del ecosistema de Starkware y aprender cÃ³mo se generan los contratos de cuentas, asÃ­ como las caracterÃ­sticas criptogrÃ¡ficas y matemÃ¡ticas detrÃ¡s de las STARKs.</p>
<p>Kyber es un mÃ©todo de encapsulaciÃ³n de clave <a href="https://en.wikipedia.org/wiki/Key_encapsulation">(KEM)</a> diseÃ±ado para resistir ataques criptoanalÃ­ticos realizados por futuras computadoras cuÃ¡nticas poderosas. Se utiliza para establecer un secreto compartido entre dos partes que se comunican, sin que un atacante <a href="https://en.wikipedia.org/wiki/Ciphertext_indistinguishability">(IND-CCA2)</a> en el sistema de transmisiÃ³n pueda descifrarlo. Este criptosistema asimÃ©trico utiliza una variante del problema de redes de aprendizaje con errores <a href="https://en.wikipedia.org/wiki/Learning_with_errors">(learning with errors, LWE)</a> como su <a href="https://en.wikipedia.org/wiki/Trapdoor_function">funciÃ³n bÃ¡sica con trampa</a>. GanÃ³ la competencia del NIST para el primer estÃ¡ndar de criptografÃ­a PQ.</p>
<p>La generaciÃ³n de claves en Kyber no se basa en la factorizaciÃ³n de enteros o en problemas relacionados con las curvas elÃ­pticas, sino que utiliza el problema de aprendizaje con errores en retÃ­culos como base para la seguridad del algoritmo.</p>
<p>El sistema se basa en el aprendizaje con errores en mÃ³dulos (M-LWE) del campo del aprendizaje automÃ¡tico, en conjunto con anillos ciclotÃ³micos. Recientemente, tambiÃ©n se ha logrado una reducciÃ³n formal matemÃ¡tica estrecha de la problemÃ¡tica del anillo LWE al MLWE. <strong>En comparaciÃ³n con otros mÃ©todos de criptografÃ­a post-cuÃ¡ntica, tiene las ventajas tÃ­picas de los mÃ©todos basados en retÃ­culos, como el tiempo de ejecuciÃ³n, el tamaÃ±o de los textos cifrados y el material clave.</strong></p>
<p>En cuanto a los parÃ¡metros, Kyber proporciona diferentes conjuntos para alcanzar diferentes niveles de seguridad. Por ejemplo, <code>Kyber-512</code> tiene una seguridad aproximada equivalente a <code>AES-128</code>, <code>Kyber-768</code> tiene una seguridad aproximada equivalente a <code>AES-192</code> y <code>Kyber-1024</code> tiene una seguridad aproximada equivalente a <code>AES-256</code>.</p>
<p>En resumen, Kyber utiliza un enfoque matemÃ¡tico diferente a ECDSA en la generaciÃ³n de claves. Se basa en el problema de aprendizaje con errores en retÃ­culos y en la selecciÃ³n adecuada de parÃ¡metros de seguridad. La seguridad de Kyber radica en la dificultad de resolver problemas criptogrÃ¡ficos especÃ­ficos asociados a ese enfoque matemÃ¡tico.</p>
<p>Con esto hemos concluido las bases criptogrÃ¡ficas que nos han brindado los detalles de cÃ³mo se generan los distintos tipos de criptografÃ­a simÃ©trica o asimÃ©trica, asÃ­ como las funciones hash y su importancia en la seguridad. Nos adentramos en cÃ³mo se integraban en los Merkle Tree o Patricia Trie, para luego explorar el Ã¡mbito de la computaciÃ³n cuÃ¡ntica y ver cÃ³mo se podÃ­an resolver algunos de los problemas planteados por ciertas criptografÃ­as. TambiÃ©n destacamos la importancia de las firmas y las verificaciones de firmas en los avances de la tecnologÃ­a de la computaciÃ³n cuÃ¡ntica.</p>
<p>La computaciÃ³n cuÃ¡ntica se mostrÃ³ resistente a las bases simÃ©tricas de una llave maestra o a las funciones hash en sÃ­. AdemÃ¡s, presenciamos avances en la prevenciÃ³n de ataques cuÃ¡nticos y en algoritmos cuÃ¡nticos como Lattice o encapsulamientos por Kyber. Con estos avances en mente, es hora de pasar a ver las EOA (Externally Owned Accounts) y los firmantes en Ethereum, para luego diferenciarlos de la Account Abstraction nativa en Starknet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eoa-y-aa---firmantes"><a class="header" href="#eoa-y-aa---firmantes">EOA y AA - Firmantes</a></h1>
<p>Las cuentas de EOA <a href="https://ethereum.org/en/whitepaper/#ethereum-accounts"><strong>(Externally Owned Accounts)</strong></a> en Ethereum, al igual que muchas otras criptomonedas, utilizan el algoritmo ECDSA que aprendimos antes para generar claves y firmar transacciones digitalmente. Esto les permite participar de manera segura en la red y realizar operaciones. Las EOA son cuentas que pertenecen a usuarios externos a la cadena de bloques.</p>
<p>En Ethereum, el estado de una cuenta solo puede ser modificado a travÃ©s de transacciones, las cuales deben ser iniciadas por una EOA. sin embargo, no cualquier persona puede activar una transacciÃ³n desde cualquier EOA, aquÃ­ es donde entra en juego el concepto de firmante.</p>
<p>Cada cuenta en Ethereum estÃ¡ asociada con un objeto criptogrÃ¡fico llamado keypair, como aprendimos antes.</p>
<p>La clave privada, se utiliza para firmar mensajes digitales, mientras que la clave pÃºblica permite que cualquiera pueda verificar que una firma en particular fue generada por la clave privada correspondiente.</p>
<p>La asociaciÃ³n entre una cuenta y un firmante se realiza mediante la direcciÃ³n de la cuenta. La direcciÃ³n de un EOA se deriva de la clave pÃºblica del firmante, especÃ­ficamente, <strong>la direcciÃ³n se obtiene tomando los Ãºltimos 20 bytes del hash Keccak-256 de la clave pÃºblica.</strong></p>
<p>El propietario de una cuenta puede autorizar una transacciÃ³n desde su cuenta firmando los parÃ¡metros de la transacciÃ³n con la clave privada correspondiente.</p>
<p>La <a href="https://ethereum.org/en/whitepaper/#ethereum-accounts"><strong>curva elÃ­ptica secp256k1</strong></a>  es una de las curvas elÃ­pticas mÃ¡s utilizadas en criptografÃ­a, especialmente en el contexto de criptomonedas como Bitcoin o Ethereum. Esto ha permitido establecer esquemas de firmas digitales que garantizan la integridad de las transacciones al asegurar la autenticidad de las claves.</p>
<p>La abstracciÃ³n de firma y clave privada es una propiedad presente en algunos sistemas criptogrÃ¡ficos, como ciertos esquemas de firmas digitales basados en identidad. Sin embargo, en el caso del algoritmo ECDSA utilizado en Ethereum y muchas otras blockchain, la firma estÃ¡ inherentemente vinculada a la clave privada de la cuenta y no es posible separarlas o abstraerlas, como podrÃ­a ser el caso en otros esquemas diseÃ±ados con estos principios.</p>
<p>Ahora que ya hemos adquirido los conceptos bÃ¡sicos y hemos prestado atenciÃ³n para adquirir la formaciÃ³n adecuada y avanzada, podemos sumergirnos en el apasionante ecosistema de StarkWare, Starknet, StarkEx y STARKs. Nuestra mente estÃ¡ mejor preparada para embarcarnos en el viaje que nos espera en el resto del documento y en las futuras series.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="starknet-aa"><a class="header" href="#starknet-aa">Starknet AA</a></h2>
<p>En esta secciÃ³n sobre <a href="https://www.starknet.io/en"><strong>Starknet</strong></a>, continuaremos construyendo sobre los conceptos previamente abordados en los capÃ­tulos anteriores, donde exploramos temas fundamentales de criptografÃ­a. Esperamos que haya disfrutado de la informaciÃ³n y recursos presentados en capÃ­tulos anteriores, ya que han sido de vital importancia para comprender lo que abordaremos a continuaciÃ³n dentro de <strong>Starknet</strong>. Exploraremos cÃ³mo mejora todo el ecosistema y cÃ³mo los contratos de cuentas (CA) y el esquema de firmas abstraÃ­das ofrecen beneficios significativos en comparaciÃ³n con el <a href="https://medium.com/infinitism/erc-4337-account-abstraction-without-ethereum-protocol-changes-d75c9d94dc4a">ERC-4337</a>.</p>
<p><em>Si deseas aprender mÃ¡s sobre el concepto y las variantes del ERC-4337, te recomendamos leer esta serie de artÃ­culos en el blog de <a href="https://www.argent.xyz/argent-x/">Argent</a>. La serie estÃ¡ compuesta por la <a href="https://www.argent.xyz/blog/wtf-is-account-abstraction/">Parte 1</a>, <a href="https://www.argent.xyz/blog/part-2-wtf-is-account-abstraction/">Parte 2</a> y <a href="https://www.argent.xyz/blog/part-3-wtf-is-account-abstraction/">Parte 3</a>. Argent y <a href="https://braavos.app/">Braavos</a> son Smart wallets que aprovechan el poder del AA nativo en Starknet. TambiÃ©n te recomendamos leer los artÃ­culos de Braavos de <a href="https://braavos.app/account-abstraction-ethereum-comprehensive-guide/">Guide 101 AA</a> y <a href="https://braavos.app/account-abstraction-security-pyramid/">Security Pyramid AA</a>, los cuales presentan optimizaciones adicionales y capas de seguridad que exploraremos mÃ¡s adelante. Estos recursos te proporcionarÃ¡n una mejor comprensiÃ³n del concepto de <strong>AA</strong> y del <strong>ERC-4337</strong>.</em></p>
<p><strong>Â¡AsÃ­ que sin mÃ¡s preÃ¡mbulos, bienvenidos a Starknet!</strong></p>
<p>En el ecosistema de Starknet, se encuentran diversas metodologÃ­as para generar claves y firmas. A diferencia de las cuentas EOA, en Starknet se emplea <strong>Account Abstraction</strong> <a href="https://book.starknet.io/chapter_5/index.html"><strong>(AA)</strong></a> para la implementaciÃ³n de <strong>Contract Accounts</strong> <a href="https://book.starknet.io/chapter_5/index.html#ethereums_current_account_system_a_closer_look">(CA)</a>. Estos contratos son responsables de establecer la lÃ³gica en nuestras cuentas dentro de Starknet, incluyendo la validaciÃ³n del esquema de firma abstraÃ­do.</p>
<p>En lugar de utilizar ECDSA, Starknet utiliza una variaciÃ³n llamada [<strong>STARK Curve</strong>], un tipo de curva elÃ­ptica mÃ¡s amigable y optimizada que es nativa en el ecosistema, esta variante nos ofrece mejoras y caracterÃ­sticas especÃ­ficas para las necesidades de Starknet.</p>
<p>Lo grandioso de tener esta abstracciÃ³n nativa es que permite aÃ±adir diferentes lÃ³gicas en tus esquemas o capas adicionales. Normalmente, se utiliza un sistema asimÃ©trico usando la curva elÃ­ptica <code>secp256k1</code>, basado en la pseudoaleatoriedad y diversas operaciones matemÃ¡ticas utilizando dicha curva, para generar claves privadas y pÃºblicas. Sin embargo, tambiÃ©n se pueden aÃ±adir curvas adicionales de forma nativa al crear un CA, como lo ha hecho Braavos con la <a href="https://github.com/myBraavos/efficient-secp256r1">secp256r1</a>. Esta curva cuenta con un sistema de firmas integrado, mejor optimizado y preparado para dispositivos modernos, donde el signer puede almacenar los datos habilitados por biometricidad en dispositivos aislados y seguros, como el mÃ³dulo &quot;Enclave&quot; de Apple.</p>
<p>La AA desempeÃ±a un papel crucial al abstraer el esquema de firmas o verificaciÃ³n de firmas de la ejecuciÃ³n. Como vimos anteriormente, podemos generar una clave privada y mediante ECDSA generar una clave pÃºblica. En este caso el poseedor de esta clave privada y del esquema de firma asociado tiene el poder de realizar transacciones en Starknet, los <a href="https://book.starknet.io/chapter_8/transactions.html">dos tipos de transacciones</a> son <code>DEPLOY</code> o <code>INVOKE</code>.</p>
<p><img src="./assets/Invoke.png" alt="graph" /></p>
<div align="center">
<em>Contrato de Cuenta de usuario</em>
</div>
<p>Con AA podemos modificar estas firmas o curvas. Por ejemplo, la curva <code>Secp256r1</code>, vimos que ofrece una seguridad adicional en Braavos al configurar una firma biomÃ©trica en el mÃ³dulo de seguridad del enclave. De esta manera, esta firma biomÃ©trica solo puede ser aÃ±adida gracias a AA.</p>
<p>Todo esto es posible gracias al lenguaje de programaciÃ³n utilizado en la implementaciÃ³n, el poderoso <a href="https://starkware.co/cairo/"><strong>Cairo</strong></a>, asÃ­ que analicemos cÃ³mo Cairo incorpora esta abstracciÃ³n en su programaciÃ³n.</p>
<p>En primer lugar, se necesita validar la firma y comprobar que coincide con la generada mediante ECDSA antes de proceder a la ejecuciÃ³n. Estas dos funciones principales son <code>validate</code> y <code>execute</code>. AdemÃ¡s, <code>execute</code> tambiÃ©n puede realizar mÃºltiples llamadas utilizando <code>execute_calls</code>.</p>
<p><img src="./assets/invoke_execute.gif" alt="graph" /></p>
<div align="center">
<em>InformaciÃ³n de la LÃ³gica separada de las funciones validate, execute</em>
</div>
<p>Ahora analicemos cÃ³mo Cairo incorpora esta abstracciÃ³n en su programaciÃ³n.</p>
<p>Veamos cÃ³mo funciona un ciclo de transacciÃ³n con AA nativa y cÃ³mo se representa grÃ¡ficamente este ciclo completo de firmas para detectar si es correcto y realizar la operaciÃ³n.</p>
<p>TambiÃ©n pensemos en cÃ³mo se podrÃ­an combinar de manera eficiente firmas como ha realizado Braavos con la EC <code>secp256r1</code> o incluso realizar la verificaciÃ³n de firmas, como vimos con Lattice para prevenir ataques cuÃ¡nticos.</p>
<p><img src="./assets/transaccion.gif" alt="graph" /></p>
<div align="center">
<em>Ciclo completo de una firma y validaciÃ³n de una trnasacciÃ³n</em>
</div>
<p>Los conocimientos previos adquiridos nos han enseÃ±ado muchas cosas, una de ellas es cÃ³mo el algoritmo de Shor puede teÃ³ricamente romper ECDSA, pero no podrÃ¡ romper una prueba STARK. </p>
<p>En la secciÃ³n de generaciÃ³n de STARKs, aprenderemos como gracias a sus bases de criptografÃ­a simÃ©trica y otras variables, si alguien nos roba, hackea o perdemos la cuenta, el esquema <strong>PQS</strong> para la prueba no serÃ¡ de mucha utilidad, ya que no se ha alterado la integridad del estado de los datos, sino que por oun teÃ³rico ataque criptoanalÃ­tico se habrÃ¡ obtenido tu PK, lo que permitirÃ­a mover los fondos de forma justa.</p>
<p><strong>Pero, Â¿quÃ© sucederÃ­a si tuviÃ©ramos un esquema de verificaciÃ³n de firmas seguro frente a un ataque cuÃ¡ntico?</strong></p>
<p>AquÃ­ es donde entran en juego pequeÃ±os cambios, especÃ­ficamente en la parte de validaciÃ³n y no de ejecuciÃ³n, con las mejoras en Starknet y con la ayuda de AA nativo, estÃ¡ implementando para prepararse para el futuro. Una posibilidad serÃ­a el uso de Lattice o Kyber, aunque el futuro no estÃ¡ escrito, asÃ­ que ha llegado el momento de ver cÃ³mo se genera la parte de la EC.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-en-cairo---stark-curve"><a class="header" href="#ec-en-cairo---stark-curve">EC en Cairo - STARK Curve</a></h1>
<p>Como hemos visto en capÃ­tulos anteriores, en el contexto de los sistemas criptogrÃ¡ficos, la elecciÃ³n de la curva elÃ­ptica adecuada es de suma importancia. En este caso, se utiliza una variante de EC la cual ha sido especialmente diseÃ±ada y optimizada para su aplicaciÃ³n en el entorno de Starknet.</p>
<p>La STARK Curve <a href="https://github.com/starkware-libs/cairo-lang/blob/361fe32d5930db340ea78fe05aedfe706f6c9405/src/starkware/cairo/common/ec.cairo"><strong>(EC.cairo)</strong></a> se define mediante la ecuaciÃ³n:</p>
<p><img src="./assets/stark_curve.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Los valores especÃ­ficos de <code>Î±</code>, <code>Î²</code> y <code>p</code> utilizados en esta curva han sido cuidadosamente seleccionados para proporcionar propiedades criptogrÃ¡ficas sÃ³lidas y un rendimiento eficiente en el contexto de los contratos de cuenta nativos en Starknet.</p>
<p>En particular, los valores de <code>Î±</code>, <code>Î²</code> (notese que es <code>Ï€</code> â€œPIâ€ sin decimales usando 67 digitos) y <code>p</code> son los siguientes:</p>
<p><img src="./assets/stark_curve1.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Estos valores aseguran que la curva elÃ­ptica Stark-friendly cumple con los requisitos de seguridad necesarios para su aplicaciÃ³n en sistemas criptogrÃ¡ficos.</p>
<p>AdemÃ¡s se utiliza un punto generador <a href="https://docs.starkware.co/starkex/crypto/stark-curve.html">(G)</a> especÃ­fico asociado a esta curva. El punto generador <code>G</code> se define como:</p>
<p><img src="./assets/stark_curve_g.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Este punto generador desempeÃ±a un papel fundamental en el esquema de firmas digitales ECDSA, permitiendo la generaciÃ³n de claves pÃºblicas, como aprendimos al momento de hablar del Generador de Claves.</p>
<p>La elecciÃ³n de la curva elÃ­ptica Stark-friendly y el punto generador <code>G</code> asociado a ella proporcionan una base sÃ³lida y optimizada para la implementaciÃ³n de esquemas criptogrÃ¡ficos en el entorno de Starknet. Estos elementos garantizan la seguridad y eficiencia necesarias para la creaciÃ³n de contratos de cuenta nativos y la verificaciÃ³n de firmas digitales en el sistema.</p>
<p>Si desea probar y adentrarse en el despliegue de cuentas en Starknet, o si estÃ¡ interesado en aprender cÃ³mo se generan y calculan off-chain, y luego financiar esas cuentas para que los contratos de cuenta se autodesplieguen, le animamos a seguir los ejercicios oficiales de <a href="https://github.com/starknet-edu/starknet-accounts/blob/answers/ES%20README.md"><strong>Starknet-Edu Account</strong></a> o las <a href="https://github.com/Nadai2010/Nadai-StarknetEs-Guia-Cairo1#configuraci%C3%B3n-de-una-cuenta"><strong>GuÃ­as Completas Cairo 1</strong></a> proporcionadas por <a href="https://twitter.com/StarkNetEs">Starknet-Es</a> para realizar pruebas reales.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-braavos---secp256r1"><a class="header" href="#my-braavos---secp256r1">My Braavos - Secp256r1</a></h1>
<p>Comencemos explorando un dato interesante relacionado con la curva elÃ­ptica vista en capÃ­tulos anteriores, la <code>secp256k1</code>. En este contexto, la <code>k</code> hace referencia a <a href="https://es.wikipedia.org/wiki/Neal_Koblitz"><strong>Koblitz</strong></a>, un destacado matemÃ¡tico cuyas contribuciones fueron fundamentales para el desarrollo de la criptografÃ­a y la teorÃ­a de nÃºmeros.</p>
<p>Por otro lado, en el caso de <code>secp256r1</code>, la <code>r</code> significa <code>random</code>, resaltando el Ã©nfasis en el proceso de selecciÃ³n aleatoria de parÃ¡metros utilizado en esta curva elÃ­ptica.</p>
<p>Braavos ha incorporado la firma y validaciÃ³n de transacciones utilizando <code>secp256r1</code>, lo que brinda una excelente experiencia al usuario final al permitir transacciones con firma biomÃ©trica directamente en el dispositivo del usuario, aÃ±adiendo asÃ­ un nivel adicional de seguridad. Puedes encontrar mÃ¡s detalles sobre esta implementaciÃ³n en el <a href="https://braavos.app/account-abstraction-security-pyramid/">blog de Braavos</a>, donde presentan una interesante PirÃ¡mide de Seguridad AA.</p>
<p><img src="./assets/Mybraavos.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Podemos ver en la cÃºspide de la pirÃ¡mide al Multi-Signer (3FA). El Multi-Signer combina la protecciÃ³n de la frase de recuperaciÃ³n (seed phrase) en la extensiÃ³n del navegador y el Hardware Signer o Protected Signer utilizando el dispositivo mÃ³vil.</p>
<p>Ahora se requieren dos firmas de dos claves diferentes para ejecutar la transacciÃ³n en la cadena, obteniendo una autenticaciÃ³n de 3FA:</p>
<ul>
<li><strong>Algo que sabemos:</strong> la clave derivada de tu frase de recuperaciÃ³n en la extensiÃ³n del navegador.</li>
<li><strong>Algo que tenemos:</strong> tu dispositivo mÃ³vil.</li>
<li><strong>Algo que somos:</strong> tu huella dactilar o identificaciÃ³n biomÃ©trica facial.</li>
</ul>
<p>Cabe destacar que aunque se ha agregado otro firmante, no se ha aÃ±adido otra seed phrase, esto tambiÃ©n tiene el beneficio adicional de alejarse de las seed phrase a una mejor seguridad en los dispositivos mÃ³viles/computadoras portÃ¡tiles modernas, y seguridad superior cuando el dispositivo del usuario admite un chip de seguridad dedicado, como el <a href="https://cloud.google.com/blog/products/identity-security/titan-in-depth-security-in-plaintext">elemento seguro Titan de Android</a> o <a href="https://support.apple.com/es-us/guide/security/sec59b0b31ff/web">Enclave Secure de Apple</a>, etc.</p>
<p>Este chip Secure Enclave/Titan es un subsistema dedicado y aislado, totalmente separado del procesador de aplicaciones que puede generar claves privadas y mensajes de signo. Genera las teclas utilizando un generador interno de nÃºmeros aleatorios verdaderos <a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator"><strong>(TRNG)</strong></a> y firma mensajes a travÃ©s de la curva elÃ­ptica <code>secp256r1</code> a travÃ©s de su acelerador interno de claves pÃºblicas <a href="https://www.rambus.com/security/crypto-accelerator-cores/pka-ip-28/"><strong>(PKA)</strong></a>. Las claves privadas nunca abandonan el sistema seguro y son desconocidas / inaccesibles para cualquier persona, ni siquiera para el usuario o para la aplicaciÃ³n en sÃ­.</p>
<p>Esto significa que incluso si el nÃºcleo del procesador de la aplicaciÃ³n del dispositivo se ve comprometido, <strong>Â¡Nuestras claves se mantendrÃ¡n seguras!</strong></p>
<p><img src="./assets/Enclave.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Vemos que esta implementaciÃ³n de la firma ECDSA <code>secp256r1</code> en Cairo no es nativa, lo que significa que no tiene un Builtin dedicado nativo, esto puede llevar a un alto costo de gas al validar la firma. Sin embargo, Braavos es uno de los que han adoptado esta maravillosa novedad y estÃ¡ trabajando en mejorar la eficiencia de este proceso.</p>
<p>AdemÃ¡s, aprovechando la funcionalidad de Multi-Call incorporada, los usuarios pueden agrupar mÃºltiples transacciones en una Ãºnica transacciÃ³n atÃ³mica. Esto no solo acelera y reduce los costos de las transacciones, sino que tambiÃ©n permite a los usuarios aprobar la cantidad exacta que desean depositar, lo cual mejora la seguridad al eliminar la necesidad de <a href="https://hackernoon.com/erc20-infinite-approval-a-battle-between-convenience-and-security-lk60350r">aprobaciÃ³n infinita</a></p>
<p>En cuanto a la <strong>gestiÃ³n de firmantes</strong>, cuando se aÃ±ade un firmante adicional, como un Hardware Signer o Protected Signer, el firmante original basado en semillas ya no puede firmar transacciones, a menos que se solicite la eliminaciÃ³n del firmante adicional y se regrese al firmante basado en semillas. <strong>Esta solicitud tiene un retraso de tiempo (actualmente de 4 dÃ­as)</strong> para su procesamiento.</p>
<p>Por otro lado, la funciÃ³n de multifirma permite configurar la cuenta en modo de multifirma (actualmente admite 2 de 2), lo que significa que ninguna transacciÃ³n se ejecutarÃ¡ hasta que los 2 firmantes definidos en la cuenta firmen la transacciÃ³n. La seed phrase puede solicitar la desactivaciÃ³n de la multifirma, pero esto <strong>tambiÃ©n tiene un retraso de tiempo (actualmente 4 dÃ­as)</strong> antes de que se haga efectiva.</p>
<p>Vemos la importancia de las firmas y como vimos en el contexto del PQS, entendemos la relevancia de poder modificar nuestros esquemas de verificaciÃ³n de firmas, como la utilizaciÃ³n de Lattice o Kyber, por ejemplo. Ahora, centrÃ©monos en aprender cÃ³mo creamos una Stark Key para StarkEx, el motor de escalabilidad de Starknet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creaciÃ³n-de-una-stark-key-en-starkex"><a class="header" href="#creaciÃ³n-de-una-stark-key-en-starkex">CreaciÃ³n de una Stark Key en StarkEx</a></h1>
<p>Es importante comprender cÃ³mo <a href="https://mirror.xyz/dashboard/edit/KJVQJ6X6wvbf6ps1oy96zpE3TztWyhSIDZd2IHu5NuI">StarkEx</a> se comunica con otras billeteras en tÃ©rminos de firmas, y cÃ³mo mantiene todo el motor de transacciones y pruebas STARKs en su interior.</p>
<p>StarkEx ofrece soluciones altamente especializadas para diferentes aplicaciones que deseen construir sobre su servicio, y esto es parte de lo que StarkWare, como compaÃ±Ã­a, proporciona a grandes empresas o cualquier otra entidad que desee aprovechar su conjunto de profesionales y servicios adaptables.</p>
<p>Aplicaciones populares como Sorare, Rhino y Apex Pro, por ejemplo, aprovechan las soluciones ofrecidas por StarkWare. Estas aplicaciones especÃ­ficas se construyen sobre el marco de Starknet. Si bien no profundizaremos en los detalles especÃ­ficos de estas aplicaciones aquÃ­, se recomienda visitar la <a href="https://layer2es.notion.site/39d63a8af9ca4524a7237b1f2456e745">Biblioteca de Layer 2 en EspaÃ±ol</a> para obtener informaciÃ³n mÃ¡s detallada sobre cada una de ellas y comprender mejor cÃ³mo se integran en las soluciones de escalado de capa 2 de Ethereum.</p>
<p>Para utilizar StarkEx y asociar tu cuenta de MetaMask u otra billetera a Starknet, es necesario crear una Stark Key. StarkEx admite diferentes tipos de billeteras y mÃ©todos para crear esta clave, dependiendo de cÃ³mo se utilizarÃ¡ posteriormente. A continuaciÃ³n, se detallan las opciones disponibles:</p>
<h2 id="billeteras-compatibles-con-bip32"><a class="header" href="#billeteras-compatibles-con-bip32">Billeteras compatibles con BIP32</a></h2>
<p>Si estÃ¡s utilizando una billetera compatible con <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki"><strong>BIP32</strong></a>, como Ledger, se recomienda seguir el EIP-2645. Este estÃ¡ndar describe una ruta denominada <code>starkPath</code> y un algoritmo de derivaciÃ³n de clave que utiliza esta ruta para obtener la <code>starkPrivateKey</code>.</p>
<p>La <code>starkPath</code> estÃ¡ compuesta por cuatro parÃ¡metros pasados y dos parÃ¡metros internos, y sigue la siguiente estructura:</p>
<p><code>m/purpose'/layer'/application'/ethAddress1'/ethAddress2'/index</code></p>
<p>Los parÃ¡metros externos pasados son los siguientes:</p>
<ul>
<li><strong>Purpose:</strong> el nÃºmero de EIP correspondiente (en este caso, 2645).</li>
<li><strong>Layer:</strong> se utiliza para diferenciar entre tecnologÃ­as y se calcula como <code>sha256(layer) &amp; ((1 &lt;&lt; 31) - 1))</code>. En el contexto de StarkEx, el valor es <code>579218131</code> segÃºn lo descrito en el EIP-2645.</li>
<li><strong>Application:</strong> sirve para diferenciar entre aplicaciones y se calcula como: <code>sha256(application_name) &amp; ((1 &lt;&lt; 31) - 1))</code>.</li>
<li><strong>Index:</strong> permite tener mÃºltiples claves por direcciÃ³n de Ethereum.</li>
</ul>
<p>Los parÃ¡metros internos usados son los siguientes:</p>
<ul>
<li><strong>ethAddress1:</strong> Los 31 LSB de la direcciÃ³n Ethereum del usuario, es decir, <code>(ethAddress &amp; 1 &lt;&lt; 31) - 1</code></li>
<li><strong>ethAddress2:</strong> Los 31 LSB siguientes de la direcciÃ³n Ethereum del usuario, es decir, <code>(ethAddress &gt;&gt; 31) &amp; 1 &lt;&lt; 31) - </code>.</li>
</ul>
<p>AdemÃ¡s, es importante que las billeteras compatibles con BIP32 mantengan un estado persistente en relaciÃ³n con su propia direcciÃ³n de Ethereum.</p>
<h2 id="billeteras-no-compatibles-con-bip32"><a class="header" href="#billeteras-no-compatibles-con-bip32">Billeteras NO compatibles con BIP32</a></h2>
<p>Si estÃ¡s utilizando una billetera que no es compatible con BIP32, como MetaMask, se recomienda seguir el siguiente proceso:</p>
<ol>
<li>El usuario firma un mensaje utilizando su clave privada de Ethereum a travÃ©s de MetaMask u otra billetera similar. Se recomienda utilizar el estÃ¡ndar  IP-712 para brindar transparencia al usuario durante el proceso de firma. Es importante que el mensaje incluya una advertencia, indicando al usuario que so1lo debe firmarlo si proviene de un dominio especÃ­fico.</li>
<li>La firma <code>(r, s, v)</code> se utiliza como entrada para el algoritmo de derivaciÃ³n de clave, que generarÃ¡ la <code>starkPrivateKey</code>. Para realizar este cÃ¡lculo, puedes utilizar la biblioteca <a href="https://www.npmjs.com/package/@starkware-industries/starkware-crypto-utils">StarkEx Crypto SDK</a>. Primero, llama a la funciÃ³n <code>getPrivateKeyFromEthSignature</code> para obtener la clave privada a partir de la firma, y luego utiliza la funciÃ³n <code>privateToStarkKey</code> para calcular la <code>StarkKey</code>.</li>
</ol>
<p>Al seguir estos pasos, podrÃ¡s crear una Stark Key asociada a tu cuenta de MetaMask u otra billetera compatible. Esta clave te permitirÃ¡ interactuar con StarkEx y otras aplicaciones dentro del ecosistema de Starknet, realizar transacciones seguras y aprovechar las funcionalidades ofrecidas por esta plataforma.</p>
<p><img src="./assets/Stark_Key.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-y-funciones-hash"><a class="header" href="#starknet-y-funciones-hash">Starknet y Funciones Hash</a></h1>
<p>En capÃ­tulos anteriores aprendimos la importancia de las firmas, el poder de AA y la asociaciÃ³n de los hash dentro del ecosistema de Starknet y StarkEx. Ahora, profundicemos en cÃ³mo se utilizan y los diferentes tipos de hash que podemos encontrar.</p>
<h2 id="dominio-y-rango"><a class="header" href="#dominio-y-rango">Dominio y rango</a></h2>
<p>Todas las salidas de las funciones de hash se mapean eventualmente a elementos en <code>ğ”½â‚š</code> con <code>p = 2Â²âµÂ¹ + 17 â‹… 2Â¹â¹Â² + 1</code> como vimos en la Stark Curve.</p>
<p>Las funciones hash son componentes clave en las especificaciones de Starknet, y se utilizan para mapear las salidas de los cÃ¡lculos a elementos en el campo finito <code>ğ”½â‚š</code>. A continuaciÃ³n, explicaremos las tres funciones hash utilizadas en Starknet de manera mÃ¡s clara:</p>
<p><img src="./assets/Stark_func_hash.png" alt="graph" /></p>
<div align="center">
<em>Ciclo completo de una firma y validaciÃ³n de una trnasacciÃ³n</em>
</div>
<ol>
<li><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#starknet_keccak"><strong>sn_keccak:</strong></a> Esta funciÃ³n hash se basa en el algoritmo KECCAK, que es una familia de funciones hash criptogrÃ¡ficas como vimos antes. Su dominio es el conjunto de cadenas de bits compuestas por ceros y unos <code>{0,1}*</code> y su rango es el campo finito <code>ğ”½â‚š</code> La funciÃ³n toma una cadena de bits como entrada y produce una salida en el campo finito <code>ğ”½â‚š</code>.</li>
<li><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#pedersen_hash"><strong>Pedersen:</strong></a> La funciÃ³n hash Pedersen es una funciÃ³n hash computacionalmente segura que se utiliza en la construcciÃ³n de criptografÃ­a de compromiso cero y otras primitivas criptogrÃ¡ficas. Su dominio es el conjunto de pares de elementos del campo finito <code>ğ”½Â²p</code>, donde <code>p</code> es un nÃºmero primo, y su rango es el campo finito <code>ğ”½p</code>. La funciÃ³n toma un par de elementos del campo finito <code>ğ”½Â²p</code> como entrada y produce una salida en el campo finito <code>ğ”½p</code>.</li>
<li><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#poseidon_hash"><strong>Poseidon:</strong></a> La funciÃ³n hash Poseidon es una funciÃ³n hash criptogrÃ¡fica. Su dominio es un conjunto de elementos del campo finito <code>ğ”½p</code>, que incluye el cero y los elementos inversos multiplicativos, y su rango tambiÃ©n es el campo finito <code>ğ”½p</code>. La funciÃ³n toma un conjunto de elementos del campo finito <code>ğ”½p</code> como entrada y produce una salida en el campo finito <code>ğ”½p</code>.</li>
</ol>
<p>Las funciones de hash mencionadas son aÃ±adidas como <a href="https://mirror.xyz/0x7D1c14939AcEE5ca141c8beDF3474AFBf3884041/RTgQnMxeVGRCczih1pGXKy2KGFcU_xmf2NMx52wDgH0"><strong>Builtin</strong></a> (AIR integradas especÃ­ficas de aplicaciones), que se utilizan como herramientas adicionales en el protocolo para garantizar la seguridad y la integridad de las transacciones y los datos.</p>
<p>Estas funciones hash desempeÃ±an un papel fundamental en las operaciones de Starknet al garantizar la integridad y seguridad de los cÃ¡lculos realizados en el sistema.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak-starknet"><a class="header" href="#keccak-starknet">Keccak Starknet</a></h1>
<p>Keccak en Starknet es una implementaciÃ³n especÃ­fica de la funciÃ³n hash <code>Keccak256</code> adaptada para su uso en la red Starknet. Proporciona un mÃ©todo confiable y eficiente para calcular hashes dentro del entorno de Starknet.</p>
<p>Generalmente denotado por <code>sn_keccak</code>, se define como los primeros <strong>250 bits del hash Keccak256</strong> (esto es simplemente <code>Keccak256</code> ampliado para ajustarse a un field element â€œelemento de campoâ€).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pedersen-hash-starknet"><a class="header" href="#pedersen-hash-starknet">Pedersen Hash Starknet</a></h1>
<p>El <a href="https://docs.starknet.io/documentation/architecture_and_concepts/Hashing/hash-functions/#pedersen_hash">Pedersen hash</a> es una funciÃ³n hash criptogrÃ¡fica utilizada en criptografÃ­a propuesta por Torben Pedersen en 1991.</p>
<p>Uno de los aspectos interesantes del <a href="https://en.wikipedia.org/wiki/Commitment_scheme">esquema de compromiso de Pedersen</a> es su propiedad homomÃ³rfica, que permite realizar la adiciÃ³n entre dos compromisos. En otras palabras, dados dos mensajes <code>mâ‚</code> y <code>mâ‚‚</code>, y sus respectivas aleatoriedades <code>râ‚</code> y <code>râ‚‚</code>, el Pedersen hash permite combinarlos de manera segura.</p>
<p>La funciÃ³n Pedersen Hash utilizada en Starknet es resistente a colisiones para entradas de longitud fija, siempre y cuando la funciÃ³n de codificaciÃ³n subyacente sea inyectiva. Una funciÃ³n inyectiva asigna elementos distintos de su dominio a elementos distintos de su codominio, esto hace que el Pedersen hash sea resistente a ciertos tipos de ataques, como colisiones y preimÃ¡genes.</p>
<p>Sin embargo, es importante destacar que la implementaciÃ³n y el contexto en el que se utilice esta funciÃ³n pueden influir en su resistencia. Para obtener mÃ¡s informaciÃ³n se recomienda realizar una lectura sobre <a href="https://research.nccgroup.com/2023/03/22/breaking-pedersen-hashes-in-practice/">Pedersen hashes in Practice</a>.</p>
<p>En Starknet, se utiliza la EC amigable STARK curve sobre el campo finito <code>ğ”½â‚š</code> para calcular el Pedersen hash de manera eficiente y segura.</p>
<p><img src="./assets/Pedersen_Starknet.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<ul>
<li>Î± = 1</li>
<li>Î² = 31415926535897932384626433832795028841971693993751058209749 44592307816406665</li>
</ul>
<p>Los parÃ¡metros <code>Î±</code> y <code>Î²</code> de la curva son importantes en tÃ©rminos de seguridad y eficiencia en los algoritmos utilizados en la construcciÃ³n del Pedersen hash y los protocolos de ZKP o basados en STARK.</p>
<p>Dada una entrada <code>(a, b) âˆˆ ğ”½Â²p</code>, se divide en <code>alow</code>, <code>ahigh</code>, <code>blow</code> y <code>bhigh</code>, donde la parte <code>low</code> consiste en los <strong>248 bits menos significativos del elemento</strong> y la parte <code>high</code> consiste en los <strong>4 bits mÃ¡s significativos del elemento.</strong> El cÃ¡lculo del Pedersen hash se define de la siguiente manera:</p>
<p><img src="./assets/Pedersen_Starknet1.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>En esta fÃ³rmula, <code>[P]x</code> denota la coordenada <code>x</code> del punto <code>P</code>. Para calcular el hash, se realiza una combinaciÃ³n lineal de los puntos <code>P0, P1, P2 y P3</code>, ponderados por los valores <code>alow</code>, <code>ahigh</code>, <code>blow</code> y <code>bhigh</code>, respectivamente. Luego, se suma el punto <code>shift_point</code> y se extrae la coordenada <code>x</code> del resultado.</p>
<p>Los valores de las constantes <code>shift_point</code>, <code>P0</code>, <code>P1</code>, <code>P2</code> y <code>P3</code> se encuentran en el archivo <a href="https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/crypto/signature/fast_pedersen_hash.py">fast_pedersen_hash.py</a>. Este archivo contiene la implementaciÃ³n especÃ­fica del algoritmo necesario para calcular el Pedersen hash.</p>
<p>No se trata de puntos en la EC en sÃ­ misma, sino de valores especÃ­ficos que se han elegido para el cÃ¡lculo del hash y tampoco estÃ¡n relacionadas con la EC ni con el punto generador <code>G</code>, revise minuciosamente la informaciÃ³n oficial en caso de querer hacer pruebas sobre Stark Curve o Hash en Starknet. Estas constantes se eligen de forma independiente para el cÃ¡lculo del hash y se utilizan en combinaciÃ³n con los valores de entrada para obtener el hash resultante.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poseidon-hash-starknet"><a class="header" href="#poseidon-hash-starknet">Poseidon hash Starknet</a></h1>
<p>La funciÃ³n <strong>Poseidon hash</strong> es un <a href="https://www.poseidon-hash.info/">ZK-friendly Hashing</a>, pertenece a una familia de funciones hash diseÃ±adas para ser muy eficientes en circuitos algebraicos. Como tal, pueden ser muy Ãºtiles en sistemas ZK proof como STARKs y otros.</p>
<p>Poseidon es una construcciÃ³n de esponja basada en la permutaciÃ³n Hades, la estrategia de diseÃ±o Hades se basa en dividir el proceso en diferentes rondas para garantizar la seguridad y eficiencia del algoritmo:</p>
<ul>
<li>En las primeras rondas, denominadas <code>Rf</code>, se aplican las <code>S-boxes</code> al estado completo. Las <code>S-boxes</code> son funciones no lineales que mezclan y transforman los datos. En esta etapa inicial, se busca lograr una alta dispersiÃ³n de los bits en el estado.</li>
<li>DespuÃ©s de estas rondas iniciales, se llevan a cabo las rondas intermedias, denominadas <code>RP</code>. En cada ronda intermedia, se aplica Ãºnicamente una <code>S-box</code>, mientras que el resto del estado permanece sin cambios, es decir, se utiliza una funciÃ³n identidad en lugar de las <code>S-boxes</code> faltantes. Esta simplificaciÃ³n reduce el costo computacional y la complejidad del algoritmo.</li>
<li>Finalmente, en las Ãºltimas rondas, nuevamente se utilizan las <code>S-boxes</code> para el estado completo. Estas rondas finales, al igual que las rondas iniciales, permiten obtener una mezcla y transformaciÃ³n adicional de los datos.</li>
</ul>
<p>Para una revisiÃ³n mÃ¡s profunda sobre su integridad en sistema de Proof pueden revisar <a href="https://eprint.iacr.org/2019/458.pdf">POSEIDON: A New Hash Function for Zero-Knowledge Proof Systems (Updated Version)</a>.</p>
<p>La versiÃ³n de <strong>Poseidon</strong> utilizada en Starknet se basa en una permutaciÃ³n de estado de tres elementos.</p>
<p>El campo <strong>ğ”½</strong>, sobre el que se definen las declaraciones aritmÃ©ticas que utilizan Poseidon. A menudo es determinado por el sistema de prueba ZK. Lo mÃ¡s probable es que sea un subgrupo de primer orden del grupo de puntos de una curva elÃ­ptica. Poseidon mapea secuencias de elementos <strong>ğ”½</strong> a una secuencia de longitud fija de elementos <strong>ğ”½</strong>.</p>
<p>A continuaciÃ³n, se define el <strong>Poseidon hash</strong> de hasta 2 elementos, y tambiÃ©n se menciona una versiÃ³n que admite un nÃºmero arbitrario de entradas.</p>
<p><img src="./assets/Poseidon_Starknet.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashing-de-array-matrices"><a class="header" href="#hashing-de-array-matrices">Hashing de Array (matrices)</a></h1>
<p>En este capÃ­tulo, explicaremos cÃ³mo se realizan los hashings de Arrays (matrices) utilizando las funciones Pedersen y Poseidon en el contexto de Starknet. Estas operaciones son fundamentales para garantizar la integridad y seguridad de los cÃ¡lculos realizados en el sistema.</p>
<p>El hashing de un array implica aplicar la funciÃ³n de hash correspondiente a cada elemento del array, de manera secuencial o iterativa. Esto permite resumir y representar de manera compacta la informaciÃ³n contenida en el array, independientemente de su longitud o contenido especÃ­fico.</p>
<p>El hashing de un array es Ãºtil en muchas aplicaciones, como la verificaciÃ³n de integridad de datos, la indexaciÃ³n eficiente de informaciÃ³n y la identificaciÃ³n Ãºnica de elementos.</p>
<h2 id="pedersen"><a class="header" href="#pedersen">Pedersen</a></h2>
<p>La funciÃ³n hash Pedersen, denotada como <code>h</code>, se utiliza para calcular el hash de un array de elementos de campo. Consideremos un arreglo <code>aâ‚</code>, <code>aâ‚‚</code>, ..., <code>aâ‚™</code> que contiene <code>n</code> elementos. La definiciÃ³n de <code>h(aâ‚ aâ‚‚, ..., aâ‚™)</code> es la siguiente:</p>
<ol>
<li>Comenzamos con un valor inicial de 0.</li>
<li>Aplicamos la funciÃ³n de hash h al primer elemento aâ‚ junto con el valor inicial. El resultado se convierte en el nuevo valor inicial.</li>
<li>Continuamos aplicando la funciÃ³n de hash h al siguiente elemento aâ‚‚ junto con el valor anteriormente obtenido. Nuevamente, el resultado se convierte en el nuevo valor inicial.</li>
<li>Repetimos este proceso hasta llegar al Ãºltimo elemento aâ‚™, aplicando la funciÃ³n de hash en cada paso.</li>
<li>Finalmente, aplicamos la funciÃ³n de hash h al Ãºltimo elemento an junto con el valor obtenido en el paso anterior.</li>
</ol>
<p>De esta manera, obtenemos el resultado final que representa el hash del array completo.</p>
<p><img src="./assets/Hash_Array.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Esta construcciÃ³n en capas nos permite combinar de manera secuencial los elementos del array a medida que calculamos el hash. Cada iteraciÃ³n agrega un nivel adicional de seguridad y complejidad al resultado final.</p>
<h2 id="poseidon"><a class="header" href="#poseidon">Poseidon</a></h2>
<p>La funciÃ³n de hash Poseidon utiliza la permutaciÃ³n Hades, representada por hades: <code>ğ”½Â³â‚šâ†’ğ”½â‚š</code>, con los parÃ¡metros de Starknet. Dado un array <code>aâ‚</code>, <code>aâ‚‚</code>, ..., <code>aâ‚™</code> que contiene <code>n</code> field elements, definimos <code>poseidon(aâ‚, aâ‚‚, ..., aâ‚™)</code> como la primera coordenada de <code>H(aâ‚, aâ‚‚, ..., aâ‚™; 0, 0, 0)</code>,</p>
<ul>
<li><code>H(aâ‚, aâ‚‚, ..., aâ‚™; sâ‚, sâ‚‚, sâ‚ƒ)</code> se define de la siguiente manera:</li>
</ul>
<p><img src="./assets/Hash_Poseidon.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<ul>
<li><strong>Si n â‰¥ 2:</strong> entonces <code>H(aâ‚,aâ‚‚,...,aâ‚™;sâ‚,sâ‚‚,sâ‚ƒ) = H(aâ‚ƒ, aâ‚„, ..., aâ‚™;hades(sâ‚ + aâ‚, sâ‚‚ + aâ‚‚, sâ‚ƒ))</code>.</li>
<li><strong>Si n = 1:</strong> entonces <code>H(aâ‚; sâ‚, sâ‚‚, sâ‚ƒ) = hades(sâ‚ + aâ‚, sâ‚‚ + 1, sâ‚ƒ)</code>.</li>
<li><strong>Si n = 0:</strong> entonces <code>H(); sâ‚, sâ‚‚, sâ‚ƒ) = hades(sâ‚ + 1, sâ‚‚, sâ‚ƒ)</code>.</li>
</ul>
<p>En resumen, la <code>funciÃ³n poseidon(aâ‚,aâ‚‚,...,aâ‚™)</code> toma el array de field elements y aplica la permutaciÃ³n Hades en capas. Cada iteraciÃ³n de la permutaciÃ³n combina los elementos del array en funciÃ³n de los valores de  <code>sâ‚</code>, <code>sâ‚‚</code> y <code>sâ‚ƒ</code>, generando asÃ­ una salida Ãºnica. La primera coordenada de la salida final se considera el resultado de la funciÃ³n de hash Poseidon.</p>
<p>Esta construcciÃ³n en capas y la utilizaciÃ³n de la permutaciÃ³n Hades permiten obtener un hash seguro y resistente a ciertos ataques criptogrÃ¡ficos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="s-t-arks"><a class="header" href="#s-t-arks">S-T-ARKs</a></h1>
<p>Ahora, adentrÃ©monos en una de las partes mÃ¡s fascinantes del ecosistema, los <strong>STARKs</strong> <a href="https://starkware.co/stark/">(Scalable Transparent Argument of Knowledge)</a> que se basan en matemÃ¡ticas modernas, la existencia de funciones hash criptogrÃ¡ficas seguras y resistentes a las colisiones. Los STARKs presentan variados beneficios, entre los cuales tenemos:</p>
<ol>
<li>
<p><strong>Seguridad poscuÃ¡ntica:</strong> los <strong>STARK</strong> son plausiblemente seguros frente a ordenadores cuÃ¡nticos eficientes.</p>
</li>
<li>
<p><strong>Eficiencia concreta:</strong> el prover <strong>STARK</strong> es al menos <strong>10 veces mÃ¡s rÃ¡pido</strong> que el prover SNARK y el prover <a href="https://eprint.iacr.org/2017/1066.pdf">Bulletproofs</a>.</p>
<p>El verificador <strong>STARK</strong> es al menos <strong>2 veces mÃ¡s rÃ¡pido</strong> que el verificador <strong>SNARK</strong> y mÃ¡s de <strong>10 veces mÃ¡s rÃ¡pido</strong> que el verificador <strong>Bulletproof</strong>.</p>
<p>A medida que StarkWare continÃºe optimizando <strong>STARKs</strong> estos ratios probablemente mejorarÃ¡n. Sin embargo, la longitud de una prueba <strong>STARK es ~100x mayor</strong> que la correspondiente <strong>SNARK</strong> y <strong>~20x mayor que BulletProofs</strong>.</p>
</li>
</ol>
<p>Puede encontrar una imagen animada de una comparativa con los datos expuestos sobre el proving time y verification time, tamaÃ±o de la prueba, configuraciÃ³n inicial y PQS entre STARKs y SNARKs, veremos cÃ³mo cada una cumple con distintas propiedades que les permite ser recomendadas para variados usos.</p>
<p><img src="./assets//Stark_Prover.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Ahora que tenemos conceptos mÃ¡s profundos sobre algunos aspectos de la criptografÃ­a, funciones hash y las operaciones detrÃ¡s de cada una, veamos la importancia de la Integridad Computacional (CI), una propiedad fundamental para el dÃ­a a dÃ­a. Esta propiedad se refiere a la confianza en que la salida de un cÃ¡lculo es correcta, permitiÃ©ndonos confiar en el saldo de una cuenta o en el monto de una factura en una tienda.</p>
<blockquote>
<p><strong>Pero, Â¿cÃ³mo podemos garantizar esta integridad en un entorno digital donde no siempre podemos confiar en todas las partes involucradas?</strong></p>
</blockquote>
<p>AquÃ­ es donde entra en juego la tecnologÃ­a STARK, que se basa en estas Validity Proof para garantizar que la computaciÃ³n se realice correctamente, <strong>incluso si nadie estÃ¡ observando <code>â€œINTEGROâ€</code></strong>. STARKs utiliza matemÃ¡ticas para lograr este objetivo y estÃ¡ diseÃ±ado para monitorear y garantizar la integridad de un gran cÃ¡lculo realizado por un grupo de supercomputadoras poco confiables.</p>
<p>Las Validity Proofs son una herramienta crucial para garantizar la integridad y validez de los cambios realizados fuera de la cadena principal. Los sistemas de ZKP, en los que el prover posee informaciÃ³n secreta que no es conocida por el verifier, son clave para las Validity Proofs. En el caso de Starknet, se trata de un Validity Rollup que utiliza STARKs.</p>
<p>Es importante tener en cuenta que ZK en Starknet, es una propiedad adicional que se utiliza para afirmar al probador que no tiene que revelar ninguna informaciÃ³n incluida en el cÃ¡lculo. Sin embargo, en el caso de Starknet como una capa 2 pÃºblica, los datos de transacciÃ³n son pÃºblicos, lo que significa que no se ofrece privacidad como tal en transacciones, ocultar saldos u otras operaciones opacas, aunque los zk-STRAKs estÃ¡n listas para eso.</p>
<p>En Starknet, el enfoque principal es el Validity Rollup, que se utiliza para probar la validez del cÃ¡lculo computacional, a diferencia de otros protocolos que utilizan el tÃ©rmino <code>ZK Rollup</code>. Los STARKs en Starknet son Validity Proofs en lugar de ZK Proofs.</p>
<p>Los STARKs utilizan funciones de criptografÃ­a simÃ©trica y hash criptogrÃ¡ficos como componentes fundamentales en su construcciÃ³n, las vulnerabilidades cuÃ¡nticas conocidas en criptografÃ­a, como el algoritmo de Shor que puede factorizar nÃºmeros enteros grandes y romper sistemas de criptografÃ­a asimÃ©trica basados en factorizaciÃ³n, no afectan a las STARKs.</p>
<p><img src="./assets//Stark_1.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>En la imagen superior, se puede observar que las pruebas pueden basarse en principios de criptografÃ­a simÃ©trica o asimÃ©trica, como aprendimos al principio del documento. AdemÃ¡s, se pueden apreciar las diferentes propiedades de cada una en cuanto a escalabilidad, transparencia, seguridad en el futuro post-cuÃ¡ntico o tamaÃ±o de la prueba.</p>
<p>Como conclusiÃ³n final antes de pasar a sus propiedades podemos ver para pruebas cortas como se recomienda utilizar <strong>Groth16</strong> o <strong>SNARKs</strong>, mientras que para todo lo demÃ¡s se sugiere <strong>STARK</strong>. Es importante destacar que este campo se encuentra en constante desarrollo y cada uno sigue optimizando sus propias soluciones. Tanto las <strong>STARKs</strong> como Starknet tambiÃ©n experimentarÃ¡n optimizaciones para mejorar <strong>STARK</strong> y/o admitir diferentes tipos de pruebas. Un ejemplo de esto es como <a href="https://github.com/keep-starknet-strange">Keep-Starknet-Strange</a> el equipo detrÃ¡s de <a href="https://github.com/keep-starknet-strange/garaga"><strong>Garaga</strong></a>, que estÃ¡ trabajando en diversas librerÃ­as criptogrÃ¡ficas como <a href="https://eprint.iacr.org/2019/953.pdf">Plonk</a>, <a href="https://eprint.iacr.org/2016/260.pdf">Groth16</a>, <strong>SNARK</strong>, entre otras.</p>
<p>Si desea obtener mÃ¡s informaciÃ³n sobre como los STARKs estÃ¡n en diversas arquitectura y sus diversos casos de uso para asentar las bases dela criptografÃ­a moderna, recomendamos leer el articulo que sacamos para L2 EspaÃ±ol <a href="https://mirror.xyz/layer2es.eth/8TUEfpZPgl1u3-HyyGaUA0YMrFm8XSHfYtY6tfqFX7s">Profundizando en el Ecosistema STARKs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="propiedas-de-las-starks"><a class="header" href="#propiedas-de-las-starks">Propiedas de las STARKs</a></h2>
<p>En capÃ­tulos anteriores hemos visto cÃ³mo diferenciar los tipos de pruebas segÃºn su criptografÃ­a, asÃ­ como la comparativa entre varias de ellas. Ahora veamos cuÃ¡les son las dos propiedades esenciales en las pruebas y cÃ³mo se pueden lograr, antes de pasar a la definiciÃ³n de STARK</p>
<ol>
<li><strong>Succintness:</strong> exigimos que nuestras pruebas y, en particular, el tiempo de verificaciÃ³n sean sucintos, es decir, que sean Ã³rdenes de magnitud mÃ¡s pequeÃ±os que el tiempo necesario para calcular nuestro programa. De lo contrario, no habrÃ­a ninguna ventaja para el verificador en utilizar la prueba en lugar del cÃ¡lculo original.</li>
<li><strong>HeurÃ­stica Fiat-Shamir:</strong> este es un proceso mediante el cual podemos convertir una prueba interactiva en una no interactiva. Funciona proporcionando compromisos a los mensajes que formarÃ­an la interacciÃ³n y las funciones hash se utilizan como fuente de aleatoriedad.</li>
</ol>
<p>Uno de los protocolos que se utiliza en sistemas criptogrÃ¡ficos, como los STARKs, para abordar el desafÃ­o de verificar eficientemente la correcciÃ³n de grandes cÃ¡lculos polinomiales es FRI (Fast Reed-Solomon Interactive Oracle Proofs of Proximity).</p>
<p>FRI utiliza cÃ³digos de correcciÃ³n de errores Reed-Solomon para permitir pruebas interactivas eficientes. Esto significa que el probador puede proporcionar una prueba corta de la correcciÃ³n del cÃ¡lculo, mientras que el verificador puede verificar de manera eficiente la validez de la prueba. Este proceso interactivo permite realizar pruebas de proximidad, donde el verificador puede verificar de manera eficiente si el cÃ¡lculo reclamado se acerca al resultado correcto sin tener que evaluar por completo todo el polinomio.</p>
<blockquote>
<p>El conjunto de operaciones matemÃ¡ticas, bases criptogrÃ¡ficas, FRI y otras propiedades, como Fiat-Shamir, permite que las STARKs logren seguridad cuÃ¡ntica y escalabilidad, al tiempo que proporcionan una verificaciÃ³n transparente y eficiente de cÃ¡lculos complejos.</p>
</blockquote>
<p>Podemos decir entonces que los STARKs demuestran la correcta operaciÃ³n de una mÃ¡quina virtual al demostrar que la traza de ejecuciÃ³n asociada es vÃ¡lida con respecto al AIR dado. En tÃ©rminos generales, las trazas de ejecuciÃ³n se organizan como tablas de nÃºmeros, y el protocolo STARK demuestra que estos nÃºmeros resuelven conjuntamente un sistema de polinomios.</p>
<p>AsÃ­ vemos cÃ³mo algunas de estas propiedades, como <code>Succintness</code>, pueden venir de forma natural en las STARKs, y cÃ³mo el principio de Fiat-Shamir permite realizar pruebas interactivas. AdemÃ¡s, contar con FRI como correcciÃ³n de errores amplÃ­a las capacidades y visiÃ³n de las STARKs, asÃ­ que ahora vayamos a su definiciÃ³n</p>
<h2 id="s--scalable"><a class="header" href="#s--scalable">S = Scalable</a></h2>
<p>Una de las principales ventajas de STARKs es que al trasladar un cÃ¡lculo fuera de la cadena, se reducen de manera exponencial los costos de verificaciÃ³n en la cadena de bloques. El proceso de creaciÃ³n de una prueba fuera de la cadena tiene un costo similar al de solicitar a un Ãºnico nodo de la cadena de bloques que realice el cÃ¡lculo.</p>
<p>La producciÃ³n de pruebas no resulta considerablemente mÃ¡s costosa que la ejecuciÃ³n del cÃ¡lculo original, y la validaciÃ³n de las pruebas es <strong>exponencialmente mÃ¡s rÃ¡pida</strong> que la ejecuciÃ³n del cÃ¡lculo original. AdemÃ¡s, las pruebas son <strong>considerablemente mÃ¡s cortas</strong> en tamaÃ±o que el cÃ¡lculo original.</p>
<p>Otra ventaja importante es que a medida que se incrementa la cantidad de cÃ³mputo, su crecimiento es casi lineal. Esto la convierte en una opciÃ³n ideal para procesar transacciones a gran escala.</p>
<p><img src="./assets//Stark_2.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>AdemÃ¡s, se puede aprovechar la capacidad de paralelizaciÃ³n de pruebas por el prover y recursividad de los STARKs eficentes para mejorar significativamente la escalabilidad.</p>
<p><img src="./assets//Stark_3.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<h2 id="t--transparent"><a class="header" href="#t--transparent">T = Transparent</a></h2>
<p>La seguridad de las STARKs no depende de ceremonias de configuraciÃ³n elaboradas que puedan generar residuos tÃ³xicos criptogrÃ¡ficos, como ocurre en otras tecnologÃ­as de pruebas.</p>
<p>El uso de STARKs que tienen una base matemÃ¡tica compleja y que utilizan pseudoaleatoriedad proporciona un inicio de ceremonia transparente y elimina la necesidad de una configuraciÃ³n de confianza inicial (trusted setup), lo que mejora la seguridad y confiabilidad general del sistema criptogrÃ¡fico.</p>
<p>Una caracterÃ­stica importante de las STARKs es su construcciÃ³n basada en el trabajo de <a href="https://es.wikipedia.org/wiki/Silvio_Micali">Micali</a>. En esta construcciÃ³n, la Ãºnica criptografÃ­a necesaria para producir o validar una prueba corta <code>ğ›‘</code> es una <strong>funciÃ³n hash criptogrÃ¡fica</strong> <code>H</code>, como <code>SHA-256</code> o <code>Keccak</code>. La elecciÃ³n de <code>H</code> se convierte en el Ãºnico <strong>&quot;parÃ¡metro global&quot;</strong> que todos los usuarios del sistema de prueba deben conocer, y <strong>esta elecciÃ³n puede hacerse de manera pÃºblica, garantizando la transparencia de las pruebas criptogrÃ¡ficas obtenidas a travÃ©s de las STARKs.</strong></p>
<p>Sin embargo siempre comparamos STARKs con SNARKs o pruebas derivadas de criptografÃ­a asimÃ©trica como las <a href="https://eprint.iacr.org/2013/279.pdf">Pinocchio</a> de ECC, pero cada una tiene sus varientes y esquemas diversos, aunque para una explicaciÃ³n mÃ¡s clara cogeremos el ejemplo de <a href="https://medium.com/@VitalikButerin/zk-snarks-under-the-hood-b33151a013f6">VB en un artÃ­culo sobre zk-SNARKs</a>.</p>
<p><img src="./assets//Stark_4.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Imaginemos que tenemos un par de puntos <code>P</code> y <code>Q</code>, donde <code>P * k = Q</code>, y tienes un punto <code>C</code>, entonces no es posible obtener <code>C * k</code> a menos que <code>C</code> estÃ© <strong>&quot;derivado&quot;</strong> de alguna manera que conozcas a partir de <code>P</code>. Esto puede parecer intuitivamente obvio, pero esta suposiciÃ³n en realidad no puede derivarse de ninguna otra suposiciÃ³n (por ejemplo, la dificultad del logaritmo discreto) que usualmente utilizamos al probar la seguridad de los protocolos basados en EC. Por lo tanto, los SNARKs se basan en una base un tanto mÃ¡s frÃ¡gil que la ECC en general.</p>
<p>Supongamos que cae del cielo un par de puntos <code>(P, Q)</code>, donde <code>P * k = Q</code>, pero nadie conoce el valor de <code>k</code>. Ahora, supongamos que yo presento un par de puntos <code>(R, S)</code> donde <code>R * k = S</code>. Entonces, la suposiciÃ³n de conocimiento del extremo de la curva (KoE, por sus siglas en inglÃ©s) implica que la Ãºnica forma en que podrÃ­a haber creado ese par de puntos es tomando <code>P</code> y <code>Q</code>, y multiplicÃ¡ndolos por un factor <code>r</code> que <strong>solo yo conozco</strong>. TambiÃ©n hay que tener en cuenta que, gracias a la magia de las parejas de curvas elÃ­pticas, verificar que <code>R = k * S</code> no requiere conocer <code>k</code>; en su lugar, simplemente puedes comprobar si <code>e(R, Q) = e(P, S)</code>, donde e es una funciÃ³n de emparejamiento de curvas elÃ­pticas.</p>
<p>Hagamos algo mÃ¡s interesante. Supongamos que caen del cielo diez pares de puntos: <code>(P_1, Q_1), (P_2, Q_2) ... (P_10, Q_10)</code>. En todos los casos, se cumple que <code>P_i * k = Q_i</code>, ahora, supongamos que te proporciono un par de puntos <code>(R, S)</code> donde <code>R * k = S</code>.</p>
<p><strong>Â¿QuÃ© sabemos ahora?</strong> Que <code>R</code> es una combinaciÃ³n lineal de la forma <code>P_1 * i_1 + P_2 * i_2 + ... + P_10 * i_10</code>, donde yo conozco los coeficientes <code>i_1, i_2 ... i_10</code>, es decir, la Ãºnica forma de obtener un par de puntos <code>(R, S)</code> de esta manera es tomando algunos mÃºltiplos de <code>P_1, P_2 ... P_10</code> y sumÃ¡ndolos, y hacer el mismo cÃ¡lculo con <code>Q_1, Q_2 ... Q_10.</code></p>
<p>Enrtonces tenemos que tener en cuenta que dado cualquier conjunto especÃ­fico de puntos <code>P_1â€¦P_10</code> para los que puedas querer verificar combinaciones lineales, en realidad no puedes crear los puntos correspondientes <code>Q_1â€¦Q_10</code> sin conocer el valor de <code>k</code>, y si conoces el valor de <code>k</code>, entonces puedes crear un par <code>(R, S)</code> donde <code>R * k = S</code> para cualquier <code>R</code> que desees, sin necesidad de crear una combinaciÃ³n lineal.</p>
<p><strong>Por lo tanto, para que esto funcione, es absolutamente imperativo que quien cree esos puntos sea confiable y realmente elimine <code>k</code> una vez que haya creado los diez puntos.</strong></p>
<p>Se debe destacar la importancia de las ceremonias de ajuste inicial en ciertos casos, como en implementaciones de sistemas de votaciÃ³n. En estos casos, es crucial tener en cuenta quiÃ©n ha sido el creador de los puntos y si existe alguna posibilidad de manipulaciÃ³n o si se ha eliminado correctamente el valor de k. Esto es necesario para lograr transparencia y evitar depender de estas verificaciones. En este sentido, los STARKs se presentan como una soluciÃ³n prometedora y <strong>EFICIENTE</strong>, ya que proporcionan una base sÃ³lida que elimina la necesidad de confiar en dichas ceremonias de ajuste inicial.</p>
<h2 id="ark--argument-of-knowledge"><a class="header" href="#ark--argument-of-knowledge">ARK = Argument of Knowledge</a></h2>
<p>Los argumentos de conocimiento â€œARKâ€ son llevados a cabo por el prover que opera fuera de la cadena principal. Este probador se encarga de ejecutar el cÃ¡lculo requerido para la prueba, utilizando las entradas auxiliares necesarias, la realizaciÃ³n de la prueba fuera de la cadena principal es clave, ya que debe garantizar la integridad y la confiabilidad del proceso.</p>
<p>La principal ventaja de esta metodologÃ­a es que permite una verificaciÃ³n autÃ©ntica y matemÃ¡ticamente sÃ³lida. DespuÃ©s de que el probador haya realizado el cÃ¡lculo, puede proporcionar la prueba generada a cualquier computadora o entidad interesada para su verificaciÃ³n, haciendo uso de ARK sto significa que cualquier sistema informÃ¡tico puede confirmar la validez de la prueba de manera independiente.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="starks-eficientes"><a class="header" href="#starks-eficientes">STARKS eficientes</a></h2>
<p>En este capÃ­tulo, llegÃ³ el momento de comprender cÃ³mo los STARKs representan una versiÃ³n mÃ¡s eficiente de los <a href="https://en.wikipedia.org/wiki/Probabilistically_checkable_proof"><strong>(PCP)</strong></a>, un protocolo que permite establecer la exactitud de las declaraciones de <strong>CI</strong>, mediante una verificaciÃ³n aleatoria local en una prueba larga. Este protocolo se lleva a cabo entre un prover <strong>PCP</strong> y un verificador <strong>PCP</strong>.</p>
<p>En esta versiÃ³n, se han realizado ajustes para mejorar la cohesiÃ³n y la fluidez del texto. Se ha utilizado un lenguaje mÃ¡s claro y directo para explicar la relaciÃ³n entre los STARKs y los PCP, asÃ­ como su funciÃ³n en la verificaciÃ³n de declaraciones de informaciÃ³n computacional.</p>
<p>El prover <strong>PCP</strong> produce una cadena de prueba <code>ğš¿</code> que codifica el seguimiento de cÃ¡lculo de la declaraciÃ³n de <code>CI</code>, a pesar de que <code>ğš¿</code> es mÃ¡s larga que la traza de cÃ¡lculo de pasos <code>T</code>. Sin embargo, la cadena de prueba <code>ğš¿</code> tiene la propiedad especial de que puede ser validada a travÃ©s de una prueba probabilÃ­stica que lee solo una pequeÃ±a parte de <code>ğš¿</code>.</p>
<p>El verifier <strong>PCP</strong>, al recibir la misma declaraciÃ³n de <strong>CI</strong> <code>(A, x, y, T)</code>, puede validar la cadena de prueba <code>ğš¿</code> leyendo aleatoriamente unas pocas ubicaciones de <code>ğš¿</code> y luego realizar una <strong>&quot;verificaciÃ³n local&quot;</strong> econÃ³mica en los valores leÃ­dos. El nÃºmero de ubicaciones de lectura puede ser una pequeÃ±a constante, como 3, independientemente de la longitud de la traza de cÃ¡lculo <code>T</code>.</p>
<p>Si la declaraciÃ³n de CI es verdadera, el verifier siempre aceptarÃ¡. Sin embargo, si la declaraciÃ³n de CI es falsa, el verificador la rechazarÃ¡ con alta probabilidad, sin importar cÃ³mo se haya elegido la cadena de prueba <code>ğš¿</code>.</p>
<p><img src="./assets/Stark_Sudoku.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>En la imagen animada podemos ver un ejemplo de <strong>PCP</strong> con un conjunto de resticciones un sudoku y ahora veremos como los STARKs eficiente pueden mejorar la eficiencia de las <strong>PCP</strong> y <strong>MPCP</strong> con <strong>IOPs</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iops---interactive-oracle-proof"><a class="header" href="#iops---interactive-oracle-proof">IOPs - Interactive Oracle Proof</a></h1>
<p>Las Interactive Oracle Proof <a href="https://eprint.iacr.org/2016/116"><strong>(IOP)</strong></a> son un nuevo tipo de sistema de prueba que combina las propiedades clave de <strong>pruebas interactivas</strong> y <strong>PCP</strong>, las <strong>IOP</strong> permiten que un verifier estÃ© convencido de la exactitud de una declaraciÃ³n al interactuar con un prover no confiable mientras lee solo algunos bits de los mensajes enviados por el prover. Las <strong>IOP</strong> se han vuelto muy prominentes en el diseÃ±o de sistemas de prueba eficientes en los Ãºltimos aÃ±os.</p>
<blockquote>
<p><strong>Las construcciones STARK eficientes se obtienen combinando IOP eficientes y funciones hash criptogrÃ¡ficas. La IOP le confiere al STARK su escalabilidad, mientras que la funciÃ³n hash le confiere al STARK su transparencia.</strong></p>
</blockquote>
<p>Las STARKs eficientes se basan en IOP, de manera informal, un prover y un verifier participan en un protocolo interactivo en el que, en cada ronda, el verifier envÃ­a algo de aleatoriedad <code>ğ›”áµ¢</code> al prover, y el prover responde con una proof larga <code>ğš¿áµ¢</code>. Al final de la interacciÃ³n, el verificador realiza una verificaciÃ³n local aleatoria de todas las proof largas <code>(ğš¿â‚,ğš¿â‚‚,â€¦)</code> enviadas por el prover a lo largo de la interacciÃ³n.</p>
<p>Ahora, antes de sumergirnos en el mundo de los pasos de creaciÃ³n de un STARKs y su eficiencia, es importante comprender quÃ© es un polinomio, ya que desempeÃ±an un papel crucial en la construcciÃ³n y verificaciÃ³n de STARKs. Son utilizados para representar y manipular datos de manera eficiente, lo que permite lograr un alto nivel de compresiÃ³n y optimizaciÃ³n en el proceso de verificaciÃ³n.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="polinomios"><a class="header" href="#polinomios">Polinomios</a></h2>
<p>Los polinomios son una poderosa herramienta algebraica que se utiliza en diversas ramas de las matemÃ¡ticas y la fÃ­sica. Estas expresiones algebraicas estÃ¡n formadas por tÃ©rminos que contienen variables y coeficientes. Los tÃ©rminos son la suma o resta de monomios, que son productos de constantes y variables elevadas a exponentes enteros no negativos.</p>
<p>Un polinomio puede tener una o varias variables, y su grado estÃ¡ determinado por el exponente mÃ¡s alto presente en los tÃ©rminos del polinomio. Por ejemplo, el polinomio <code>3xÂ² - 2x + 1</code>  es un polinomio de grado 2, ya que el tÃ©rmino de mayor grado tiene un exponente de 2.</p>
<p>Los polinomios se pueden sumar, restar, multiplicar y dividir, y se emplean en ecuaciones algebraicas, cÃ¡lculo, geometrÃ­a y muchas otras ramas de las ciencias exactas.</p>
<p><strong>Â¿Por quÃ© no evalÃºa el verifier los propios polinomios?</strong></p>
<ul>
<li>Porque, en realidad, el prover no envÃ­a todos los polinomios al verificador, si lo hiciera perderÃ­amos la succintness, contienen mÃ¡s informaciÃ³n que nuestra declaraciÃ³n original, por lo que el prover sÃ³lo proporciona un compromiso con los polinomios.</li>
</ul>
<p><strong>Â¿QuÃ© propiedades de los polinomios son importantes en este caso?</strong></p>
<ul>
<li>Los polinomios son buenos cÃ³digos de correcciÃ³n de errores.</li>
</ul>
<p>Si tenemos polinomios de grado <code>d</code> sobre un dominio de codificaciÃ³n <code>D</code>, y dos mensajes <code>mâ‚</code> y <code>mâ‚‚</code>, entonces  <code>mâ‚</code> y <code>mâ‚‚</code> diferirÃ¡n en <code>|D|-d</code> puntos. Esto es importante porque queremos que la diferencia entre una declaraciÃ³n correcta y una incorrecta sea grande, de modo que sea fÃ¡cil de encontrar.</p>
<p>Esto conduce a un buen muestreo, lo que ayuda a la sucintez, sÃ³lo necesitamos muestrear unos pocos valores para estar seguros de que la probabilidad de error es lo suficientemente baja como para ser insignificante.</p>
<ul>
<li>Disponer de pruebas eficaces de lote cero mantiene la sucintez.</li>
</ul>
<p>Tener la capacidad de realizar pruebas de lote cero eficaces es fundamental. Esto nos permite demostrar de manera conjunta que un conjunto de elementos cumple con una determinada propiedad, en lugar de tener que probar cada elemento de forma individual, esta tÃ©cnica de prueba en lote nos permite lograr una mayor concisiÃ³n y eficiencia en la verificaciÃ³n.</p>
<p>Imaginemos que queremos demostrar que un polinomio de grado grande <code>P(x) (grado ~ 10 millones)</code> evalÃºa a <code>0</code> en los puntos <code>1...1 millÃ³n</code>, pero queremos hacerlo con una sola consulta.</p>
<p>Imaginemos que nuestra afirmaciÃ³n es que <code>P</code> desaparece en estos puntos. Si el verifier sÃ³lo utiliza el muestreo, el prover podrÃ­a hacer trampas fÃ¡cilmente proporcionando un punto que se evalÃºe como <code>0</code>, pero los otros <code>999.999</code> podrÃ­an ser distintos de <code>0</code>.</p>
<h2 id="resolviendo-el-problema"><a class="header" href="#resolviendo-el-problema">Resolviendo el problema</a></h2>
<p>Consideremos un conjunto <code>S = 1...10â¶</code></p>
<p>Definir <code>V</code> como el polinomio que se anula en estos puntos, es decir: <code>(x - 1)(x - 2)(x - 3)...</code> el grado de <code>V = tamaÃ±o de S</code> y esto es beneficioso porque:</p>
<ol>
<li><code>P(x) = P'(x) â€¢ V(x)</code></li>
<li><code>Grado de P = Grado de P' - TamaÃ±o de S.</code></li>
</ol>
<p>La introducciÃ³n de <code>V(x)</code> nos permite verificar en todo el dominio.</p>
<ul>
<li>Estos polinomios tienen una propiedad <strong>&quot;multiplicadora&quot;</strong>. Podemos <strong>&quot;envolver&quot;</strong> una restricciÃ³n alrededor de un polinomio.</li>
</ul>
<p>Por ejemplo, si tenemos la restricciÃ³n <strong>C</strong>, que indica que nuestra evaluaciÃ³n siempre serÃ¡ 0 o 1, podrÃ­amos expresarla como <code>C(x) = x â€¢ (x - 1)</code>. Esto se podrÃ­a interpretar como restringir una salida para que sea un booleano, lo cual es Ãºtil en tÃ©rminos de integridad computacional.</p>
<p>En lugar de tener <code>x</code> como un simple punto, podrÃ­amos considerar la evaluaciÃ³n de un  de un polinomio <code>Pâ‚(x)</code> en un punto especÃ­fico, es decir, <code>C(Pâ‚(x)) = Pâ‚(x)â€¢(Pâ‚(x)-1)</code></p>
<p>Los grados de los polinomios resultantes de la multiplicaciÃ³n son aditivos, por lo que el grado de <code>C(x) = 2 â€¢ grado de Pâ‚(x)</code></p>
<p>Podemos afirmar que si <code>Pâ‚(x)</code> cumple con esta restricciÃ³n para nuestro conjunto <code>S</code>, entonces, como mencionamos anteriormente, existe un polinomio <code>P'(x)</code> tal que:</p>
<ul>
<li><code>C(Pâ‚(x)) = P'(x) â€¢ V(x)</code></li>
</ul>
<p>Si <code>Pâ‚(x)</code> no cumpliera con la restricciÃ³n (por ejemplo, si para un valor de <code>x, Pâ‚(x) = 93</code>), entonces no podrÃ­amos encontrar esos polinomios, la igualdad no se cumplirÃ­a y habrÃ­a un residuo en la ecuaciÃ³n anterior.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creando-un-stark"><a class="header" href="#creando-un-stark">Creando un STARK</a></h1>
<p>En los prÃ³ximos capÃ­tulos del Libro de L2 sobre StarkWare, despuÃ©s de haber explicado algunas propiedades importantes de los polinomios y su relevancia, exploraremos la creaciÃ³n de un STARK desde sus fundamentos matemÃ¡ticos mÃ¡s profundos. Para obtener una comprensiÃ³n completa de los procesos involucrados y cÃ³mo se puede combinar un <code>PCP</code> con criptografÃ­a ligera para obtener un STARK, te recomendamos revisar la serie lanzada por Starkware, la cual ofrece una profundizaciÃ³n mÃ¡s detallada desde el inicio.</p>
<p>A continuaciÃ³n os dejaremos los enlaces a cinco artÃ­culos fundamentales traducidos al espaÃ±ol que complementarÃ¡n tu aprendizaje:</p>
<ol>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Comienza%20el%20viaje.md">Comienza el Viaje</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Aritmetizaci%C3%B3n%20I.md">AritmetizaciÃ³n I</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Aritmetizaci%C3%B3n%20II.md">AritmetizaciÃ³n II</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Prueba%20de%20bajo%20grado.md">Pruebas de Bajo Grado</a></li>
<li><a href="https://github.com/Starknet-Es/Maths-StarknetEs/blob/main/Gu%C3%ADas%20Oficiales/Un%20marco%20para%20STARKs%20eficientes.md">Un Frameword para STARKs Eficientes</a></li>
</ol>
<p>Estos recursos adicionales te brindarÃ¡n una visiÃ³n mÃ¡s completa y prÃ¡ctica del proceso de creaciÃ³n de una STARK. TambiÃ©n te recomendamos revisar los repositorios relacionados y los videos de creaciÃ³n de una STARK en Pioneros Clases 3, un Basecamp descentralizado en EspaÃ±ol creado por Starknet, o el de inglÃ©s impartido por Eli Ben-Sasson</p>
<p>Nos interesa la Integridad Computacional (CI), por ejemplo, saber que el programa de Cairo que escribiste se calculÃ³ correctamente.</p>
<ul>
<li>Tenemos que pasar por una serie de transformaciones desde el trazado de nuestro programa, hasta la prueba.</li>
<li>La primera parte de esto se llama aritmetizaciÃ³n, y consiste en tomar nuestra traza y convertirla en un conjunto de polinomios.</li>
<li>Nuestro problema se convierte entonces en uno en el que el prover intenta convencer a un verificador de que el polinomio es de grado bajo.</li>
<li>El verificador estÃ¡ convencido de que el polinomio es de grado bajo si y sÃ³lo si el cÃ¡lculo original es correcto (salvo una probabilidad infinitesimalmente pequeÃ±a).</li>
</ul>
<p><img src="./assets/Stark_5.gif" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>El uso de la aletoriedad es muy importante para el prover y el verifier, mientras que el prover utiliza la aleatoriedad para alcanzar el conocimiento cero, el verificador utiliza la aleatoriedad al generar consultas al prover, para detectar trampas por parte del prover.</p>
<p>Gran parte del trabajo que se realiza al crear una prueba consiste en garantizar que sea sucinta y que pueda elaborarse y verificarse en un tiempo razonable. Por tanto, nuestro plan consistirÃ¡ en:</p>
<ul>
<li>Reformular la traza de ejecuciÃ³n como un polinomio,</li>
<li>Extenderlo a un gran dominio,</li>
<li>Transformarlo, utilizando las restricciones polinÃ³micas, en otro polinomio que se garantiza que es de grado bajo si y sÃ³lo si la traza de ejecuciÃ³n es vÃ¡lida.</li>
<li>Queremos lograr una verificaciÃ³n sucinta, en la que el verificador de la declaraciÃ³n CI requiera exponencialmente menos recursos que los necesarios para la repeticiÃ³n ingenua.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aritmetizaciÃ³n"><a class="header" href="#aritmetizaciÃ³n">AritmetizaciÃ³n</a></h1>
<p>Tenemos dos pasos principales en este proceso:</p>
<ol>
<li>GeneraciÃ³n de una traza de ejecuciÃ³n y restricciones polinÃ³micas.</li>
<li>Transformar estos dos objetos en un Ãºnico polinomio de bajo grado.</li>
</ol>
<p>En tÃ©rminos de interacciÃ³n prover-verifier, realmente lo que ocurre es que entre ambos acuerdan de antemano cuÃ¡les son las restricciones polinÃ³micas.</p>
<p>A continuaciÃ³n, el prover genera una traza de ejecuciÃ³n y, en la interacciÃ³n posterior, intenta convencer al verificador de que las restricciones polinÃ³micas se cumplen en esta traza de ejecuciÃ³n, sin que el verificador lo vea.</p>
<p>La traza de ejecuciÃ³n es una tabla que representa los pasos del cÃ¡lculo subyacente, donde cada fila representa un Ãºnico paso y el tipo de traza de ejecuciÃ³n que buscamos generar debe tener la caracterÃ­stica especial de ser sucintamente comprobable:</p>
<ul>
<li>Cada fila puede ser verificada basÃ¡ndose sÃ³lo en las filas que estÃ¡n cerca de ella en la traza, y el mismo procedimiento de verificaciÃ³n se aplica a cada par de filas.</li>
</ul>
<p>Por ejemplo, imaginemos que nuestra traza representa un total en ejecuciÃ³n, con cada paso de la siguiente manera.</p>
<pre><code class="language-bash">                    â•”â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•—
                    â•‘  PASO  â•‘  IMPORTE  â•‘ TOTAL â•‘
                    â• â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•£
                    â•‘   0    â•‘     0     â•‘   0   â•‘
                    â• â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•£
                    â•‘   1    â•‘     5     â•‘   5   â•‘
                    â• â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•£
                    â•‘   2    â•‘     2     â•‘   7   â•‘
                    â• â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•£
                    â•‘   3    â•‘     2     â•‘   9   â•‘
                    â• â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•£
                    â•‘   4    â•‘     3     â•‘   12  â•‘
                    â• â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•£
                    â•‘   5    â•‘     6     â•‘   18  â•‘
                    â•šâ•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•
</code></pre>
<p>Si representamos la fila como <code>i</code> , y la columna como <code>j</code> , y los valores como <code>Aáµ¢,â±¼</code> , podrÃ­amos escribir algunas restricciones sobre esto de la siguiente manera:</p>
<ul>
<li><code>Aâ‚€,â‚‚=0</code></li>
<li><code>âˆ€1 &gt;= i &lt;= 5 : Aáµ¢,â‚‚ âˆ’ Aáµ¢,â‚ âˆ’ Aáµ¢-â‚,â‚‚ = 0</code></li>
<li><code>Aâ‚…,â‚‚ = 18</code></li>
</ul>
<p>Se trata de restricciones polinÃ³micas lineales en <code>Aáµ¢,â±¼</code></p>
<p>NÃ³tese que aquÃ­ estamos consiguiendo cierta concisiÃ³n porque podrÃ­amos representar un nÃºmero mucho mayor de filas con sÃ³lo estas 3 restricciones.</p>
<p>El sistema de restricciones aritmÃ©ticas define al menos dos tipos de restricciones sobre la traza de ejecuciÃ³n algebraica:</p>
<ol>
<li><strong>Restricciones de contorno:</strong> al principio o al final del cÃ¡lculo, un registro indicado tiene un valor determinado.</li>
<li><strong>Restricciones de transiciÃ³n:</strong> dos tuplas de estado consecutivas cualesquiera evolucionan de acuerdo con la funciÃ³n de transiciÃ³n de estado. En conjunto, estas restricciones se conocen como representaciÃ³n algebraica intermedia o AIR.</li>
</ol>
<p>Las STARKs avanzadas pueden definir mÃ¡s tipos de restricciones para tratar con la memoria o con la consistencia de los registros dentro de un ciclo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polinomio-para-nuestra-traza"><a class="header" href="#polinomio-para-nuestra-traza">Polinomio para nuestra traza</a></h1>
<p>Siguiendo el capÃ­tulo anterior, en esta ocasiÃ³n continuaremos definiendo un polinomio <code>f(x)</code> en el que los elementos de la traza de ejecuciÃ³n se obtienen a travÃ©s de  evaluaciones de <code>f</code> en potencias de algÃºn generador <code>g</code>.</p>
<p>Recordemos que nuestro campo finito tiene generadores, los cuales utilizaremos para indexar los pasos de la traza. Para ello, consideraremos una secuencia de Fibonacci que nos permitirÃ¡ establecer restricciones especÃ­ficas, como la siguiente:</p>
<ul>
<li><code>âˆ€ x âˆˆ {1,gÂ²,gÂ³...gâµâ°â¹}: f(gÂ²x) â‚‹ f(gx) â‚‹ f(x) = 0</code></li>
</ul>
<p>Esto restringe los valores entre las filas subsiguientes. TambiÃ©n significa que los valores g son raÃ­ces de este polinomio.</p>
<p>Por lo tanto, podemos utilizar el enfoque que vimos anteriormente para proporcionar el polinomio de fuga utilizando el tÃ©rmino <code>(x - gâ±)</code> y a partir de Ã©l creamos la ComposiciÃ³n Polinomial.</p>
<p>El hecho bÃ¡sico sobre polinomios y sus raÃ­ces es que si <code>p(x)</code> es un polinomio, entonces <code>p(a)=0</code> para algÃºn valor especÃ­fico a, si y sÃ³lo si existe un polinomio <code>q(x)</code> tal que <code>(x-a)q(x)=p(x)</code>, y <code>deg(p)=deg(q)+1.</code></p>
<p>Esta expresiÃ³n coincide con el polinomio de grado 2 como mÃ¡ximo si nuestra traza de ejecuciÃ³n ha sido correcta, es decir, ha obedecido a la restricciÃ³n de paso que hemos definido.</p>
<p>Si la traza difiere de eso, entonces es poco probable que esta expresiÃ³n produzca un polinomio de bajo grado.</p>
<h1 id="composiciÃ³n-polinomial"><a class="header" href="#composiciÃ³n-polinomial">ComposiciÃ³n Polinomial</a></h1>
<p>El Polinomio de ComposiciÃ³n en su traducciÃ³n tambiÃ©n conocido como ComposiciÃ³n Polinomial (CP), se realiza para demostrar eficazmente la validez del rastro de ejecuciÃ³n, nos esforzamos por alcanzar los dos objetivos siguientes:</p>
<ol>
<li>Componer las restricciones sobre los polinomios de la traza para hacerlas cumplir en la traza.</li>
<li>Combinar las restricciones en un Ãºnico polinomio (mÃ¡s grande), denominado ComposiciÃ³n Polinomial, de modo que se pueda utilizar una Ãºnica prueba de grado bajo para atestiguar su grado bajo.</li>
</ol>
<h1 id="ampliando-el-polinomio"><a class="header" href="#ampliando-el-polinomio">Ampliando el polinomio</a></h1>
<p>Como hemos visto antes, los polinomios pueden utilizarse para construir buenos cÃ³digos de correcciÃ³n de errores, ya que dos polinomios de grado d, evaluados en un dominio considerablemente mayor que d, son diferentes en casi todas partes.</p>
<p>Observando esto, podemos extender la traza de ejecuciÃ³n pensando en ella como una evaluaciÃ³n de un polinomio en algÃºn dominio, y evaluando este mismo polinomio en un dominio mucho mayor. Extendiendo de manera similar una traza de ejecuciÃ³n incorrecta, se obtiene una cadena muy diferente, lo que a su vez hace posible que el verificador distinga entre estos casos utilizando un pequeÃ±o nÃºmero de consultas.</p>
<h2 id="de-restricciones-polinÃ³micas-al-problema-de-las-pruebas-de-bajo-grado"><a class="header" href="#de-restricciones-polinÃ³micas-al-problema-de-las-pruebas-de-bajo-grado">De restricciones polinÃ³micas al problema de las pruebas de bajo grado</a></h2>
<p>En general, si nuestro cÃ¡lculo implica <code>N</code> pasos, la traza de ejecuciÃ³n estarÃ¡ representada por polinomios de grado inferior a <code>N</code></p>
<ul>
<li><code>f(X) = câ‚€ + câ‚X + câ‚‚XÂ² +â‹¯+ cÉ´-â‚Xá´ºâ»Â¹</code></li>
</ul>
<p>Los coeficientes <code>cáµ¢</code> estÃ¡n en el campo <code>ğ”½</code> y el lÃ­mite <code>N</code> en el grado es tÃ­picamente grande, quizÃ¡ del orden de unos pocos millones. A pesar de ello, estos polinomios se denominan de bajo grado.</p>
<p>Esto se debe a que el punto de comparaciÃ³n es el tamaÃ±o del campo. Por interpolaciÃ³n, toda funciÃ³n sobre <code>ğ”½</code> puede representarse mediante un polinomio.</p>
<p>La mayorÃ­a de ellos tendrÃ¡n un grado igual al tamaÃ±o total del campo, por lo que, comparado con Ã©ste, <code>N</code> es realmente bajo.</p>
<p>Este tipo de funciones, coherentes con un polinomio de bajo grado, tambiÃ©n se conocen como cÃ³digos <code>Reed-Solomon</code>.</p>
<p>Tras la generaciÃ³n de la traza, el prover se compromete con ella. Recordemos que no queremos enviar los polinomios al verificador como un todo, pero necesitamos que el prover se comprometa con ellos.</p>
<p>En todo el sistema, los compromisos se ejecutan construyendo Ã¡rboles de Merkle sobre las series de elementos de campo y enviando las raÃ­ces de Merkle al verificador.</p>
<p>Queremos que un verificador plantee al prover un nÃºmero muy reducido de preguntas y decida si acepta o rechaza la prueba con un alto nivel de precisiÃ³n garantizado. Idealmente, al verificador le gustarÃ­a pedir al prover que proporcione los valores en unos pocos lugares (aleatorios) en la traza de ejecuciÃ³n, y comprobar que las restricciones polinÃ³micas se mantienen para estos lugares.</p>
<p>Una traza de ejecuciÃ³n correcta pasarÃ¡ naturalmente esta prueba.</p>
<p>Sin embargo, no es difÃ­cil construir una traza de ejecuciÃ³n completamente errÃ³nea (especialmente si sabÃ­amos de antemano quÃ© puntos se comprobarÃ­an), que viole las restricciones sÃ³lo en un punto de la traza Ãºnico y, al hacerlo, llegar a un resultado completamente alejado y diferente. Identificar este fallo mediante un pequeÃ±o nÃºmero de consultas aleatorias es altamente improbable.</p>
<p>Pero recuerda que los polinomios tienen algunas propiedades Ãºtiles aquÃ­:</p>
<ul>
<li>Dos polinomios (diferentes) de grado <code>d</code> evaluados en un dominio considerablemente mayor que <code>d</code> son diferentes en casi todas partes.</li>
</ul>
<p>AsÃ­ que si tenemos un prover deshonesto, que crea un polinomio de bajo grado representando su traza (que es incorrecta en algÃºn punto) y lo evalÃºa en un dominio grande, serÃ¡ fÃ¡cil ver que este es diferente al polinomio correcto.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pruebas-de-bajo-grado"><a class="header" href="#pruebas-de-bajo-grado">Pruebas de Bajo Grado</a></h1>
<p>Las pruebas de bajo grado son realmente el corazÃ³n del proceso de verificaciÃ³n.</p>
<p>El supuesto de comprobaciÃ³n de bajo grado establece la existencia de un verificador probabilÃ­stico que comprueba si una funciÃ³n f es de grado como mÃ¡ximo d â‰ª |ğ”½|. El verificador debe distinguir entre los dos casos siguientes:</p>
<ol>
<li><strong>La funciÃ³n <code>f</code> es igual a un polinomio de bajo grado:</strong> es decir, existe un polinomio <code>p(x)</code> sobre <code>ğ”½</code>, de grado menor que <code>d</code>, que coincide con <code>f</code> en todas partes.</li>
<li><strong>La funciÃ³n <code>f</code> estÃ¡ lejos de TODOS los polinomios de bajo grado:</strong> por ejemplo, necesitamos modificar al menos el <strong>10%</strong> de los valores de <code>f</code> antes de obtener una funciÃ³n que concuerde con un polinomio de grado inferior a <code>d</code>.</li>
</ol>
<p>La aritmetizaciÃ³n muestra que un prover honesto que trate con una afirmaciÃ³n verdadera caerÃ¡ en el primer caso, mientras que un prover (posiblemente malicioso) que intente <strong>&quot;probar&quot;</strong> una afirmaciÃ³n falsa caerÃ¡, con alta probabilidad, en el segundo caso.</p>
<p>Otra forma de ver esto es que el polinomio de traza correcto combinado con las restricciones serÃ¡ necesariamente de grado bajo, el grado proviene del nÃºmero de pasos en nuestra traza (probablemente unos pocos millones), y la combinaciÃ³n de esto con los polinomios de restricciÃ³n (probablemente &lt; 10).</p>
<p>En general, cabrÃ­a esperar que los polinomios <strong>&quot;correctos&quot;</strong> tuvieran un grado de alrededor de <code>10â·</code> , mientras que un prover tramposo que eligiera puntos al azar del campo <code>ğ”½</code> obtendrÃ­a, tras la interpolaciÃ³n, polinomios de grado comparable al tamaÃ±o del campo, es decir, del orden de <code>2Â²âµâ¶</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fri"><a class="header" href="#fri">FRI</a></h1>
<p>FRI son las siglas de <a href="https://eccc.weizmann.ac.il/report/2017/134/">Fast Reed-Solomon IOP of Proximity</a>, es un protocolo que establece que un polinomio comprometido tiene un grado limitado.</p>
<p>El <a href="https://book.starknet.io/chapter_10/fri.html"><strong>FRI</strong></a> es complejo y gran parte del procesamiento que lo compone estÃ¡ diseÃ±ado para que las pruebas sean factibles y sucintas. TambiÃ©n hay mucho procesamiento involucrado con la protecciÃ³n contra diversos tipos de ataques que podrÃ­an ser realizados por el prover, y garantizar que todo se lleva a cabo en el conocimiento cero.</p>
<p>Su objetivo es encontrar si un conjunto de puntos se encuentran mayoritariamente en un polinomio de bajo grado y puede alcanzar una complejidad de prueba lineal y una complejidad de verificaciÃ³n logarÃ­tmica.</p>
<p>En general, hay 2 etapas : commit y query, contenidas en los siguientes pasos repetidos.</p>
<ol>
<li>El verifier envÃ­a un nÃºmero aleatorio al prover.</li>
<li>El prover genera un nuevo polinomio.</li>
<li>El verifier genera los conjuntos puntuales de consultas y los envÃ­a al prover.</li>
<li>El prover evalÃºa los valores polinÃ³micos correspondientes.</li>
<li>El verifier realiza una comprobaciÃ³n de validez.</li>
</ol>
<p>Aprendamos como FRI es un protocolo entre un probador y un verificador, que establece que una codeword dada pertenece a un polinomio de grado bajo.</p>
<p>El prover conoce explÃ­citamente este codeword, mientras que el verificador sÃ³lo conoce su raÃ­z Merkle y las hojas de su elecciÃ³n, suponiendo la validaciÃ³n satisfactoria de las rutas de autenticaciÃ³n que establecen la pertenencia de las hojas al Merkle Tree.</p>
<p>Una de las grandes ideas para los sistemas de pruebas de los Ãºltimos aÃ±os ha sido la tÃ©cnica de dividir y doblar. La idea es reducir una afirmaciÃ³n a dos afirmaciones de la mitad de tamaÃ±o. A continuaciÃ³n, ambas afirmaciones se fusionan en una sola utilizando pesos aleatorios proporcionados por el verificador.</p>
<p>DespuÃ©s de muchos pasos, la afirmaciÃ³n se ha reducido a una de tamaÃ±o trivial que es verdadera si y sÃ³lo si (modulo alguna degradaciÃ³n de seguridad insignificante) la afirmaciÃ³n original era verdadera.</p>
<p>El Verifier inspecciona los Merkle Tree (en concreto: pide al prover que proporcione las hojas indicadas con sus rutas de autenticaciÃ³n) de rondas consecutivas para comprobar una relaciÃ³n lineal simple.</p>
<p>Para los provers honestos, el grado de los polinomios representados tambiÃ©n se reduce a la mitad en cada ronda y, por tanto, es mucho menor que la longitud de la codeword. Sin embargo, para los provers maliciosos, este grado es uno menos que la longitud de la codeword. En el Ãºltimo paso, el prover envÃ­a una codeword no trivial correspondiente a un polinomio constante.</p>
<p>DespuÃ©s de explorar los diferentes pasos en la creaciÃ³n detrÃ¡s de un STARKs y la importancia de las pruebas de integridad, es evidente que estas pruebas son fundamentales para garantizar la seguridad y confiabilidad de los sistemas del Futuro.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leve-introducciÃ³n-cairo"><a class="header" href="#leve-introducciÃ³n-cairo">Leve introducciÃ³n Cairo</a></h1>
<p>Para concluir esta primera parte del L2 Book sobre Starkware, antes de adentrarnos en los prÃ³ximos temas sobre la arquitectura de Starknet y Cairo, haremos una breve introducciÃ³n a Cairo y su relaciÃ³n con la CVM (MÃ¡quina Virtual de Cairo). En este contexto, es relevante comprender cÃ³mo todos los pasos de un cÃ¡lculo pueden ser representados mediante polinomios, utilizando lo que se conoce como la RepresentaciÃ³n Algebraica Intermedia (AIR).</p>
<p>Los bloques de cÃ¡lculo pueden ser representados como AIR y tienen la capacidad de combinarse entre sÃ­, lo que se convierte en la base de Cairo. Para ilustrarlo mediante una analogÃ­a con el hardware:</p>
<ul>
<li><strong>ASIC (AIR)</strong></li>
<li><strong>CPU (varias AIR)</strong></li>
</ul>
<p>El nombre <strong>Cairo</strong> deriva de una CPU construida a partir de AIRs:</p>
<ul>
<li><strong>(CPU-AIR, Oh genial -&gt; CAIRO)</strong></li>
</ul>
<p>Cairo es un lenguaje funcional de alto nivel, no determinista y Turing completo, que cuenta con un modelo de memoria basado en registros y un compilador que produce una tabla de pasos computacionales llamada traza.</p>
<blockquote>
<p>En los programas escritos en Cairo, se especifican los resultados que se consideran aceptables, no cÃ³mo obtenerlos.</p>
</blockquote>
<p>En los capÃ­tulos anteriores, hemos visto cÃ³mo, en el proceso de construcciÃ³n de pruebas STARK, el prover utiliza esta traza para crear Representaciones Algebraicas Intermedias (AIRs). Posteriormente, estas AIRs se combinan y convierten en pruebas STARK.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusiÃ³n"><a class="header" href="#conclusiÃ³n">ConclusiÃ³n</a></h1>
<p>Con esto, concluimos nuestro profundo viaje por el mundo de la criptografÃ­a, explorando la generaciÃ³n de claves privadas y pÃºblicas, asÃ­ como sus diversas implementaciones. Hemos aprendido cÃ³mo Starknet y los esquemas de firmas pueden prevenir ataques criptoanalÃ­ticos, y hemos visto cÃ³mo las STARKs han sido diseÃ±adas desde su inicio para brindar seguridad matemÃ¡tica frente a ataques cuÃ¡nticos, siguiendo sus principios fundamentales.</p>
<p>Starknet estÃ¡ sentando las bases de la criptografÃ­a moderna y creando un ecosistema escalable, Ã­ntegro y seguro por una de las mayores descentralizada como Ethereum, escalemos juntos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducciÃ³n-parte-2"><a class="header" href="#introducciÃ³n-parte-2">IntroducciÃ³n Parte 2</a></h1>
<p>Â¡Hola comunidad! ğŸ‘‹</p>
<p>Nos complace presentar la segunda parte del libro <strong>L2 en EspaÃ±ol sobre StarkWare</strong>. En estos capÃ­tulos, nos enfocaremos en la fascinante arquitectura de Starknet y el poderoso lenguaje de programaciÃ³n, Cairo. Antes de profundizar en ello, agradecemos a los expertos y colaboradores que han aportado su valioso conocimiento para enriquecer este documento y han sido parte activa en el Ã©xito de esta investigaciÃ³n sobre la arquitectura de StarkWare.</p>
<p>En esta etapa, estamos emocionados de adentrarnos en el desarrollo detrÃ¡s de StarkWare, un ecosistema en el que brillantes mentes trabajan en conjunto para alcanzar logros extraordinarios.</p>
<p>Â¿Te sientes inspirado para ser parte de esta comunidad de mentes brillantes? Si es asÃ­, te animamos a acompaÃ±arnos en este viaje. Nos sumergiremos en los detalles mÃ¡s profundos, exploraremos algunos conceptos clave para establecer una sÃ³lida base y contextualizar los componentes como StarkEx, Starknet, SHARP, Secuenciadores, Starknet Stack y mucho mÃ¡s.</p>
<p>Â¡PrepÃ¡rate para un emocionante recorrido por el mundo de Starknet y Cairo! Â¡Comencemos! ğŸš€</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arquitectura-starknet-y-cairo"><a class="header" href="#arquitectura-starknet-y-cairo">Arquitectura Starknet y Cairo</a></h1>
<p>Starknet es una soluciÃ³n escalabilidad de de capa 2 para ETH que ofrece transacciones rÃ¡pidas, seguras y de bajo costo. Funciona como un Validity Rollup (confundidos o mal nombrados a veces como ZK Rollup) que utiliza sistemas criptogrÃ¡ficos llamados STARKs para reducir los costos de computaciÃ³n.</p>
<p>Starknet introduce una innovadora soluciÃ³n de Capa 2 para ETH, que aprovecha la tecnologÃ­a de STARKs para revolucionar la escalabilidad y seguridad. En este documento ofreceremos informaciÃ³n sobre la estructura de Starknet y Cairo, en los primeros capÃ­tulos daremos una visiÃ³n tÃ©cnica detallada de la arquitectura de la red Starknet y sus componentes clave <code>Sequencers</code>, <code>Provers</code> y <code>Nodes</code>. Estos actores trabajan en armonÃ­a, impulsando el procesamiento eficiente de la red y asegurando la integridad de las transacciones. Aunque Starknet se encamina hacia la descentralizaciÃ³n total, actualmente se enfoca en el desarrollo para alcanzar este objetivo final. </p>
<h2 id="caracterÃ­sticas-generales-de-starknet"><a class="header" href="#caracterÃ­sticas-generales-de-starknet">CaracterÃ­sticas Generales de Starknet</a></h2>
<p>Veamos algunas carÃ¡teristicas bÃ¡sicas antes de pasar a componente y su arquitectura.</p>
<ul>
<li><strong>Bajos costos de transacciÃ³n:</strong> Los costos de transacciÃ³n en Starknet son significativamente inferiores a los de Ethereum. Con prÃ³ximas mejoras como Volition (disponibilidad de datos fuera de la cadena) y la implementaciÃ³n de EIP 4844 en L1, se espera que estos costos disminuyan aÃºn mÃ¡s.</li>
<li><strong>Plataforma amigable para desarrolladores:</strong> Starknet proporciona un entorno que empodera a los desarrolladores para construir aplicaciones descentralizadas utilizando STARKs y el lenguaje de programaciÃ³n Cairo.</li>
<li><strong>Alto rendimiento y baja latencia:</strong> Las futuras versiones de Starknet tienen como objetivo aumentar el rendimiento de la red, reducir la latencia de las transacciones y disminuir los costos de las mismas.</li>
<li><strong>La FilosofÃ­a de Starknet:</strong> La filosofÃ­a de Starknet se centra en ser amigable para los desarrolladores. La red estÃ¡ diseÃ±ada con un claro enfoque en proporcionar a los desarrolladores una plataforma robusta, segura y poderosa para construir el futuro de la infraestructura y las aplicaciones descentralizadas.</li>
<li><strong>Rendimiento:</strong> Starknet ofrece mayor rendimiento, menor latencia y costos de transacciÃ³n reducidos, facilitando asÃ­ la creaciÃ³n de aplicaciones intensivas en cÃ³mputo.</li>
<li><strong>Cairo:</strong> El lenguaje de programaciÃ³n central de Starknet, Cairo, se actualiza constantemente y se mejora para brindar a los desarrolladores las mejores herramientas para aprovechar las pruebas de validez y la tecnologÃ­a zk-STARKs.</li>
<li><strong>Enfoque en la comunidad:</strong> Starknet mantiene canales activos de comunicaciÃ³n y retroalimentaciÃ³n con la comunidad de desarrolladores a travÃ©s de plataformas como Telegram y Discord.</li>
<li><strong>Creatividad:</strong> Starknet tiene como objetivo eliminar limitaciones y empoderar a los desarrolladores para construir el futuro de las aplicaciones descentralizadas. Permite crear cosas que nunca antes se pudieron construir debido a las limitaciones de la tecnologÃ­a subyacente.</li>
<li><strong>Herramientas:</strong> Starknet se compromete a proporcionar una amplia gama de herramientas de desarrollo, incluyendo SDKs para diversos lenguajes, un marco de pruebas e implementaciÃ³n inspirado en Foundry (Protostar) y administradores de paquetes (Scarb).</li>
</ul>
<p>En la prÃ³xima secciÃ³n, nos sumergiremos en la arquitectura de Starknet y sus componentes fundamentales para comprender cÃ³mo construir aplicaciones web3 escalables. Te proporcionaremos un conocimiento profundo de los elementos clave de Starknet, lo que te permitirÃ¡ desarrollar e implementar dApps de manera eficiente. Comencemos con una breve descripciÃ³n de los componentes fundamentales que desempeÃ±arÃ¡n un papel crucial en el funcionamiento de la red y asegurarÃ¡n que el ciclo de las transacciones sea escalable, rÃ¡pido y econÃ³mico.</p>
<h2 id="sequencers"><a class="header" href="#sequencers">Sequencers:</a></h2>
<p>Los Secuenciadores (Sequencers) son componentes esenciales de la red Starknet y juegan un papel central al actuar como puntos de entrada para las transacciones. Son comparables a los validadores en Ethereum, y los ZK Rollups tienen la capacidad Ãºnica de delegar ciertas tareas de la red, como la agregaciÃ³n y el procesamiento de transacciones, a entidades especializadas. Sin embargo, este proceso demanda recursos significativos debido a los altos requisitos de capacidad y continuidad.</p>
<p>En el ecosistema de Starknet y otras plataformas con ZK Rollups, se observa un paralelo similar. Estas redes externalizan el procesamiento de transacciones a estas entidades especializadas, denominadas <code>Sequencers</code>, quienes luego verifican su trabajo. La delegaciÃ³n de tareas a los Sequencers es clave para que los ZK Rollups puedan manejar una gran cantidad de transacciones sin poner en riesgo la seguridad de la red subyacente, y asÃ­ los Sequencers desempeÃ±an un papel esencial para lograr una mayor escalabilidad en Ethereum.</p>
<p>A diferencia de los mineros, cuya funciÃ³n es brindar seguridad en otras redes, los Sequencers no aportan seguridad, sino que ofrecen capacidad de transacciÃ³n. Su labor consiste en agrupar mÃºltiples transacciones en un solo batch, procesarlas y generar un bloque. Este bloque serÃ¡ luego verificado por el Verificador, al cual se le proporcionarÃ¡ una zk Proof que garantiza la <strong><code>Validez</code></strong> o <strong><code>Integridad</code></strong> de los datos, conocida como <code>Validity Proof</code>, y mÃ¡s concretamente un <code>STARK</code> especÃ­fico de Starknet. El Prover es el encargado de generar este STARK y se asegura de que todos los datos de las transacciones sean correctos. Posteriormente, el Sequencer enviarÃ¡ todo a la red de Capa 1 como un <code>rollup</code>, una prueba Ãºnica y compacta para que el Verificador compruebe que los datos son correctos y actualice el nuevo estado de la red.</p>
<p>Los Sequencers siguen un mÃ©todo sistemÃ¡tico para el procesamiento de transacciones:</p>
<ol>
<li><strong>AgregaciÃ³n:</strong> Recopilan transacciones de los usuarios.</li>
<li><strong>Procesamiento:</strong> Los Sequencers procesan estas transacciones de acuerdo con las reglas definidas por la red.</li>
<li><strong>AgrupaciÃ³n:</strong> Las transacciones se agrupan en batchs o bloques para mayor eficiencia.</li>
<li><strong>ProducciÃ³n de Bloques:</strong> Los Sequencers producen bloques que contienen lotes de transacciones procesadas.</li>
</ol>
<p>Los Sequencers deben ser confiables y estar altamente disponibles, ya que su funciÃ³n es fundamental para el buen funcionamiento de la red. Necesitan mÃ¡quinas potentes y bien conectadas para desempeÃ±ar su papel de manera efectiva, ya que deben procesar transacciones de manera rÃ¡pida y continua.</p>
<p>La hoja de ruta actual de Starknet incluye la descentralizaciÃ³n del rol de secuenciador. Este cambio hacia la descentralizaciÃ³n permitirÃ¡ que mÃ¡s participantes se conviertan en Sequencers, contribuyendo a la robustez y seguridad de la red.</p>
<h2 id="provers"><a class="header" href="#provers">Provers:</a></h2>
<p>En Starknet, el SHARP (Shared Prover) desempeÃ±a un papel esencial al realizar mÃºltiples tareas, incluida la generaciÃ³n de la Validity Proof. Detallaremos estas diversas funciones en capÃ­tulos posteriores para comprender su importancia. Podemos entender al Prover como un componente que actÃºa en la segunda lÃ­nea de verificaciÃ³n del sistema, y una de sus tareas principales es validar el trabajo de los Sequencers, especialmente cuando estos reciben el bloque producido por el Sequencers. AdemÃ¡s, los Provers tambiÃ©n tienen la responsabilidad de generar pruebas que demuestren que todos estos procesos se llevaron a cabo de manera correcta.</p>
<p>Los Provers necesitan incluso mÃ¡s potencia computacional que los Sequencers, ya que deben calcular y generar pruebas, un proceso que es computacionalmente pesado. Sin embargo, el trabajo de los Provers se puede dividir en varias partes, lo que permite la paralelizaciÃ³n y la generaciÃ³n eficiente de pruebas. El proceso de generaciÃ³n de pruebas es asincrÃ³nico, lo que significa que no es necesario que ocurra de inmediato o en tiempo real. Esta flexibilidad permite distribuir la carga de trabajo entre varios Provers, cada uno trabajando en un bloque diferente, lo que facilita la paralelizaciÃ³n y una generaciÃ³n mÃ¡s eficiente de pruebas.</p>
<p>El diseÃ±o de Starknet se basa en dos tipos de actores: los Sequencers y los Provers, que trabajan en conjunto para garantizar un procesamiento eficiente y una verificaciÃ³n segura de las transacciones.</p>
<p>En cuanto a las funciones de un Prover, podemos destacar:</p>
<ol>
<li><strong>RecepciÃ³n de Bloques:</strong> Los Provers obtienen bloques de transacciones procesadas de los Sequencers.</li>
<li><strong>Procesamiento:</strong> Los Provers vuelven a procesar estos bloques para asegurarse de que todas las transacciones dentro del bloque se hayan manejado correctamente.</li>
<li><strong>GeneraciÃ³n de Pruebas:</strong> DespuÃ©s del procesamiento, los Provers generan una Validity Proof que demuestra el correcto procesamiento de las transacciones.</li>
<li><strong>EnvÃ­o de Prueba a Ethereum:</strong> Finalmente, la Validity Proof se envÃ­a a la red de Ethereum para su validaciÃ³n. Si la Validity Proof es correcta, la red Ethereum acepta el bloque de transacciones.</li>
</ol>
<h2 id="nodos"><a class="header" href="#nodos">Nodos:</a></h2>
<p>Cuando se trata de definir quÃ© hacen los nodos en Bitcoin o Ethereum, a menudo se interpreta errÃ³neamente su papel como mantener un registro de cada transacciÃ³n dentro de la red. Sin embargo, esto no es del todo preciso.</p>
<p>Los nodos actÃºan como auditores de la red, manteniendo el estado de la red, como cuÃ¡nto Bitcoin posee cada participante o el estado actual de un contrato inteligente especÃ­fico. Logran esto procesando transacciones y conservando un registro de todas las transacciones, pero eso es un medio para un fin, no el fin en sÃ­ mismo.</p>
<p>En el caso de Validity Rollup, especÃ­ficamente dentro de Starknet, este concepto se invierte en cierta medida. Los nodos no necesariamente tienen que procesar todas las transacciones para obtener el estado. A diferencia de Ethereum o Bitcoin, los nodos de Starknet no estÃ¡n obligados a procesar cada transacciÃ³n para mantener el estado de la red.</p>
<p>Existen dos formas principales de acceder a los datos del estado de la red:</p>
<ul>
<li>A travÃ©s de una puerta de enlace de API.</li>
<li>Mediante el protocolo RPC para comunicarse con un nodo.</li>
</ul>
<p>Operar su propio nodo suele ser mÃ¡s rÃ¡pido que usar una arquitectura compartida, como la puerta de enlace. A medida que avanza el tiempo, Starknet planea descontinuar las API y reemplazarlas por un estÃ¡ndar JSON RPC, lo que harÃ¡ que operar su propio nodo sea aÃºn mÃ¡s beneficioso.</p>
<p>Vale la pena seÃ±alar que alentar a mÃ¡s personas a ejecutar nodos aumenta la resistencia de la red y evita la sobrecarga del servidor, un problema que ha afectado a otras redes de Capa 2.</p>
<p>Actualmente, existen principalmente tres mÃ©todos principales para que un nodo lleve un registro del estado de la red: </p>
<ol>
<li><strong>ReproducciÃ³n de Transacciones Antiguas:</strong> Al igual que en Ethereum o Bitcoin, un nodo puede tomar todas las transacciones y volver a ejecutarlas. Aunque este enfoque es preciso, no es escalable a menos que se tenga una mÃ¡quina potente capaz de manejar la carga. Si se pueden volver a reproducir todas las transacciones, el nodo puede convertirse en un Sequencer, como puede ser el caso del nuevo enfoque adaptado a Madara con Substrate, actuando como un Sequencer, Full Node o mucho mÃ¡s como veremos en su momento.</li>
<li><strong>Confiar en el Consenso de Capa 2:</strong> Los nodos pueden confiar en que los Secuencer ejecutan la red correctamente. Cuando el Secuencer actualiza el estado y agrega un nuevo bloque, los nodos aceptan la actualizaciÃ³n como precisa.</li>
<li><strong>VerificaciÃ³n de la ValidaciÃ³n de Pruebas en L1:</strong> Los nodos pueden monitorear el estado de la red observando L1 y asegurÃ¡ndose de que cada vez que se envÃ­a una prueba, reciben el estado actualizado. De esta manera, no tienen que confiar en nadie y solo necesitan realizar un seguimiento de la Ãºltima transacciÃ³n vÃ¡lida para Starknet.</li>
</ol>
<p>Podemos encontrarnos una variedad de tipos de nodos, cada uno desempeÃ±ando un papel esencial en el funcionamiento y cada tipo de configuraciÃ³n de nodo presenta sus propios desafÃ­os y oportunidades, ya que vienen acompaÃ±ados de requisitos de hardware y suposiciones de confianza Ãºnicas.</p>
<p>A medida que nos adentramos en este universo descentralizado, es crucial entender cÃ³mo estos nodos interactÃºan y cÃ³mo contribuyen a la eficiencia y seguridad de Starknet. Desde aquellos que reproducen transacciones con potencia de procesamiento masiva, hasta los que confÃ­an en el consenso de Capa 2 con menor carga computacional, y aquellos que verifican la validaciÃ³n de pruebas en L1 con una huella mÃ¡s liviana, cada nodo tiene su lugar y su relevancia en esta red en constante evoluciÃ³n.</p>
<h3 id="nodos-que-reproducen-transacciones"><a class="header" href="#nodos-que-reproducen-transacciones">Nodos que Reproducen Transacciones:</a></h3>
<p>Los nodos que reproducen transacciones requieren mÃ¡quinas potentes para rastrear y ejecutar todas las transacciones. Estos nodos no tienen suposiciones de confianza, Ãºnicamente confÃ­an en las transacciones que ejecutan, garantizando que el estado en cualquier momento sea vÃ¡lido.</p>
<h3 id="nodos-que-confian-en-el-consenso-de-capa-2"><a class="header" href="#nodos-que-confian-en-el-consenso-de-capa-2">Nodos que Confian en el Consenso de Capa 2:</a></h3>
<p>Los nodos que confÃ­an en el consenso de Capa 2 representan una opciÃ³n de menor exigencia en cuanto a potencia computacional. Aunque necesitan un almacenamiento adecuado para mantener el estado, su carga de procesamiento de transacciones es mÃ¡s liviana, dado que se basan en una suposiciÃ³n de confianza. Inicialmente, Starknet estuvo centrado en un solo secuenciador, pero ha evolucionado hacia una red mÃ¡s descentralizada con la incorporaciÃ³n de componentes como Madara y Secuencers de Rust mejorados por Lambda, entre otros, los cuales serÃ¡n detallados en la secciÃ³n de Sequencers.</p>
<p>En este contexto, estos nodos depositan su confianza en que Starkware no interferirÃ¡ con la red. Sin embargo, a medida que se implemente un mecanismo de consenso y selecciÃ³n de lÃ­deres entre los Sequencers, el nivel de confianza se modificarÃ¡. En ese futuro escenario, los nodos solo necesitarÃ¡n confiar en que un Sequencer que ha comprometido su participaciÃ³n para producir un bloque no estarÃ¡ dispuesto a perderla.</p>
<h3 id="nodos-que-verifican-la-validaciÃ³n-de-pruebas-en-l1"><a class="header" href="#nodos-que-verifican-la-validaciÃ³n-de-pruebas-en-l1">Nodos que Verifican la ValidaciÃ³n de Pruebas en L1:</a></h3>
<p>Los nodos que actualizan su estado basÃ¡ndose Ãºnicamente en la validaciÃ³n de pruebas en L1 requieren menos hardware y comparten los mismos requisitos que un nodo de Ethereum. Con la futura existencia de nodos ligeros de Ethereum, mantener un nodo de este tipo podrÃ­a ser tan sencillo como usar un telÃ©fono inteligente. No obstante, existe un compromiso a considerar <code>la latencia</code>. Las pruebas no se envÃ­an a Ethereum en cada bloque de manera constante, sino de forma intermitente, lo que provoca actualizaciones de estado retrasadas.</p>
<p>Para aumentar la frecuencia de las pruebas, incluso si no se envÃ­an a Ethereum de inmediato, se espera que un avance en el futuro permita que estos nodos reduzcan significativamente su latencia. Sin embargo, es importante tener en cuenta que este desarrollo aÃºn estÃ¡ lejos en la hoja de ruta de Starknet</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="componentes"><a class="header" href="#componentes">Componentes</a></h1>
<p>Aprendamos como a medida que te embarcas en el viaje para construir aplicaciones web3 escalables, es esencial comprender la arquitectura de donde estÃ¡s construyendo, en este caso tendrÃ¡s que formarte sobre Starknet y sus diversos componentes. Este capÃ­tulo tiene como objetivo proporcionar una comprensiÃ³n profunda de los elementos clave de construcciÃ³n de Starknet, lo que te permitirÃ¡ desarrollar e implementar aplicaciones descentralizadas (dApps) de manera eficiente.</p>
<p>En este capÃ­tulo, abordaremos temas como:</p>
<ul>
<li>
<p><strong>Nodos L2:</strong> Una visiÃ³n general de alto nivel de los diferentes nodos de Starknet (Secuenciador, Full Nodes, Prover e Indexer) y sus funciones dentro de la red.</p>
</li>
<li>
<p><strong>Ciclo de Vida de Transacciones:</strong> Una explicaciÃ³n detallada de los diferentes estados por los que pasa una transacciÃ³n L2, discutiendo los beneficios y riesgos de considerar un state en particular como <strong>finality</strong>, como se aÃ±adido con la 0.12.0 directamente el <strong>Accepted_On_L2</strong> eliminando el estado <strong>Pending</strong> y como la 0.12.1 empezarÃ¡ a cobrar y aÃ±adir las <strong>tx Rejected</strong> en el bloque, mejorando la eficiencia y seguridad de la red.</p>
</li>
<li>
<p><strong>SHARP:</strong> Veremos el flujo de trabajo del SHARP, un componente en Starknet que actÃºa como un transporte pÃºblico para las pruebas, permitiendo la agregaciÃ³n de mÃºltiples programas Cairo para reducir costos y aumentar la eficiencia.</p>
<p>Utilizando SHARP, se generan pruebas STARK para programas combinados, lo que facilita el envÃ­o de transacciones a una prueba comÃºn. La demostraciÃ³n recursiva de SHARP permite la paralelizaciÃ³n y optimizaciÃ³n, brindando escalabilidad a todas las aplicaciones, y su personalizaciÃ³n.</p>
</li>
<li>
<p><strong>Stack de Starknet:</strong> Permite crear sus propias Appchains personalizadas, lo que les proporciona beneficios como protecciÃ³n contra la congestiÃ³n en la red pÃºblica y la capacidad de implementar caracterÃ­sticas que no son compatibles con la cadena pÃºblica, como su propia lÃ³gica de mercado de tarifas. Lo que permite valiosos experimentos que pueden aplicarse a otras Appchains o a la red pÃºblica.</p>
</li>
<li>
<p><strong>VM de Cairo:</strong> La CVM forma el nÃºcleo del lenguaje Cairo, brindando capacidades avanzadas de ejecuciÃ³n de contratos inteligentes y permitiendo el desarrollo de aplicaciones descentralizadas seguras y eficientes en la cadena de bloques.</p>
</li>
<li>
<p><strong>Storage Proof:</strong> Estas Pruebas de Almacenamiento proporcionan inherentemente una prueba de autenticidad. Las Storage Proof nos permiten validar el state de una cadena de bloques en cualquier momento utilizando compromisos criptogrÃ¡ficos sin asumir la confianza de un tercero.</p>
</li>
<li>
<p><strong>Cairo:</strong> Cairo es un lenguaje para crear programas verificables mediante STARK para cÃ¡lculos generales, este impulsa a Starknet y StarkEx, escalando aplicaciones.</p>
<p>Cairo estÃ¡ inspirado en Rust y permite a los desarrolladores escribir contratos inteligentes para Starknet de manera segura y conveniente.</p>
</li>
</ul>
<p>Al final de esta parte 2 sobre arquitectura de Starknet y Cairo, tendrÃ¡s un conocimiento profundo del funcionamiento y los componentes del ecosistema Starknet, lo que te permitirÃ¡ tomar decisiones informadas al construir formarte sobre toda su infraestructura.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secuenciadores"><a class="header" href="#secuenciadores">Secuenciadores</a></h1>
<p>Los secuenciadores desempeÃ±an un papel crucial en las soluciones blockchain y de Capa 2, ya que son responsables de gestionar el orden y la ejecuciÃ³n de las transacciones. En Starknet, los secuenciadores garantizan que las transacciones se ejecuten en un orden especÃ­fico para prevenir el doble gasto y mantener la consistencia del estado de la red.</p>
<p>Los secuenciadores reciben transacciones, las procesan segÃºn reglas predefinidas y producen una serie de acciones u cambios de estado ordenados. Estas acciones se agrupan en bloques y se incluyen en la cadena de bloques.</p>
<p>Los secuenciadores desempeÃ±an un papel vital en el rendimiento y la seguridad de Starknet al ejecutar transacciones y aplicar cambios de estado segÃºn las reglas y requisitos del protocolo.</p>
<p>El secuenciador de Starknet es especialmente relevante debido al uso de pruebas de conocimiento cero (ZKPs, por sus siglas en inglÃ©s). El correcto funcionamiento del secuenciador garantiza que las transacciones se ejecuten de manera compatible con la generaciÃ³n de ZKPs, lo que contribuye a la escalabilidad y seguridad general de Starknet. Los usuarios interactÃºan con los secuenciadores al enviar transacciones a Starknet, siendo este el primer paso hacia el escalado de STARK. Una vez que un secuenciador ensambla un bloque, el protocolo de consenso lo aprueba y los probadores generan una prueba para la Capa 1 (L1).</p>
<p>En Ethereum, los mineros ordenan y ejecutan las transacciones, mientras que los secuenciadores cumplen un propÃ³sito similar en Starknet. Los secuenciadores procesan las transacciones, las agregan y producen bloques, lo que los convierte en una pieza fundamental de la infraestructura del ecosistema de Starknet.</p>
<p>A medida que Starknet evoluciona, es crucial mejorar el rendimiento de los secuenciadores. AquÃ­ es donde se vuelve fundamental la transiciÃ³n a secuenciadores basados en Rust. Al reescribir los componentes principales del secuenciador en Rust, la red puede lograr un mejor rendimiento, mayor capacidad y mayor resistencia.</p>
<p>Algunos ejemplos de implementaciones de secuenciadores incluyen <a href="https://github.com/lambdaclass/starknet_tendermint_sequencer">Starknet Tendermint Sequencer de LambdaClass</a> y <a href="https://github.com/keep-starknet-strange/madara">Madara</a>, un secuenciador de Starknet impulsado por Rust utilizando Substrate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secuenciadores-basados-en-rust"><a class="header" href="#secuenciadores-basados-en-rust">Secuenciadores Basados en Rust</a></h1>
<p>Originalmente, los secuenciadores se escribieron en Python, que resultÃ³ ineficiente para operaciones a gran escala. A medida que la red alcanzÃ³ su capacidad, los desarrolladores buscaron mejorar el rendimiento del secuenciador. El primer hito fue establecer una cadena de bloques en pleno funcionamiento, seguida de un enfoque en la optimizaciÃ³n del rendimiento.</p>
<p>La mejora inicial del rendimiento implicÃ³ la implementaciÃ³n de una concurrencia optimista para la ejecuciÃ³n de transacciones paralelas. Sin embargo, el avance mÃ¡s significativo provino de la reescritura de secuenciadores en Rust, un lenguaje mÃ¡s eficiente y mÃ¡s rÃ¡pido.</p>
<p>La reescritura de secuenciadores en Rust ha mostrado resultados prometedores en rendimiento y escalabilidad. Se espera que el rendimiento y la latencia de la red Starknet mejoren dramÃ¡ticamente, beneficiando a la red y a aquellos que trabajan con infraestructura relacionada y herramientas de desarrollo.</p>
<p>Uno de los nuevos secuenciadores se basa en Papyrus, un nodo completo Starknet de cÃ³digo abierto responsable de la gestiÃ³n del estado. Los primeros puntos de referencia para proyectos como Madara revelan una notable transacciÃ³n de 76 TPS ( por segundo ) para transferencias ERC20, mostrando las posibles mejoras que los secuenciadores basados en el Ã³xido aportan al ecosistema Starknet.</p>
<p>La implementaciÃ³n de concurrencia optimista tambiÃ©n contribuye a las mejoras en el rendimiento del secuenciador al ejecutar transacciones en paralelo, verificar conflictos en las celdas de almacenamiento tocadas e invalidar transacciones posteriores cuando sea necesario.</p>
<p>A medida que Starknet evoluciona, el desarrollo del secuenciador progresarÃ¡, enfocÃ¡ndose en mejorar las capacidades y garantizar una integraciÃ³n perfecta con la red. Los desarrolladores trabajarÃ¡n en nuevas caracterÃ­sticas, como los mecanismos de tarifas, que se implementarÃ¡n en los prÃ³ximos lanzamientos como Memphis.</p>
<p>La mejora continua y la optimizaciÃ³n de los secuenciadores son vitales para el crecimiento sostenido de Starknet. La transiciÃ³n a secuenciadores basados en Rust y los esfuerzos continuos para mejorar su desempeÃ±o indudablemente contribuirÃ¡n.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="madara---bases-de-su-arquitectura"><a class="header" href="#madara---bases-de-su-arquitectura">Madara - Bases de su arquitectura</a></h1>
<p>Madara es mucho mÃ¡s que un secuenciador, ha sido diseÃ±ado por el equipo de exploraciÃ³n de Starkware, los poderosos <a href="https://github.com/keep-starknet-strange">Keep Starknet Strange</a>. Su enfoque modular, basado en Substrate (SDK) con el poder de Rust, lo convierte en un componente principal para escalar Starknet, ETH y darle al usuario y desarrollador la facilidad de adaptar sus dapps, montando capas 3, 4 o 5 modificables segÃºn su proyecto. PodrÃ¡ utilizar y desplegar una pila de componentes de forma rÃ¡pida y segura gracias a las STARKs y Cairo, usando la Cairo VM y el Blockifier para ejecutar programas o contratos de Cairo en Starknet.</p>
<p>En este capÃ­tulo, exploraremos los cimientos de Madara, definiendo conceptos esenciales que son cruciales para comprender tanto esta arquitectura como otras similares.</p>
<ul>
<li>
<p><strong>Substrate:</strong> Es un Kit de desarrollo de software (SDK) que le permite construir cadenas de bloques especÃ­ficas de la aplicaciÃ³n que pueden ejecutarse como servicios independientes o en paralelo con otras cadenas.</p>
</li>
<li>
<p><strong>Blockifier:</strong> Es una implementaciÃ³n de Rust para el componente de ejecuciÃ³n de transacciones en el secuenciador Starknet, a cargo de crear diferencias de estado <code>state distaff</code> y bloques, su funciÃ³n engloba:</p>
<ul>
<li>Realizar la ejecuciÃ³n de un bloque y generar  un state distaff.</li>
<li>Integrarse con el secuenciador Starknet actual, reemplazando su componente de bloqueo de transacciones, escrito en Python.</li>
<li>Implementar la concurrencia optimista de la ejecuciÃ³n de transacciones.</li>
<li>Ampliar el Blockifier para convertirlo en un secuenciador Starknet completo, escrito en Rust, sustituyendo al actual en uso.</li>
</ul>
</li>
<li>
<p><strong>Pallet:</strong> El nÃºcleo de Madara reside en el starknet pallet, que proporciona una capa de compatibilidad Starknet para Substrate. Esto permite una ejecuciÃ³n fluida del cÃ³digo existente de Cairo. Este pallet no solo incluye un mÃ³dulo RPC, sino que tambiÃ©n posibilita la emulaciÃ³n de bloques Starknet, valida las transacciones codificadas por Starknet y facilita la implementaciÃ³n de una Starknet DApp sin necesidad de modificaciones.</p>
</li>
<li>
<p><strong>Paridad de bloques:</strong> Wrapper Block es una estrategia en Substrate diseÃ±ada para procesar bloques que no fueron originariamente concebidos con Substrate en mente, este enfoque fue pionero por Parity en la capa de compatibilidad EVM para Substrate.</p>
</li>
<li>
<p><strong>Stack de Madara:</strong> El Stack de Madara consta de tres componentes clave: EjecuciÃ³n, Asentamiento y SecuenciaciÃ³n.</p>
<ul>
<li>
<p><strong>EjecuciÃ³n:</strong> Define el procedimiento para la ejecuciÃ³n de bloques y la creaciÃ³n de diferencias de estado. Permite cambiar entre Blockifier (por Starkware) y starknet_in_rust (por LambdaClass) para una mayor optimizaciÃ³n con el tiempo.</p>
</li>
<li>
<p><strong>Settlement:</strong> Permite construir el estado de la cadena Madara solo mirando su capa de asentamiento. No hace suposiciones sobre la capa de asentamiento elegida y permite establecer la finalidad Hard y Soft segÃºn el contexto.</p>
</li>
<li>
<p><strong>Sequencing:</strong> Realizada por Madara, se puede modificar para satisfacer diferentes necesidades. Puede ser un FCFS, PGA simple o esquemas mÃ¡s complejos como Narwhall &amp; Bullshark o HotStuff, que se basa en el protocolo PBFT.</p>
</li>
</ul>
</li>
<li>
<p><strong>Gobernanza:</strong> La gobernanza en Madara se basa principalmente en la SnapShot X, un sistema totalmente en cadena que utiliza Storage Proof. AdemÃ¡s, se estÃ¡n explorando otros mecanismos de gobernanza,  como el pallet nativo de gobernanza en Substrate.</p>
</li>
</ul>
<p>Con estos aspectos clave, hemos buscado fortalecer los fundamentos esenciales de Madara y evitar limitarnos a considerarlo Ãºnicamente como un secuenciador. Su enfoque modular, adaptado a Starknet y centrado en el concepto de escalado fractal, abre las puertas a fusiones de componentes que trascienden las expectativas convencionales. AdemÃ¡s, esta arquitectura posibilita optimizaciones y mejoras mÃ¡s efectivas en diversos desarrollos, como el impresionante Starknet Stack desarrollado por Lambda, que contribuye a la eficiencia global del sistema.</p>
<p>Este enfoque estratÃ©gico de Madara en Substrate no solo nos permite la creaciÃ³n de nuevas cadenas subyacentes, abordando diversas estrategias de almacenamiento de datos y variados protocolos de consenso, incluyendo opciones como Celestia. TambiÃ©n nos brinda la capacidad de implementar una gama diversa de arquitecturas, como la prometedora fusiÃ³n potencial con Kakarot, un zkEVM que interpreta el lenguaje de programaciÃ³n Solidity y lo ejecuta en el entorno Cairo. Esta colaboraciÃ³n inteligente proporciona una mayor flexibilidad y la opciÃ³n de afinarla como un zkEVM de tipo 1. AdemÃ¡s, Madara sienta las bases para el desarrollo de motores de juegos completos al estilo de Unity, como se demuestra claramente con el ejemplo de Dojo en el entorno de Starknet. Estas capacidades no solo permiten una creaciÃ³n Ã¡gil y adaptable a necesidades especÃ­ficas, sino que tambiÃ©n destaca la versatilidad de Madara mÃ¡s allÃ¡ de su papel inicial como secuenciador, tal como mencionamos al principio.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-kraken-sequencer-"><a class="header" href="#starknet-kraken-sequencer-">Starknet Kraken Sequencer ğŸš§</a></h1>
<p>En este capÃ­tulo, exploraremos Kraken, uno de los Secuenciadores que busca optimizar y mejorar el rendimiento. Kraken es una implementaciÃ³n descentralizada de un secuenciador diseÃ±ado por Lambda Class con el propÃ³sito de escalar Starknet. </p>
<blockquote>
<p><strong>Nota:</strong> El cÃ³digo actual de consenso se basa en gran medida en la implementaciÃ³n de <a href="https://github.com/asonnino/hotstuff/">Albert Sonnino's (asonnino) implementation</a>, la cual se centrÃ³ en la investigaciÃ³n en lugar de la aplicaciÃ³n. Las modificaciones fueron realizadas por Lambda Class, principalmente en la estructura del nodo, para permitir el procesamiento de transacciones para bloques confirmados.</p>
</blockquote>
<p>En este anÃ¡lisis detallaremos sus diferentes mÃ³dulos y posibles implementaciones, analizemos como el secuenciador puede dividirse en (aproximadamente) 3 mÃ³dulos intercambiables:</p>
<h2 id="mÃ³dulo-mempool"><a class="header" href="#mÃ³dulo-mempool">MÃ³dulo Mempool</a></h2>
<p>El mÃ³dulo Mempool, conocido como <a href="https://arxiv.org/pdf/2105.11827.pdf"><strong>Narwhal</strong></a>, almacena las transacciones recibidas. Narwhal se especializa en la difusiÃ³n y el almacenamiento de historias causales de transacciones. EstÃ¡ diseÃ±ado para funcionar con alta eficiencia en la difusiÃ³n y almacenamiento de transacciones, tolerando incluso fallas en la red. Narwhal es escalable y puede ser implementado con mÃºltiples trabajadores en cada validador, con un alto rendimiento demostrado. La investigaciÃ³n en Narwhal y Tusk propone la separaciÃ³n de la difusiÃ³n confiable de transacciones de su ordenamiento, habilitando un consenso de alto rendimiento y tolerancia a fallas bizantinas. La combinaciÃ³n de Narwhal con un protocolo de consenso parcialmente sincrÃ³nico (Narwhal-HotStuff) mejora significativamente el rendimiento, manteniendo alta tolerancia a fallos.</p>
<p>SegÃºn los datos del Whitepaper, Narwhal-Hotstuff logra mÃ¡s de <code>130,000 tx/sec</code> con una latencia inferior a 2 segundos en una WAN, en comparaciÃ³n con <code>1,800 tx/sec</code> a 1 segundo de latencia para Hotstuff. La adiciÃ³n de trabajadores aumenta linealmente el rendimiento a <code>600,000 tx/sec</code> sin aumento de latencia. AdemÃ¡s, el protocolo Tusk ha sido diseÃ±ado para trabajar con Narwhal y lograr un rendimiento Ã³ptimo incluso bajo condiciones de fallo.</p>
<h2 id="mÃ³dulo-de-consenso"><a class="header" href="#mÃ³dulo-de-consenso">MÃ³dulo de Consenso</a></h2>
<p>En el funcionamiento del secuenciador Kraken, el mÃ³dulo de consenso desempeÃ±a un papel fundamental al ofrecer diversas alternativas para lograr acuerdos en el estado compartido. Estas opciones abarcan desde enfoques simples hasta esquemas mÃ¡s complejos, como el <strong>FCFS (First-Come, First-Served)</strong>, que organiza tareas segÃºn su recepciÃ³n, <strong>PGA (Practical Byzantine Fault Tolerance)</strong>, un algoritmo que busca acuerdos en sistemas distribuidos a pesar de fallos o nodos maliciosos, y tambiÃ©n esquemas mÃ¡s sofisticados como <strong>Bullshark</strong>, <strong>Tendermint</strong> y <strong>Hotstuff</strong>.</p>
<ul>
<li>
<p><a href="https://arxiv.org/pdf/1803.05069.pdf"><strong>HotStuff:</strong></a> es un protocolo de consenso basado en el algoritmo PBFT que destaca por su enfoque en la optimizaciÃ³n de la latencia y el rendimiento. Su diseÃ±o permite la replicaciÃ³n de estado a alta velocidad en sistemas distribuidos. Introduciendo un enfoque basado en tolerancia a fallos bizantinos, HotStuff capacita a un lÃ­der confiable para guiar el protocolo hacia el consenso en lÃ­nea con el retraso real de la red, en contraposiciÃ³n al retraso mÃ¡ximo, obteniendo una propiedad denominada capacidad de respuesta. Este logro se complementa con una complejidad de comunicaciÃ³n lineal en funciÃ³n del nÃºmero de rÃ©plicas involucradas. En la esencia de su estructura, HotStuff supera el desafÃ­o de la replicaciÃ³n de la mÃ¡quina de estado (SMR), logrando aplicar comandos de manera secuencial y coherente. En el nÃºcleo de SMR reside un protocolo que rige la determinaciÃ³n de un registro en crecimiento de solicitudes de comandos procedentes de los clientes. De manera conjunta, un grupo de rÃ©plicas de la mÃ¡quina de estado lleva a cabo la ejecuciÃ³n de estos comandos en orden secuencial y coherente. Si bien gran parte de la discusiÃ³n excluye al cliente, la literatura estÃ¡ndar aborda aspectos relativos a la numeraciÃ³n y deduplicaciÃ³n de solicitudes de clientes.</p>
</li>
<li>
<p><a href="https://arxiv.org/pdf/2201.05677.pdf"><strong>Bullshark:</strong></a> BullShark es un protocolo de difusiÃ³n atÃ³mica asincrÃ³nica basado en grÃ¡ficos acÃ­clicos dirigidos (DAG) que estÃ¡ optimizado para el caso sincrÃ³nico comÃºn. A diferencia de otros protocolos asincrÃ³nicos basados en DAG, BullShark proporciona una ruta rÃ¡pida de baja latencia que explota perÃ­odos sincrÃ³nicos y elimina la necesidad de mecanismos de cambio de vista y sincronizaciÃ³n de vista notoriamente complejos. BullShark logra esto manteniendo todas las propiedades deseables de su predecesor DAG-Rider, incluyendo una complejidad de comunicaciÃ³n amortizada Ã³ptima, equidad y vida asincrÃ³nica, y garantizando la seguridad incluso ante un adversario cuÃ¡ntico.</p>
</li>
</ul>
<p>Mediante esta gama de opciones de consenso, Kraken se adapta con flexibilidad a diversos escenarios y requerimientos.</p>
<h2 id="mÃ³dulo-de-ejecuciÃ³n"><a class="header" href="#mÃ³dulo-de-ejecuciÃ³n">MÃ³dulo de EjecuciÃ³n</a></h2>
<p>Ahora enfoquÃ©monos en el motor de ejecuciÃ³n, el componente esencial encargado de procesar las transacciones en la mÃ¡quina de estado. En Starknet, el sistema operativo estÃ¡ implementado en Rust, y la ejecuciÃ³n puede llevarse a cabo mediante <a href="https://github.com/lambdaclass/cairo_native">Cairo Native</a> (un compilador que transforma el cÃ³digo de representaciÃ³n intermedia &quot;Sierra&quot; de Cairo en cÃ³digo de mÃ¡quina a travÃ©s de MLIR y LLVM) o <a href="https://github.com/lambdaclass/cairo-vm">Cairo-rs</a> (una implementaciÃ³n mÃ¡s rÃ¡pida y segura de la mÃ¡quina virtual de Cairo en Rust). Esta adaptabilidad a travÃ©s de mÃºltiples opciones garantiza una operaciÃ³n eficiente y segura en el procesamiento de las transacciones.</p>
<h3 id="mÃ³dulos-intercambiables"><a class="header" href="#mÃ³dulos-intercambiables">MÃ³dulos Intercambiables</a></h3>
<p>Una caracterÃ­stica clave de Kraken es su capacidad de intercambiar mÃ³dulos. Esto implica que la implementaciÃ³n subyacente en la comunicaciÃ³n del Mempool, el protocolo de Consenso o el Motor de EjecuciÃ³n puede personalizarse y adaptarse segÃºn las necesidades especÃ­ficas de la red.</p>
<p>AdemÃ¡s, para mantener y persistir el estado, Kraken utiliza un mÃ³dulo de Estado que implementa <a href="https://github.com/photondb/photondb">PhotonDB</a> en una primera iteraciÃ³n. PhotonDB, un motor de almacenamiento de alto rendimiento diseÃ±ado para hardware y plataformas modernas, asegura una gestiÃ³n adecuada y segura de los datos en el entorno descentralizado de Kraken.</p>
<p>En resumen, Kraken emerge como un poderoso secuenciador descentralizado diseÃ±ado por Lambda Class para abordar los desafÃ­os de escalabilidad en Starknet. A travÃ©s de su enfoque en mÃ³dulos intercambiables, Kraken ofrece flexibilidad y personalizaciÃ³n, permitiendo adaptar su funcionamiento a diferentes necesidades y contextos. AdemÃ¡s, su incorporaciÃ³n de tecnologÃ­as avanzadas como Narwhal, HotStuff, Bullshark o PhotonDB que contribuyen a mantener la coherencia y seguridad del estado en la red distribuida. </p>
<p>En Ãºltima instancia, el secuenciador Kraken no solo demuestra su capacidad para procesar transacciones eficientemente, sino que tambiÃ©n juega un papel esencial en la bÃºsqueda continua de la descentralizaciÃ³n en el Starknet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="full-nodes---starknet-stack"><a class="header" href="#full-nodes---starknet-stack">Full Nodes - Starknet Stack</a></h1>
<p>En el contexto de Ethereum y blockchain, un nodo es una parte integral de la red que valida y retransmite transacciones. Los nodos descargan una copia de toda la cadena de bloques y estÃ¡n interconectados con otros nodos para mantener y actualizar el estado de la cadena de bloques. Hay diferentes tipos de nodos, como nodos completos, nodos ligeros y nodos de minerÃ­a, cada uno con roles y responsabilidades diferentes dentro de la red.</p>
<h2 id="starknet-stack"><a class="header" href="#starknet-stack">Starknet Stack</a></h2>
<p>La red de nodos de Starknet estÃ¡ compuesta por nodos que sincronizan y procesan transacciones, contribuyendo a la seguridad y descentralizaciÃ³n general de la red.</p>
<p>La pila de Starknet se puede dividir en varias capas, al igual que los modelos OSI o TCP/IP. El modelo mÃ¡s apropiado depende de tu comprensiÃ³n y requisitos. Una versiÃ³n simplificada de la pila modular de blockchain podrÃ­a verse asÃ­:</p>
<ul>
<li><strong>Capa 1 - Capa de Datos:</strong> La Capa 1 en la pila de Starknet es la Capa de Datos, que se refiere a la cadena de bloques subyacente en Ethereum. Esta capa proporciona la seguridad y la integridad de los datos subyacentes a Starknet. AquÃ­ es donde se almacenan los contratos inteligentes y se realizan las transacciones en Ethereum.</li>
<li><strong>Capa 2 - Capa de EjecuciÃ³n:</strong> La Capa 2 en la pila de Starknet es la Capa de EjecuciÃ³n. AquÃ­ es donde se lleva a cabo la ejecuciÃ³n de los contratos inteligentes utilizando el entorno de ejecuciÃ³n de Cairo. Cairo es un lenguaje de programaciÃ³n especÃ­fico de Starknet que facilita la escritura y ejecuciÃ³n de contratos inteligentes complejos. En esta capa, se procesan las transacciones y se realizan las operaciones computacionales necesarias para ejecutar los contratos inteligentes.</li>
<li><strong>Capa 3 - Capa de AplicaciÃ³n:</strong> La Capa 3 en la pila de Starknet es la Capa de AplicaciÃ³n. AquÃ­ es donde se desarrollan y despliegan las aplicaciones descentralizadas (dApps) en Starknet. Las dApps pueden incluir una amplia gama de aplicaciones, como juegos, finanzas descentralizadas, intercambios descentralizados y mÃ¡s. Esta capa permite a los desarrolladores aprovechar la escalabilidad y las capacidades de ejecuciÃ³n de Starknet para construir aplicaciones mÃ¡s rÃ¡pidas y eficientes.</li>
<li><strong>Capa 4 - Capa de Transporte:</strong> La Capa 4 en la pila de Starknet es la Capa de Transporte. Esta capa se encarga de la comunicaciÃ³n y el transporte de datos entre los diferentes nodos de Starknet. Proporciona la infraestructura necesaria para que los nodos se sincronicen y compartan informaciÃ³n, lo que contribuye a la seguridad y descentralizaciÃ³n general de la red.</li>
</ul>
<p>Estas son las cuatro capas principales en la pila de Starknet. Cada capa desempeÃ±a un papel crucial en el funcionamiento y la escalabilidad de Starknet, permitiendo a los desarrolladores aprovechar las capacidades de Capa 2 para construir aplicaciones mÃ¡s rÃ¡pidas y eficientes en Ethereum.</p>
<p>En cuanto a por quÃ© el cÃ³mputo verificable constituye un movimiento tecnolÃ³gico con un impacto amplio, creemos en tres cualidades esenciales: inmutable, inalterable, componibilidad.</p>
<ul>
<li><strong>Nivel 8 - Interfaces de usuario:</strong> Las interfaces de usuario parecen fuera de lugar en la pila de cÃ³mputo verificable a primera vista. La clave aquÃ­ es reconocer la ventaja poco explorada de ejecutar la generaciÃ³n de pruebas en el lado del cliente.</li>
<li><strong>Nivel 7 - Hiperestructura y aplicaciones:</strong> AquÃ­ es donde participarÃ¡n directamente las prÃ³ximas olas de desarrolladores y creadores. Para una definiciÃ³n, consulta las <a href="https://jacob.energy/hyperstructures.html">Hiperestructuras</a>.</li>
<li><strong>Nivel 6 - Bibliotecas de bajo nivel:</strong> AquÃ­ es donde se encuentran bibliotecas como numpy, scipy, onnx. Por ejemplo, consulta <a href="https://twitter.com/gizatechxyz">Giza</a>.</li>
<li><strong>Nivel 5 - Lenguaje de programaciÃ³n y compilador:</strong> AquÃ­ es donde los programas / intenciones de diseÃ±o escritos en notaciones accesibles y ergonÃ³micas en los niveles 5-7 se transforman en objetos estandarizados (por ejemplo, con respecto a algunas arquitecturas de conjuntos de instrucciones) que son susceptibles a aritmetizaciÃ³n. Por ejemplo, consulta <a href="https://eprint.iacr.org/2021/1063.pdf">Cairo</a> y <a href="https://github.com/risc0/risc0">Risc0</a>.</li>
<li><strong>Nivel 4 - AritmÃ©tica y arquitectura:</strong> AquÃ­ es donde los objetos estandarizados del nivel 5 se transforman en restricciones polinomiales. Por ejemplo, consulta <a href="https://eprint.iacr.org/2021/582.pdf">ethSTARK</a>.</li>
<li><strong>Nivel 3 - GeneraciÃ³n y verificaciÃ³n de pruebas:</strong> AquÃ­ es donde las restricciones polinomiales se transforman en pruebas (sucintas, de conocimiento cero) que pueden ser verificadas (de manera eficiente y recursiva), donde los calificadores entre parÃ©ntesis son mÃ©tricas a las que se aspira. Por ejemplo, consulta <a href="https://arxiv.org/pdf/1903.12243.pdf">DEEP-FRI</a> y <a href="https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf">KZG</a>.</li>
<li><strong>Nivel 2 - Sistema distribuido:</strong> AquÃ­ es donde pertenece el diseÃ±o de la arquitectura del sistema de blockchain o rollup. Por ejemplo, consulta <a href="https://community.starknet.io/t/starknet-decentralization-tendermint-based-suggestion/998">DescentralizaciÃ³n de Starknet</a>.</li>
<li><strong>Nivel 1 - AceleraciÃ³n de hardware:</strong> Autoexplicativo. Por ejemplo, consulta <a href="https://www.ingonyama.com/">Ingonyama</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pathfinder"><a class="header" href="#pathfinder">Pathfinder</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="juno"><a class="header" href="#juno">Juno</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deoxys"><a class="header" href="#deoxys">Deoxys</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="papyrus"><a class="header" href="#papyrus">Papyrus</a></h1>
<p>Papyrus es una implementaciÃ³n en Rust de un nodo completo de Starknet. ProporcionarÃ¡ las bases para el nuevo Sequencer de Starknet, que mejorarÃ¡ drÃ¡sticamente el rendimiento de Starknet. Papyrus ayudarÃ¡ a mejorar el rendimiento y la descentralizaciÃ³n de Starknet, que son las principales prioridades de desarrollo.</p>
<p>El nodo completo de Papyrus realizarÃ¡ un seguimiento del estado de Starknet a medida que evoluciona con el tiempo y permitirÃ¡ a los usuarios y desarrolladores consultar este estado a travÃ©s de Starknet's JSON-RPC.</p>
<p>Papyrus proporcionarÃ¡ al Sequencer de Starknet una capa de almacenamiento eficiente, lo que mejorarÃ¡ el rendimiento. Esto significa que el secuenciador mantendrÃ¡ una base de datos local en lugar de una base de datos en la nube, y tambiÃ©n almacenarÃ¡ un almacenamiento plano de clave/valor, lo que interactuarÃ¡ directamente con el estado.</p>
<p>Papyrus se une a otros nodos completos de Starknet, Pathfinder y Juno, para fortalecer la descentralizaciÃ³n y redundancia. Al ser de cÃ³digo abierto, Papyrus contribuye a la variedad de implementaciones de clientes, lo que es crucial para una red descentralizada.</p>
<p>Actualmente, Papyrus permite sincronizarse con el estado de Starknet y acceder a toda su historia. Aunque el soporte JSON-RPC estÃ¡ parcialmente implementado, el equipo de Papyrus trabajarÃ¡ para alcanzar la compatibilidad completa y contribuirÃ¡ a formar la base de la capa P2P de Starknet, lo que permitirÃ¡ una mayor descentralizaciÃ³n. El objetivo final es que diferentes nodos puedan comunicarse y sincronizarse a travÃ©s de esta capa P2P, mejorando significativamente los tiempos de sincronizaciÃ³n.</p>
<p>En resumen, Papyrus es el tercer nodo completo en unirse al ecosistema de Starknet. Es de cÃ³digo abierto bajo la licencia Apache 2.0 y serÃ¡ una parte crucial de la infraestructura de Starknet descentralizado.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sharp"><a class="header" href="#sharp">SHARP</a></h1>
<p>SHARP (SHARed Prover) opera como el transporte pÃºblico para las pruebas en Starknet, permitiendo la agregaciÃ³n de mÃºltiples programas Cairo con el fin de reducir costos y aumentar la eficiencia. Mediante SHARP, se generan pruebas STARK para los programas de Cairo combinados, lo que facilita que cualquier aplicaciÃ³n pueda enviar transacciones a la misma prueba. AdemÃ¡s, SHARP emplea pruebas recursivas que permiten la paralelizaciÃ³n y optimizaciÃ³n, lo que lo convierte en una opciÃ³n mÃ¡s accesible para todos los usuarios.</p>
<blockquote>
<p>Imagina que SHARP funciona como un servicio de reparto tipo StarknetUber para las Pruebas STARK. Es como cuando un grupo de amigos se reÃºne y cada uno realiza compras en diferentes tiendas, pero todos comparten el mismo servicio de entrega para recibir sus pedidos y compartir el gasto. </p>
</blockquote>
<p>De manera similar, SHARP permite que mÃºltiples programas Cairo se unan y compartan el mismo proceso de generaciÃ³n de pruebas STARK. Cada programa puede ser como una compra individual en diferentes tiendas, pero al utilizar el servicio de reparto compartido de SHARP, los costos de generaciÃ³n de la prueba se distribuyen entre todos los programas. Esta dinÃ¡mica de &quot;reparto de entregas&quot; garantiza que incluso las aplicaciones mÃ¡s pequeÃ±as puedan acceder al enorme poder de escalabilidad que ofrece STARK. Si un programa estÃ¡ escrito en Cairo, SHARP puede demostrarlo, sin importar quÃ© tan diversas sean las aplicaciones (dApps) que lo utilizan</p>
<ul>
<li>El procesamiento de SHARP agrupa aproximadamente 220,000 transacciones en una sola prueba en la red Ethereum Mainnet. </li>
<li>La demostraciÃ³n recursiva con SHARP permite el procesamiento y la verificaciÃ³n paralela de mÃºltiples pruebas STARK, mejorando la escalabilidad y la eficiencia. </li>
<li>La personalizaciÃ³n de SHARP, <code>Dynamic Layouts</code>, promete una reducciÃ³n adicional de hasta un 30% en las tarifas de gas.</li>
</ul>
<p>Veamos una analogÃ­a para ilustrar cÃ³mo funciona SHARP, segÃºn un documento oficial de StarkWare:</p>
<blockquote>
<p>Imagina que tÃº y tu hermana estÃ¡n comprando regalos para tus padres: un nuevo telÃ©fono, una taza y una camiseta. Cada regalo se ordena en lÃ­nea a un minorista diferente y se entregarÃ¡ en sus respectivos hogares en diferentes fechas, variando en tamaÃ±o y embalaje. Su plan es envolver cada artÃ­culo y enviarlos a sus padres por correo.</p>
</blockquote>
<blockquote>
<p>Sin embargo, hay un problema en la oficina de correos. Las cajas pequeÃ±as y medianas no estÃ¡n disponibles, solo hay cajas grandes de tamaÃ±o Ãºnico. Esto presenta dos opciones:</p>
</blockquote>
<ul>
<li>
<p><strong>OpciÃ³n 1:</strong> Empacar y enviar cada artÃ­culo por separado en su propia caja grande tan pronto como llegue. Si bien esto puede acelerar el envÃ­o de regalos individuales, requiere el esfuerzo adicional de empacar tres cajas separadas y hacer tres viajes a la oficina de correos para enviar tres paquetes diferentes. Como resultado, este mÃ©todo no resulta eficiente en tÃ©rminos de tiempo ni econÃ³mico.</p>
</li>
<li>
<p><strong>OpciÃ³n 2:</strong> Empacar y enviar todos los artÃ­culos juntos en una sola caja grande. Esto significa que solo manejarÃ¡n una caja en lugar de tres.</p>
</li>
</ul>
<blockquote>
<p>En este ejemplo, SHARP es la OpciÃ³n 2, lo que permite el uso eficiente de los recursos y una gestiÃ³n del tiempo mÃ¡s fluida.</p>
</blockquote>
<p>SHARP es un sistema potente que estÃ¡ diseÃ±ado para generar pruebas STARK para programas de Cairo agrupados. Cairo, un lenguaje de programaciÃ³n de computaciÃ³n general, permite la acomodaciÃ³n de diversas lÃ³gicas de cÃ³digo en una sola prueba. El objetivo principal de SHARP es mejorar la escalabilidad y la eficiencia dentro de la red de Starknet, aquÃ­ tenemos algunas de sus propiedades y caractrerÃ­sticas:</p>
<p><strong>AmortizaciÃ³n Exponencial y Eficiencia en Costos:</strong> </p>
<p>Una de las caracterÃ­sticas clave de SHARP es su capacidad para reducir costos y mejorar la eficiencia en la generaciÃ³n de pruebas STARK. Al agrupar mÃºltiples trabajos de Cairo (conjuntos individuales de cÃ¡lculos), SHARP aprovecha la amortizaciÃ³n exponencial que ofrecen las pruebas STARK. Esto significa que a medida que aumenta la carga computacional de las pruebas, el costo de verificarlas aumenta a una tasa logarÃ­tmica mÃ¡s lenta que el crecimiento de la computaciÃ³n en sÃ­. Como resultado, el costo de cada transacciÃ³n dentro del conjunto agregado se reduce significativamente, lo que lo hace mÃ¡s rentable y accesible para los usuarios.</p>
<p><strong>Procesamiento Paralelo y Pruebas Recursivas:</strong> </p>
<p>SHARP utiliza el procesamiento paralelo de declaraciones entrantes, lo que permite sortear las barreras de escalabilidad anteriores que requerÃ­an que las declaraciones combinadas se demostraran solo despuÃ©s de recibir todas las declaraciones individuales. Con la implementaciÃ³n de pruebas recursivas, SHARP demuestra cada declaraciÃ³n a medida que llega, en lugar de esperar a completar un conjunto de declaraciones para comenzar el proceso de demostraciÃ³n. Esto agiliza el proceso de verificaciÃ³n y mejora la eficiencia en comparaciÃ³n con el cÃ¡lculo en sÃ­.</p>
<p>Con la implementaciÃ³n de la recursiÃ³n, SHARP demuestra las declaraciones entrantes de inmediato. A partir de ahÃ­, estas pruebas pueden demostrarse repetidamente y fusionarse en pruebas recursivas. Este proceso de demostraciÃ³n recursiva se implementa hasta que, finalmente, la prueba final se envÃ­a a un contrato verificador de Solidity en cadena. </p>
<p><strong>ValidaciÃ³n y Solidity Verifier:</strong> </p>
<p>Las pruebas STARK generadas por SHARP se validan mediante un contrato verificador de Solidity en Ethereum. Antes de enviar las pruebas al verificador de Solidity, se envÃ­an inicialmente a un programa Verificador STARK escrito en Cairo. Este programa Verificador STARK genera una nueva prueba que confirma la validez de las pruebas iniciales, permitiendo la generaciÃ³n de mÃºltiples pruebas hasta llegar al Verificador de Solidity en Ethereum.</p>
<p><strong>Acceso a la Escalabilidad de STARK para Todos:</strong> </p>
<p>SHARP permite que incluso las aplicaciones mÃ¡s pequeÃ±as accedan al enorme poder de escalabilidad que ofrece STARK. Si un programa estÃ¡ escrito en Cairo, SHARP puede demostrarlo, sin importar quÃ© tan diversas sean las aplicaciones (dApps) que lo utilizan.</p>
<p>Con SHARP, los desarrolladores tienen una soluciÃ³n efectiva para mejorar la escalabilidad y reducir los costos de transacciÃ³n en la red de Starknet. La capacidad de procesar mÃºltiples programas Cairo en una sola prueba STARK es un avance significativo que abre nuevas posibilidades para la adopciÃ³n masiva de la tecnologÃ­a de escalabilidad STARK.</p>
<p><strong>Dynamic Layouts:</strong> </p>
<p>El equipo detrÃ¡s de SHARP estÃ¡ desarrollando actualmente Dynamic Layouts como la prÃ³xima personalizaciÃ³n de sus servicios. Con Dynamic Layouts, el probador calcularÃ¡ los recursos necesarios para cada lÃ³gica especÃ­fica y generarÃ¡ una prueba a medida en consecuencia.</p>
<p>Haciendo un paralelismo con nuestra analogÃ­a anterior, Dynamic Layouts se puede asemejar a la idea de cajas de envÃ­o personalizadas. Estas cajas personalizadas acomodan perfectamente la forma de cada regalo, asegurÃ¡ndose de que solo pagues por el tamaÃ±o exacto necesario, evitando tarifas innecesarias. De manera similar, con Dynamic Layouts, crearÃ¡n una prueba adaptada para cada lÃ³gica y los recursos de computaciÃ³n Ãºnicos que requiere, asegurÃ¡ndose de que solo pagues por la computaciÃ³n que uses. Si estÃ¡ en Cairo, SHARP puede demostrarlo con precisiÃ³n.</p>
<p>Al aprovechar el poder de la generaciÃ³n de pruebas recursivas basadas en STARK, SHARP se convierte en una tecnologÃ­a que impulsa enormemente la escalabilidad y eficiencia de la red Ethereum. En el prÃ³ximo capÃ­tulo, nos centraremos en analizar mÃ¡s a fondo su arquitectura y componentes, asÃ­ como su funcionamiento, en especial la recursividad.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursividad---sharp"><a class="header" href="#recursividad---sharp">Recursividad - SHARP</a></h1>
<p>Una de las caracterÃ­sticas mÃ¡s poderosas de SHARP es su uso de pruebas recursivas. En lugar de enviar directamente las pruebas generadas al Verificador de Solidity, primero se envÃ­an a un programa Verificador STARK escrito en Cairo. Este Verificador, que tambiÃ©n es un Programa Cairo, recibe la prueba y crea un nuevo trabajo de Cairo que se envÃ­a al Proveedor. El Proveedor luego genera una nueva prueba para confirmar que las pruebas iniciales fueron verificadas. Estas nuevas pruebas se pueden enviar de vuelta a SHARP y al Verificador STARK, reiniciando el proceso.</p>
<p>Este proceso continÃºa de forma recursiva, enviando cada nueva prueba al Verificador de Cairo hasta que se alcanza un disparador. En este punto, la Ãºltima prueba de la serie se envÃ­a al Verificador de Solidity en Ethereum. Este enfoque permite una mayor paralelizaciÃ³n de la computaciÃ³n y reduce el tiempo y los costos asociados con la generaciÃ³n y verificaciÃ³n de pruebas.</p>
<p>A primera vista, las pruebas recursivas pueden parecer mÃ¡s complejas y consumir mÃ¡s tiempo. Sin embargo, hay varios beneficios en este enfoque:</p>
<ul>
<li><strong>ParalelizaciÃ³n:</strong> Las pruebas recursivas permiten la paralelizaciÃ³n del trabajo, reduciendo la latencia del usuario y mejorando la eficiencia de SHARP.</li>
<li><strong>Menores costos en la cadena:</strong> La paralelizaciÃ³n permite que SHARP cree pruebas mÃ¡s grandes, que anteriormente se limitarÃ­an por la disponibilidad de mÃ¡quinas en la nube grandes (que son escasas y limitadas). Como resultado, los costos en la cadena se reducen.</li>
<li><strong>Menores costos en la nube:</strong> Dado que cada trabajo es mÃ¡s corto, se reduce la memoria requerida para el procesamiento, lo que resulta en menores costos en la nube.</li>
<li><strong>OptimizaciÃ³n:</strong> Las pruebas recursivas permiten que SHARP se optimice para varios factores, incluyendo la latencia, los costos en la cadena y el tiempo de prueba.</li>
<li><strong>Compatibilidad con Cairo:</strong> Las pruebas recursivas solo requieren soporte en Cairo, sin necesidad de agregar soporte en el Verificador de Solidity.</li>
</ul>
<p>La latencia en Starknet abarca el tiempo que lleva procesar, confirmar e incluir transacciones en un bloque. EstÃ¡ afectada por factores como la congestiÃ³n de la red, las tarifas de transacciÃ³n y la eficiencia del sistema. Minimizar la latencia garantiza un procesamiento de transacciones mÃ¡s rÃ¡pido y una retroalimentaciÃ³n del usuario mÃ¡s rÃ¡pida.</p>
<p>El tiempo de prueba, por otro lado, se refiere especÃ­ficamente a la duraciÃ³n requerida para generar y verificar pruebas criptogrÃ¡ficas para transacciones u operaciones.</p>
<p>Desde SHARP 4.0 se agregaron dos nuevos componentes importantes: keccack y PoseidÃ³n.</p>
<p>Keccack es importante para las aplicaciones y Poseidon tambiÃ©n se usa en el propio estado de Starknet (para el nuevo cÃ¡lculo de hash de clases de Cairo 1 y para el nuevo estado de clases).</p>
<p>La arquitectura del backend de SHARP consiste en varios servicios que trabajan en conjunto para procesar trabajos de Cairo y generar pruebas. Estos servicios incluyen:</p>
<ul>
<li><strong>Gateway:</strong> Los trabajos de Cairo ingresan a SHARP a travÃ©s del gateway.</li>
<li><strong>Job Creator:</strong> Evita la duplicaciÃ³n de trabajos y garantiza que el sistema funcione de manera consistente, independientemente de las solicitudes mÃºltiples idÃ©nticas.</li>
<li><strong>Validator:</strong> Este es el primer paso importante. El servicio de validaciÃ³n realiza verificaciones en cada trabajo para asegurarse de que cumplan con los requisitos y puedan adaptarse a las mÃ¡quinas probadoras. Los trabajos invÃ¡lidos se etiquetan como tales y no continÃºan hacia el Prover.</li>
<li><strong>Scheduler:</strong> El servicio de planificaciÃ³n crea &quot;trains&quot; que agregan trabajos y los envÃ­an al Prover. Los trabajos recursivos se emparejan y se envÃ­an juntos al Prover.</li>
<li><strong>Cairo Runner:</strong> Este servicio ejecuta Cairo para las necesidades del Prover. El servicio Cairo Runner ejecuta programas de Cairo, realizando los cÃ¡lculos necesarios y generando el rastro de ejecuciÃ³n como resultado intermedio. El Prover luego utiliza este rastro de ejecuciÃ³n.</li>
<li><strong>Prover:</strong> El Prover calcula las pruebas para cada trains (que contiene varios trabajos).</li>
<li><strong>Dispatcher:</strong> El Dispatcher cumple dos funciones en el sistema SHARP.
<ul>
<li>
<p>En el caso de una prueba recursiva, el Dispatcher ejecuta el programa Cairo Verifier en la prueba que ha recibido del Prover, lo que resulta en un nuevo trabajo de Cairo que vuelve al Validador.</p>
</li>
<li>
<p>En el caso de una prueba que debe ir a la cadena (por ejemplo, a Ethereum), el Dispatcher crea &quot;paquetes&quot; a partir de la prueba, que luego se pueden enviar al Escritor de la Cadena de Bloques.</p>
</li>
</ul>
</li>
<li><strong>Blockchain Writer:</strong> Una vez que el Dispatcher ha creado los paquetes, los envÃ­a al Escritor de la Cadena de Bloques. El Escritor de la Cadena de Bloques se encarga de enviar los paquetes a la cadena de bloques correspondiente (por ejemplo, Ethereum) para su verificaciÃ³n. Este es un paso importante en el sistema SHARP, ya que garantiza que las pruebas se verifiquen correctamente y que las transacciones se registren de forma segura en la cadena de bloques.</li>
<li><strong>Catcher:</strong> El Catcher monitorea las transacciones de la cadena de bloques (por ejemplo, Ethereum) para asegurarse de que hayan sido aceptadas. Si bien el Catcher es relevante para fines de monitoreo interno, es importante tener en cuenta que si una transacciÃ³n falla, el hecho no se registrarÃ¡ en el registro de hechos de la cadena. Como resultado, la integridad del sistema se mantiene incluso sin el Catcher.</li>
</ul>
<p>SHARP estÃ¡ diseÃ±ado para ser sin estado (cada trabajo de Cairo se ejecuta en su propio contexto y no depende de otros trabajos), lo que permite una mayor flexibilidad en el procesamiento de trabajos.</p>
<p>Actualmente, los principales usuarios de SHARP incluyen:</p>
<ul>
<li>StarkEx</li>
<li>Starknet</li>
<li>Usuarios externos que utilizan el Cairo Playground</li>
</ul>
<p>Optimizar el Proveedor implica numerosos desafÃ­os y proyectos potenciales en los que el equipo de Starkware y la comunidad estÃ¡n trabajando actualmente:</p>
<ul>
<li><strong>ExploraciÃ³n de funciones hash mÃ¡s eficientes:</strong> SHARP estÃ¡ constantemente explorando funciones hash mÃ¡s eficientes para Cairo, el Proveedor y Solidity.</li>
<li><strong>InvestigaciÃ³n de campos mÃ¡s pequeÃ±os:</strong> La investigaciÃ³n de campos mÃ¡s pequeÃ±os para los pasos de prueba recursiva podrÃ­a conducir a cÃ¡lculos mÃ¡s eficientes.</li>
<li><strong>Ajuste de varios parÃ¡metros:</strong> SHARP estÃ¡ ajustando constantemente varios parÃ¡metros del protocolo STARK, como los parÃ¡metros FRI y los factores de bloque.</li>
<li><strong>OptimizaciÃ³n del cÃ³digo de Cairo:</strong> SHARP estÃ¡ optimizando el cÃ³digo de Cairo para hacerlo mÃ¡s rÃ¡pido, lo que resulta en un Proveedor recursivo mÃ¡s rÃ¡pido.</li>
<li><strong>Desarrollo de diseÃ±os dinÃ¡micos:</strong> Esto permitirÃ¡ a los programas de Cairo adaptar los recursos segÃºn sus necesidades.</li>
</ul>
<p>Mejora del algoritmo de programaciÃ³n: Este es otro camino de optimizaciÃ³n que se puede tomar. No estÃ¡ dentro del Proveedor en sÃ­.</p>
<p>En particular, los Dynamic Layouts o diseÃ±os dinÃ¡micos, permitirÃ¡n que los programas de Cairo adapten los recursos segÃºn sus necesidades. Esto puede llevar a una computaciÃ³n mÃ¡s eficiente y a una mejor utilizaciÃ³n de los recursos. Los diseÃ±os dinÃ¡micos permiten a SHARP determinar los recursos necesarios para un trabajo especÃ­fico y ajustar el diseÃ±o en consecuencia en lugar de depender de diseÃ±os predefinidos con recursos fijos. Este enfoque puede proporcionar soluciones personalizadas para cada trabajo, mejorando la eficiencia general.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="componentes---sharp"><a class="header" href="#componentes---sharp">Componentes - SHARP</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="playground"><a class="header" href="#playground">Playground</a></h1>
<p>El Playground de Cairo es una herramienta que te permite crear y probar cÃ³digos de Cairo de manera interactiva. Con esta plataforma, puedes desarrollar y probar tus programas de Cairo antes de implementarlos en una cadena de bloques.</p>
<p>El proceso de prueba en el Playground de Cairo consta de varios pasos. Primero, cuando escribes tu cÃ³digo en Cairo, el Playground lo compila y ejecuta para crear un rastro de ejecuciÃ³n. Este rastro se envÃ­a a la red de Cairo para su evaluaciÃ³n.</p>
<p>En la etapa de prueba, el sistema de Cairo, conocido como SHARP, recopila mÃºltiples trazas de ejecuciÃ³n de programas (incluso programas no relacionados) y los combina en un lote llamado &quot;tren&quot;. Al igual que un tren no sale de la estaciÃ³n a pedido, el tren de Cairo puede tardar un tiempo en ser enviado al probador. SHARP esperarÃ¡ hasta acumular un lote lo suficientemente grande de trazas de programas o hasta que haya transcurrido cierto tiempo, lo que ocurra primero.</p>
<p>Una vez que se ha formado el tren de pruebas, SHARP envÃ­a este conjunto al verificador en cadena (actualmente en Goerli). Para cada programa en el tren, el contrato SHARP registra un hecho en el Registro de hechos que certifica la validez de la ejecuciÃ³n y su salida particular. Con esto, se cierra el ciclo y tu aplicaciÃ³n en la cadena de bloques puede utilizar la salida del programa.</p>
<p>Durante todo este proceso, puedes monitorear el estado de tu trabajo haciendo clic en el enlace en el panel de salida del Playground. Se abrirÃ¡ una nueva pestaÃ±a que se actualizarÃ¡ automÃ¡ticamente y te mostrarÃ¡ en quÃ© etapa se encuentra tu trabajo.</p>
<p>AdemÃ¡s, puedes acceder al contrato compartido para ver el hecho de tu trabajo utilizando el mÃ©todo isValid().</p>
<div style="break-before: page; page-break-before: always;"></div><p>https://github.com/patrickbiel01/Cairo_Verifier</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quantum-leap"><a class="header" href="#quantum-leap">Quantum Leap</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="versiones"><a class="header" href="#versiones">Versiones</a></h1>
<p>Puede <a href="https://www.starknet.io/en/roadmap">consultar el roadmap</a> con cada uno de sus estados desde la pÃ¡ginal oficial, les dejamos un resumen de lo mÃ¡s importante.</p>
<p><strong>VersiÃ³n 0.12.1:</strong> en esta versiÃ³n se introdujo otra mejora significativa al incluir transacciones fallidas en el bloque. Anteriormente, en versiones anteriores a la 0.12, las transacciones fallidas no se incluÃ­an en el bloque, lo que resultaba en problemas para el Sequencer al no poder cobrar tarifas ni avanzar el nonce correspondiente a esas transacciones. Esta situaciÃ³n generaba inconvenientes en la experiencia de usuario para los desarrolladores, ya que debÃ­an monitorear constantemente el estado de las transacciones antes de enviar nuevas transacciones, sin poder confiar en el avance del nonce. Con esta actualizaciÃ³n, el Sequencer queda protegido de usuarios que intentan llenar el sistema con transacciones fallidas sin pagar por ellas.</p>
<p><strong>VersiÃ³n 0.13:</strong> en este lanzamiento previsto en su hoja de ruta para 2023, tiene como objetivo reducir significativamente los costos de transacciÃ³n mediante la introducciÃ³n del modo Volition, lo que permitirÃ¡ una gama mÃ¡s amplia de casos de uso y empoderando a los desarrolladores y usuarios. El compromiso de reducir costos se alinea con la misiÃ³n de Starknet de proporcionar una infraestructura escalable, flexible y rentable para aplicaciones descentralizadas.</p>
<p>El modo Volition permitirÃ¡ a los desarrolladores construir aplicaciones con un enfoque hÃ­brido de DA, que incorpora tanto datos en cadena como fuera de cadena.</p>
<p>Al aprovechar el modo Volition, Starknet prevÃ© una reducciÃ³n drÃ¡stica en el costo de los datos. Se espera que esta reducciÃ³n se logre a travÃ©s de dos factores clave: la implementaciÃ³n del EIP-4844 de Ethereum (Shard Blob Transaction) y la introducciÃ³n de Volition en sÃ­.</p>
<p><strong>VersiÃ³n 0.14:</strong> en esta versiÃ³n se introducirÃ¡ un mercado de tarifas, conocido como &quot;Fee Market&quot;, para mejorar la experiencia del usuario durante la congestiÃ³n de la red. Actualmente, cuando hay congestiÃ³n, los tiempos de espera de las transacciones aumentan para todos. Para abordar este problema, Starknet planea implementar un mercado de tarifas en la versiÃ³n 0.14.0. Este mercado permitirÃ¡ asignar eficientemente los recursos limitados de Starknet en base a la disposiciÃ³n de los usuarios para pagar por una transacciÃ³n, en lugar de simplemente seguir el orden de las transacciones en lÃ­nea. El objetivo de este mercado de tarifas es proporcionar a los usuarios una experiencia mÃ¡s predecible y fluida, incluso en momentos de alta actividad en la red.</p>
<p><strong>VersiÃ³n 0.15:</strong> esta actualizaciÃ³n permitirÃ¡ un mejor manejo de las transacciones fallidas, destacando especialmente la implementaciÃ³n de Sierra para demostrar dichas transacciones. Esta adiciÃ³n garantiza una experiencia de red mÃ¡s confiable y robusta al reducir la frecuencia de las transacciones fallidas y mejorar la eficiencia general del procesamiento de transacciones.</p>
<p>AdemÃ¡s, Starknet aborda el problema de la variabilidad en los intervalos de bloque, que genera tiempos de espera impredecibles para las transacciones, a partir de la versiÃ³n 0.15.0, se introducirÃ¡n intervalos de bloque constantes y mÃ¡s cortos.</p>
<p>Al desvincular la relaciÃ³n 1:1 entre un bloque de Starknet y su prueba, las pruebas podrÃ¡n verificar la integridad de uno o mÃ¡s bloques de Starknet. Esta modificaciÃ³n establecerÃ¡ intervalos de bloque fijos, lo que garantizarÃ¡ un comportamiento de red mÃ¡s consistente y predecible. El objetivo de la introducciÃ³n de intervalos de bloque mÃ¡s cortos y fijos es mejorar significativamente la experiencia general del usuario en Starknet al reducir los tiempos de espera y permitir un procesamiento de transacciones mÃ¡s fluido y eficiente.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-stack-1"><a class="header" href="#starknet-stack-1">Starknet Stack</a></h1>
<p>TL;DR (Too Long; Didn't Read):</p>
<p>El Stack de Starknet estÃ¡ experimentando un crecimiento vertiginoso y permitirÃ¡ lanzar tu propia instancia personalizada de Starknet para satisfacer tus necesidades. Starknet ya es la capa 2 mÃ¡s eficiente en tÃ©rminos de rendimiento, con la comunidad de desarrolladores de mÃ¡s rÃ¡pido crecimiento y la pila Rollup mÃ¡s descentralizada, que incluye infraestructura clave desarrollada por mÃºltiples equipos independientes. Pronto se lanzarÃ¡ la primera Starknet Appchain en Mainnet.</p>
<p>IntroducciÃ³n:</p>
<p>Actualmente, hay un renacimiento de las cadenas pÃºblicas de capa 2 sobre Ethereum. Starknet, en particular, ha florecido con una comunidad de desarrolladores activos que abordan emocionantes casos de uso en juegos, DeFi, NFTs, IA y mÃ¡s.</p>
<p>La necesidad de Appchains, cadenas de bloques especÃ­ficas de aplicaciones diseÃ±adas para satisfacer las necesidades de una aplicaciÃ³n especÃ­fica, ha sido evidente durante varios aÃ±os y ahora estÃ¡ recibiendo una mayor atenciÃ³n. La oferta de servicios SaaS de StarkWare, StarkEx, ha impulsado el Ã©xito de las Appchains de capa 2 mÃ¡s exitosas en funcionamiento en Ethereum, como dYdX y Sorare. A la fecha (julio de 2023), StarkEx ha liquidado alrededor de $1 billÃ³n en operaciones acumuladas y procesado mÃ¡s de 500 millones de transacciones. Las Appchains de Starknet son el entorno personalizado donde las aplicaciones pueden adaptar una instancia de Starknet para lograr un mayor control sobre las especificaciones, reducir costos, aumentar la escala y ofrecer privacidad opcional. El Stack de Starknet tiene como objetivo permitir que cualquier aplicaciÃ³n despliegue su propia Appchain de Starknet de forma descentralizada.</p>
<p>El Stack de Starknet:</p>
<p>Los bloques de construcciÃ³n de Starknet atraen a una amplia gama de aplicaciones y casos de uso, que incluyen pruebas STARK, el lenguaje de programaciÃ³n Cairo y AbstracciÃ³n de Cuenta nativa. Con la actualizaciÃ³n de Starknet a la versiÃ³n 0.12.0 en Mainnet, Starknet se convirtiÃ³ en la capa 2 mÃ¡s eficiente en tÃ©rminos de TPS. Se espera que la ventaja de rendimiento de Starknet sobre otras capas 2 y, en particular, sobre las capas 2 compatibles con EVM, aumente con el tiempo, ya que Starknet no estÃ¡ limitado por las restricciones heredadas impuestas por el diseÃ±o e implementaciÃ³n del EVM.</p>
<p>Sin embargo, es natural que algunas aplicaciones requieran ajustes adicionales a su plataforma. El Stack de Starknet les permitirÃ¡ hacerlo.</p>
<p>En lÃ­nea con el ecosistema de Starknet, se busca mostrar primero y contar despuÃ©s. Pero dado el desarrollo electrizante dentro de nuestro ecosistema y el ritmo con el que evoluciona el Stack, hemos decidido ofrecer nuestra perspectiva actual sobre el Stack de Starknet. Los esfuerzos de desarrollo estÃ¡n impulsados por el ecosistema de Starknet y orquestados por la FundaciÃ³n Starknet a travÃ©s de sus colaboraciones de desarrollo.</p>
<p>Beneficios:</p>
<p>El Stack de Starknet permite a las aplicaciones crear sus propias Appchains personalizadas. Estas proporcionarÃ¡n los beneficios genÃ©ricos de las Appchains, como:</p>
<ul>
<li>ProtecciÃ³n contra la congestiÃ³n en la red pÃºblica de Starknet, lo que permite a los usuarios obtener un mejor rendimiento y experiencia de usuario.</li>
<li>Las Appchains pueden implementar caracterÃ­sticas que no son compatibles con la cadena pÃºblica, como su propia lÃ³gica de mercado de tarifas. Desde la perspectiva de la red pÃºblica, estas nuevas caracterÃ­sticas implementadas en las Appchains son valiosos experimentos. Implementarlas en una Appchain proporcionarÃ­a conclusiones valiosas que podrÃ­an aplicarse a otras Appchains o a la red pÃºblica.</li>
</ul>
<p>AdemÃ¡s de estos beneficios, las Appchains de Starknet tendrÃ¡n ventajas adicionales. Starknet es el rollup mÃ¡s escalable, con la opciÃ³n de configurar varios parÃ¡metros, incluidos el consenso, los parÃ¡metros de la cadena de bloques y la disponibilidad de datos.</p>
<p>DescentralizaciÃ³n:</p>
<p>El Stack de Starknet se estÃ¡ convirtiendo rÃ¡pidamente en la pila L2 mÃ¡s descentralizada. Las blockchains sin permisos se centran en la descentralizaciÃ³n como medio para lograr la seguridad y resiliencia de la red. La FundaciÃ³n Starknet estÃ¡ enfocada en lograr esta propiedad para Starknet.</p>
<p>&quot;Una pila descentralizada hace que la red sea mÃ¡s segura, resiliente, transparente, escalable e innovadora. Sin un Ãºnico punto de falla, sin dependencia de una Ãºnica entidad, sin cajas negras y mucho mÃ¡s constructores&quot;.</p>
<p>Diego Oliva
CEO, Starknet Foundation</p>
<p>&quot;Starknet estÃ¡ logrando la descentralizaciÃ³n orgÃ¡nica de la pila: diferentes equipos estÃ¡n produciendo versiones optimizadas de los componentes principales, que luego vuelven a las versiones oficiales (LambdaClass Rust VM) o crean completamente nuevos componentes&quot;.</p>
<p>Nicolas Bacca
Cofundador y CTO, Ledger</p>
<p>Madara:
Un ejemplo reciente de la descentralizaciÃ³n del Stack de Starknet es el Secuenciador de Madara. EstÃ¡ basado en Substrate y, como tal, se basa en mecanismos de consenso descentralizados de forma nativa. El esfuerzo de desarrollo comunitario comenzÃ³ en febrero de 2023. El esfuerzo de ingenierÃ­a incluye a 45 desarrolladores de la comunidad, que hasta la fecha (julio de 2023) han realizado mÃ¡s de 740 commits y mÃ¡s de 400 solicitudes de extracciÃ³n fusionadas. Este esfuerzo ha producido un Secuenciador compatible con Starknet pÃºblico, con un mempool configurable y mÃ¡s.</p>
<p>LambdaClass:
Otro esfuerzo notable en la construcciÃ³n de la pila que permitirÃ¡ el lanzamiento de Appchains de Starknet es el trabajo realizado por LambdaClass (que tambiÃ©n desempeÃ±Ã³ un papel fundamental en las mejoras manifestadas en V0.12.0). LambdaClass estÃ¡ construyendo un Stack de Starknet que eventualmente incluirÃ¡ un probador, un secuenciador, un motor de ejecuciÃ³n y un explorador de red. En un futuro cercano, estos diferentes componentes podrÃ­an integrarse con otros componentes del Stack de Starknet y convertirse en una instancia funcional de Starknet.</p>
<p>Por la Comunidad, para la Comunidad:</p>
<p>El ecosistema de Starknet tiene como objetivo tener mÃºltiples implementaciones de cada componente en el Stack. AquÃ­ hay una muestra de los diferentes equipos y la infraestructura que estÃ¡n desarrollando:</p>
<p>| CategorÃ­a |	Proyecto | Entidad | Estado |
|Nodo completo | Pathfinder | Equilibrium |	En producciÃ³n |
Juno	Nethermind	En producciÃ³n
Papyrus	StarkWare	Pronto en producciÃ³n
Deoxys	KasarLabs	En desarrollo
Motor de ejecuciÃ³n	Blockifier	StarkWare	En producciÃ³n
starknet_in_rust	LambdaClass	Pronto en producciÃ³n
Secuenciador	SW Sequencer	StarkWare	En producciÃ³n
Madara	Comunidad	En desarrollo
LC Sequencer	LambdaClass	En desarrollo
Probador	SW Prover	StarkWare	En producciÃ³n
LC Prover	LambdaClass	En desarrollo
Sandstorm	Andrew Milson	En desarrollo</p>
<p>AdemÃ¡s de los componentes principales del Stack, hay componentes y servicios complementarios importantes que son necesarios para ejecutar una Appchain (todos en producciÃ³n, a menos que se indique lo contrario):</p>
<p>Exploradores de bloques: Starkscan, ViewBlock, Voyager y Explorer de LambdaClass (en desarrollo).
Indexadores: Apibara, Checkpoint, TokenFlow.
Servicios de API: Alchemy, Infura, Blast API, Lava y Chainstack.
Puentes: LayerSwap, Orbiter, StarkGate.
Pasarelas para monedas fiduciarias: Banxa, Ramp.
Billeteras: Argent, Braavos, Cartridge y Metamaskâ€™s Snap (llegarÃ¡ en sep 2023).
Marco de desarrollo de aplicaciones especÃ­fico de dominio: Dojo (juegos).
OrÃ¡culos: Pragma y RedStone.</p>
<p>Expresividad:</p>
<p>El Stack de Starknet estÃ¡ impulsado por Cairo. Su Ãºltima versiÃ³n, similar a Rust y ergonÃ³mica, ha generado una tremenda emociÃ³n en la comunidad de desarrolladores.</p>
<p>&quot;Como alguien que nunca ha escrito Rust, lo aprendÃ­ hace unas semanas y soy tan eficiente escribiendo contratos Cairo como Solidity. Agregue la capacidad de compartir lÃ³gica entre contratos (Â¡prÃ³ximamente!) y pruebas de fuzz incorporadas, y serÃ¡ mi entorno preferido para escribir contratos inteligentes&quot;.</p>
<p>Moody Salem
Desarrollador principal de Solidity, Uniswap</p>
<p>Cairo, como un lenguaje de contrato inteligente de propÃ³sito general, con la ventaja adicional de producir cÃ¡lculos demostrables, es utilizado por uno de los ecosistemas de desarrollo de blockchain de mÃ¡s rÃ¡pido crecimiento en la historia. Las aplicaciones pueden encontrar desarrolladores de Starknet con los que asociarse, contratar o externalizar.</p>
<p>&quot;El ecosistema de Starknet se siente como los primeros dÃ­as de Ethereum. Atrae al mejor talento en el espacio con su enfoque descentralizado para el desarrollo e innovaciÃ³n&quot;.</p>
<p>Itamar Lesuisse
Cofundador y CEO, Argent</p>
<p>El Camino por Delante:</p>
<p>El Stack de Starknet es un trabajo en progreso y continuarÃ¡ evolucionando y mejorando con el tiempo. Sin embargo, hoy en dÃ­a, las Appchains de Starknet se pueden ejecutar como un servicio alojado, operado por StarkWare. De hecho, la primera Appchain de Starknet se lanzarÃ¡ pronto en una versiÃ³n beta cerrada en Mainnet.</p>
<p>Esperamos que los equipos de desarrollo del ecosistema de Starknet, como LambdaClass, Nethermind y StarkWare, asÃ­ como los proveedores de Rollup como servicio, ofrezcan servicios de alojamiento para las Appchains. Las Appchains elegirÃ¡n quÃ© componentes del Stack ejecutar por sÃ­ mismas y cuÃ¡les a travÃ©s de un servicio de alojamiento (por ejemplo, SHARP de StarkWare). Pueden optar por depender de componentes de cÃ³digo abierto estrictamente, o de tecnologÃ­a propietaria. Esta es la belleza de las Appchains: una talla Ãºnica no sirve para todos. En cambio, cada aplicaciÃ³n tomarÃ¡ sus propias decisiones Ã³ptimas.</p>
<p>Las Appchains comenzaron como una capa 2 sobre Ethereum, pero no permanecerÃ¡n allÃ­ por mucho tiempo. En 2021, StarkWare introdujo el concepto de capa 3. Creemos que, para lograr una mayor escala y menor costo por transacciÃ³n, las Appchains de Starknet migrarÃ¡n a la capa 3 y, como tal, se ejecutarÃ¡n sobre la red pÃºblica de Starknet.</p>
<p>Resumen:</p>
<p>El Stack de Starknet estÃ¡ experimentando un crecimiento notable. Esperamos que domine el espacio de las Appchains debido a su rendimiento, seguridad y expresividad. El prÃ³spero ecosistema de desarrolladores de Starknet, que ha impulsado la rÃ¡pida evoluciÃ³n de este Stack, continuarÃ¡ desarrollÃ¡ndolo y satisfaciendo las diversas necesidades de mÃ¡s y mÃ¡s aplicaciones.</p>
<div style="break-before: page; page-break-before: always;"></div><p>https://starkware.co/resource/paradex-starknets-first-appchain/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-stack-2"><a class="header" href="#starknet-stack-2">Starknet Stack</a></h1>
<ol>
<li>
<p><strong>Client</strong>: Es el punto de inicio del ciclo. El cliente envÃ­a transacciones de Starknet a travÃ©s de la red.</p>
</li>
<li>
<p><strong>Sequencer</strong>: El secuenciador recibe las transacciones enviadas por el cliente y las organiza en bloques que contienen varias transacciones.</p>
</li>
<li>
<p><strong>Watcher-Prover</strong>: Este es un servicio que actÃºa en dos partes: el &quot;Watcher&quot; y el &quot;Prover&quot;.</p>
<ul>
<li><strong>Watcher</strong>: Monitorea la cadena de bloques en busca de bloques confirmados generados por el secuenciador.</li>
<li><strong>Prover</strong>: Genera pruebas (STARK proofs) para cada transacciÃ³n dentro de los bloques confirmados. Para hacerlo, utiliza la &quot;Cairo VM&quot; para ejecutar los programas Cairo asociados con cada transacciÃ³n y genera las trazas correspondientes.</li>
</ul>
</li>
<li>
<p><strong>Request blocks through RPC</strong>: DespuÃ©s de que el &quot;Watcher-Prover&quot; identifica un nuevo bloque con transacciones confirmadas, solicita los bloques al secuenciador a travÃ©s de un protocolo de comunicaciÃ³n remota llamado RPC (Remote Procedure Call).</p>
</li>
<li>
<p><strong>STARK proofs</strong>: Una vez que el &quot;Watcher-Prover&quot; tiene acceso a los bloques confirmados, genera pruebas STARK para cada transacciÃ³n dentro de esos bloques utilizando la informaciÃ³n obtenida de la ejecuciÃ³n de los programas Cairo asociados con cada transacciÃ³n.</p>
</li>
<li>
<p><strong>Proof Storage (Db)</strong>: Las pruebas STARK generadas se almacenan en una base de datos (Db) para su posterior uso y consulta. Es importante destacar que el estilo de lÃ­nea (stroke-dasharray: 5) indica que esta conexiÃ³n es de tipo almacenamiento, es decir, una conexiÃ³n de datos mÃ¡s permanente.</p>
</li>
<li>
<p><strong>Cairo Native</strong>: Es la ejecuciÃ³n de los programas Cairo asociados con cada transacciÃ³n dentro de los bloques confirmados. Estos programas son ejecutados en la &quot;Cairo Native&quot; para obtener resultados y trazas que se utilizarÃ¡n para generar las pruebas STARK.</p>
</li>
<li>
<p><strong>Consensus (C)</strong>: Es la fase del ciclo en la que se realiza el proceso de consenso. AquÃ­, se acuerda el orden y la validez de las transacciones dentro de los bloques, lo que garantiza que todos los nodos de la red estÃ©n de acuerdo con el estado actual de la cadena de bloques.</p>
</li>
<li>
<p><strong>Blockchain data</strong>: Una vez que el consenso se ha alcanzado y las transacciones se han confirmado, la informaciÃ³n sobre los bloques y las transacciones se almacena en la cadena de bloques. En este punto, la informaciÃ³n de la cadena de bloques estÃ¡ disponible para ser explorada y verificada.</p>
</li>
<li>
<p><strong>Explorer</strong>: Es una herramienta de exploraciÃ³n y verificaciÃ³n de la cadena de bloques. Permite a los usuarios navegar por los bloques y transacciones, asÃ­ como verificar la validez de las pruebas STARK asociadas con las transacciones.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="watcherprover"><a class="header" href="#watcherprover">WatcherProver</a></h1>
<p>Este es el servicio de watcher-prover para el sistema de pruebas.</p>
<p>La arquitectura consiste en un watcher que monitorea la cadena de bloques en busca de bloques confirmados y un prover que genera pruebas para cada transacciÃ³n del bloque. Puede conectarse a cualquier cadena de bloques que admita contratos inteligentes.</p>
<p>Cuando el watcher encuentra una nueva transacciÃ³n con un programa, primero llama a <a href="https://github.com/lambdaclass/cairo-rs/">cairo-rs</a> para ejecutar el programa Cairo y generar la traza. Luego, esta traza se envÃ­a al prover de Lambdaworks que crea la prueba. La prueba se coloca luego en un bloque posterior en la cadena de bloques.</p>
<p>Inicialmente, estas operaciones se realizarÃ¡n de forma secuencial. Sin embargo, en el futuro, el objetivo es realizarlas en paralelo, escalando horizontalmente.</p>
<p>Al ejecutar los provers en paralelo, la capacidad del sistema de pruebas serÃ¡ tan alta como la capacidad de la cadena de bloques. Sin embargo, existe una latencia del prover y la inclusiÃ³n de las pruebas en los bloques.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-avalability"><a class="header" href="#data-avalability">Data Avalability</a></h1>
<p>En la etapa actual de Alpha, Starknet opera en modo ZK-Rollup. Esto significa que al aceptar una actualizaciÃ³n de estado en la cadena, la diferencia de estado entre el estado anterior y el nuevo se envÃ­a como datos de llamada (calldata) a Ethereum.</p>
<p>Estos datos permiten a cualquiera que observe Ethereum reconstruir el estado actual de Starknet.</p>
<p>Para actualizar el estado de Starknet en L1, es suficiente enviar una prueba vÃ¡lida, sin informaciÃ³n sobre las transacciones o los cambios particulares que causÃ³ esta actualizaciÃ³n.</p>
<p>Consecuentemente, se debe proporcionar mÃ¡s informaciÃ³n para permitir que otras partes rastreen localmente el estado de Starknet.</p>
<p>Datos en la cadena: despuÃ©s de v0.11.0 Formato v0.11.0 Las diferencias de estado contienen informaciÃ³n sobre cada contrato cuyo almacenamiento se ha actualizado, asÃ­ como informaciÃ³n adicional sobre los despliegues de contratos.</p>
<p>Para cada contrato afectado, tenemos:</p>
<ul>
<li><strong>La direcciÃ³n del contrato</strong></li>
<li><strong>Una sola palabra que codifica:</strong>
<ul>
<li>Un indicador de informaciÃ³n de clase (0 = solo actualizaciones de almacenamiento / 1 = el contrato fue desplegado o reemplazado en esta actualizaciÃ³n de estado). Cuando este indicador estÃ¡ activado, habrÃ¡ una palabra adicional antes de la secciÃ³n de actualizaciones de almacenamiento, que contiene el nuevo hash de clase.</li>
</ul>
</li>
<li><strong>Nonce</strong></li>
<li><strong>num_of_storage_updates</strong> (nÃºmero de actualizaciones de almacenamiento).</li>
</ul>
<p>A continuaciÃ³n se muestra </p>
<p><img src="./assets/state.png" alt="graph" /></p>
<div align="center">
<em>AsÃ­ debe de ser el formato esperado</em>
</div>
<p>Para cada actualizaciÃ³n de almacenamiento:</p>
<ul>
<li><strong>clave:</strong> la direcciÃ³n dentro del almacenamiento del contrato donde se actualiza el valor</li>
<li><strong>valor:</strong> el nuevo valor</li>
</ul>
<p>A continuaciÃ³n, se proporciona informaciÃ³n sobre las clases declaradas y el nÃºmero de clases (Cairo 1.0) presentes en el bloque.</p>
<p>Para cada clase, se incluyen los siguientes detalles:</p>
<ol>
<li>Hash de la clase.</li>
<li>Hash de la clase compilada.</li>
</ol>
<h2 id="ejemplos-despuÃ©s-la-v0110"><a class="header" href="#ejemplos-despuÃ©s-la-v0110">Ejemplos despuÃ©s la v0.11.0</a></h2>
<p>A continuaciÃ³n, mostramos un ejemplo de datos en la cadena que se extrajeron de L1 y procedemos a decodificarlo segÃºn el formato mencionado anteriormente.</p>
<pre><code class="language-bash">[
1,
2019172390095051323869047481075102003731246132997057518965927979101413600827,
18446744073709551617,
100,
200,
1,
1351148242645005540004162531550805076995747746087542030095186557536641755046,
558404273560404778508455254030458021013656352466216690688595011803280448032
]
</code></pre>
<ul>
<li>El primer elemento <code>1</code>, es el nÃºmero de contratos cuyo estado se actualizÃ³.</li>
<li>El segundo elemento, <code>2019172390095051323869047481075102003731246132997057518965927979101413600827</code>, es la direcciÃ³n del primer (y Ãºnico) contrato cuyo estado cambiÃ³, recordamos que es un felt su expresiÃ³n hexadecimal serÃ­a <code>0x0476cfa27c83ea2498c4fb61972c2b80d2b1cd500986a881ec3c4e5b4f726e3b</code>.</li>
<li>El tercer elemento, 18446744073709551617, que es 2^64+1, codifica lo siguiente:
<ul>
<li>El indicador de informaciÃ³n de clase es 0, es decir, el contrato no se desplegÃ³ ni se reemplazÃ³, por lo que no debemos tratar la siguiente palabra como el hash de clase.</li>
<li>El nuevo nonce es 1.</li>
<li>Se actualizÃ³ una celda de almacenamiento.</li>
</ul>
</li>
<li>Los dos elementos siguientes, <code>100</code> y <code>200</code>, codifican la actualizaciÃ³n de almacenamiento (el valor de la clave 100 se estableciÃ³ en 200).</li>
<li>A continuaciÃ³n, tenemos la secciÃ³n de declaraciones nuevas: <code>1</code> significa que tuvimos una Ãºnica declaraciÃ³n v2 en esta actualizaciÃ³n de estado, y los dos elementos siguientes, codifican el <code>class hash</code> y el <code>class hash compile</code> del <code>class declare</code>.</li>
</ul>
<h2 id="formato-anterior-a-la-011"><a class="header" href="#formato-anterior-a-la-011">Formato Anterior a la 0.11</a></h2>
<p>Las state diffs contienen informaciÃ³n sobre cada contrato cuyo storage se ha actualizado, asÃ­ como informaciÃ³n adicional sobre los despliegues de contratos. Esas diferencias se envÃ­an como un arreglo uint256[] como parte de los datos de llamada (calldata), y se codifican de la siguiente manera:</p>
<ul>
<li>NÃºmero de celdas que codifican los despliegues de contratos.</li>
<li>Para cada contrato desplegado, tenemos:
<ul>
<li>contract_address: la direcciÃ³n del contrato desplegado.</li>
<li>contract_hash: el hash de la clase.</li>
</ul>
</li>
<li>NÃºmero de contratos cuyo almacenamiento se actualiza.</li>
<li>Para cada contrato de ese tipo, tenemos:
<ul>
<li>contract_address: la direcciÃ³n del contrato.</li>
<li>num_of_storage_updates: el nÃºmero de actualizaciones de almacenamiento.</li>
<li>nonce,Î½mofsâ†’raâ‰¥actualizaciones: un valor uint256 que codifica tanto el nÃºmero de actualizaciones de almacenamiento para ese contrato como el nonce actualizado:</li>
</ul>
</li>
</ul>
<p><img src="./assets/state1.png" alt="graph" /></p>
<div align="center">
<em>AsÃ­ era el formato esperado antes de 0.11</em>
</div>
<ul>
<li>Para cada actualizaciÃ³n de almacenamiento:
<ul>
<li>clave: la direcciÃ³n dentro del almacenamiento del contrato donde se actualiza el valor</li>
<li>valor: el nuevo valor</li>
</ul>
</li>
</ul>
<h2 id="ejemplos-antes-la-v0110"><a class="header" href="#ejemplos-antes-la-v0110">Ejemplos antes la v0.11.0</a></h2>
<p>A continuaciÃ³n, mostramos un ejemplo de datos en cadena que se extrajeron de L1 y se decodificaron segÃºn el formato anterior.</p>
<pre><code class="language-bash">[
2,
2472939307328371039455977650994226407024607754063562993856224077254594995194,
1336043477925910602175429627555369551262229712266217887481529642650907574765,
5,
2019172390095051323869047481075102003731246132997057518965927979101413600827,
18446744073709551617,
5,
102,
2111158214429736260101797453815341265658516118421387314850625535905115418634,
2,
619473939880410191267127038055308002651079521370507951329266275707625062498,
1471584055184889701471507129567376607666785522455476394130774434754411633091,
619473939880410191267127038055308002651079521370507951329266275707625062499,
541081937647750334353499719661793404023294520617957763260656728924567461866,
2472939307328371039455977650994226407024607754063562993856224077254594995194,
1,
955723665991825982403667749532843665052270105995360175183368988948217233556,
2439272289032330041885427773916021390926903450917097317807468082958581062272,
3429319713503054399243751728532349500489096444181867640228809233993992987070,
1,
5,
1110,
3476138891838001128614704553731964710634238587541803499001822322602421164873,
6,
59664015286291125586727181187045849528930298741728639958614076589374875456,
600,
221246409693049874911156614478125967098431447433028390043893900771521609973,
400,
558404273560404778508455254030458021013656352466216690688595011803280448030,
100,
558404273560404778508455254030458021013656352466216690688595011803280448031,
200,
558404273560404778508455254030458021013656352466216690688595011803280448032,
300,
1351148242645005540004162531550805076995747746087542030095186557536641755046,
500
]
</code></pre>
<ul>
<li>El primer elemento <code>2</code>, es el nÃºmero de celdas que codifican la implementaciÃ³n de contratos.</li>
<li>Los dos siguientes elementos describen una Ãºnica implementaciÃ³n de contrato con los siguientes parÃ¡metros:
<ul>
<li>direcciÃ³n_contrato:</li>
</ul>
</li>
</ul>
<pre><code class="language-bash">2472939307328371039455977650994226407024607754063562993856224077254594995194
</code></pre>
<ul>
<li>hash_contrato:</li>
</ul>
<pre><code class="language-bash">1336043477925910602175429627555369551262229712266217887481529642650907574765
</code></pre>
<ul>
<li>El siguiente elemento <code>5</code> (Ã­ndice 3 en el array), es el nÃºmero de contratos cuyo almacenamiento se actualizÃ³. Tomaremos solo el primer contrato como ejemplo.
<ul>
<li>direcciÃ³n_contrato:</li>
</ul>
</li>
</ul>
<pre><code class="language-bash">2019172390095051323869047481075102003731246132997057518965927979101413600827
</code></pre>
<ul>
<li>DespuÃ©s de la direcciÃ³n de contrato mencionada anteriormente, tenemos <code>18446744073709551617</code> (Ã­ndice 8 en el array), que es <code>2^64+1</code> , por lo tanto:
<ul>
<li>El nuevo nonce del contrato es 1.</li>
<li>Se actualiza una clave de almacenamiento.</li>
<li>El valor en la clave 5 se cambiÃ³ a 102.</li>
</ul>
</li>
</ul>
<p>Las siguientes 4 actualizaciones de almacenamiento de contratos se interpretan de la misma manera.</p>
<p>ExtracciÃ³n desde Ethereum Los datos descritos anteriormente se envÃ­an a travÃ©s de varias transacciones de Ethereum, cada una de las cuales contiene una parte de esta matriz como calldata. Cada nuevo bloque de Starknet tiene sus transacciones de difusiÃ³n de estado asociadas.</p>
<p>Puede encontrar <a href="https://github.com/eqlabs/pathfinder/blob/2fe6f549a0b8b9923ed7a21cd1a588bc571657d6/crates/pathfinder/src/ethereum/state_update/retrieve.rs">el cÃ³digo para extraer estos datos</a> de Ethereum en el repositorio de Pathfinder.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evm-vs-zkevm"><a class="header" href="#evm-vs-zkevm">EVM vs zkEVM</a></h1>
<p>El desafÃ­o central con el enfoque zkEVM estÃ¡ enraizado en el plan original de EVM, este no fue diseÃ±ado para funcionar dentro de un contexto de prueba de validez. En consecuencia, los esfuerzos para reflejar su funcionalidad no logran desbloquear todo el potencial de las pruebas de validez, lo que resulta en una eficiencia menos que Ã³ptima. Tal ineficiencia finalmente pesa el rendimiento general del sistema. </p>
<p>La compatibilidad del EVM con las pruebas de validez se ve obstaculizada por los siguientes factores:</p>
<ul>
<li>
<p>El EVM emplea un modelo basado en apilamiento, mientras que las pruebas de validez se emplean de manera mÃ¡s efectiva con un modelo basado en registros. La naturaleza basada en la pila del EVM hace que sea inherentemente mÃ¡s difÃ­cil demostrar la exactitud de su ejecuciÃ³n y proporcionar soporte directo para su cadena de herramientas nativa.</p>
</li>
<li>
<p>El diseÃ±o de almacenamiento Ethereum depende en gran medida de Keccak y un gran Ã¡rbol Merkle Patricia, que no son amigables con Validity Proof e imponen una carga de prueba sustancial. Por ejemplo, Keccak es muy rÃ¡pido para las arquitecturas x86 ( sobre las cuales generalmente ejecutamos el EVM ), pero toma 90k pasos para probar ( con una construcciÃ³n especial incorporada ). Mientras que Pedersen ( una funciÃ³n hash amigable con zk ) da 32 pasos. Incluso con compresiÃ³n recursiva, el uso de Keccak en un zkEVM significa altos recursos de prover que terminan siendo pagados por el usuario.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kakarot---bases-de-su-arquitectura"><a class="header" href="#kakarot---bases-de-su-arquitectura">Kakarot - Bases de su arquitectura</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vm-de-cairo"><a class="header" href="#vm-de-cairo">VM de Cairo</a></h1>
<p>La MÃ¡quina Virtual Cairo (CVM) es un componente esencial del lenguaje de programaciÃ³n Cairo, utilizado para desarrollar y ejecutar contratos inteligentes en la cadena de bloques. Su arquitectura eficiente y sofisticada permite una gestiÃ³n avanzada de la memoria, validaciÃ³n de instrucciones y deducciÃ³n de valores.</p>
<p>La CVM forma el nÃºcleo del lenguaje Cairo, brindando capacidades avanzadas de ejecuciÃ³n de contratos inteligentes y permitiendo el desarrollo de aplicaciones descentralizadas seguras y eficientes en la cadena de bloques. Su diseÃ±o tÃ©cnico y eficiente hace posible la ejecuciÃ³n de programas complejos y la validaciÃ³n precisa de memoria, garantizando la confiabilidad y precisiÃ³n en la ejecuciÃ³n de los contratos inteligentes.</p>
<p>A continuaciÃ³n, se detalla su funcionamiento y estructura tÃ©cnica:</p>
<h2 id="gestiÃ³n-de-memoria-y-segmentos"><a class="header" href="#gestiÃ³n-de-memoria-y-segmentos">GestiÃ³n de Memoria y Segmentos</a></h2>
<p>La memoria de Cairo es de solo lectura, y las direcciones de memoria que el programa accede deben ser continuas. Los posibles huecos entre las direcciones son llenados con valores arbitrarios.</p>
<p>La memoria se organiza en segmentos continuos, cuyo tamaÃ±o varÃ­a y solo se conoce al finalizar la ejecuciÃ³n del programa. Las direcciones absolutas de cada celda dentro de un segmento se determinan utilizando valores <code>Relocatable</code>, que indican el nÃºmero de segmento y el desplazamiento.</p>
<p>Los diferentes segmentos son:</p>
<ol>
<li><strong>Segmento del Programa:</strong> Contiene el bytecode de Cairo, con el <code>Program Counter (pc)</code> iniciando al principio de este segmento.</li>
<li><strong>Segmento de EjecuciÃ³n:</strong> AquÃ­ se generan datos durante la ejecuciÃ³n del programa Cairo y su longitud es variable segÃºn la entrada del programa. Los <code>Allocation Pointer (ap)</code> y <code>Frame Pointer (fp)</code> comienzan aquÃ­.</li>
<li><strong>Segmento Incorporado:</strong> Cada funciÃ³n incorporada tiene su propio espacio continuo en memoria. La longitud es variable.</li>
</ol>
<h2 id="registros"><a class="header" href="#registros">Registros</a></h2>
<p>Los registros son fundamentales para el funcionamiento de la MÃ¡quina Virtual Cairo:</p>
<ol>
<li><strong>Allocation Pointer (ap):</strong> Apunta a una celda de memoria sin usar.</li>
<li><strong>Frame Pointer (fp):</strong> Apunta al marco de la funciÃ³n actual. Las direcciones de todas las variables locales y argumentos son relativas al valor de este registro. Al inicio de una <strong>function1</strong>, <code>fp</code> es igual a <code>ap</code> y permanece constante durante su ejecuciÃ³n. Cuando una <strong>function2</strong> se llama dentro de una <strong>function1</strong>, el valor de <code>fp</code> cambia para <strong>function2</strong> pero se restaura a su valor original al finalizar <strong>function2</strong> (esto permite rastrear el valor original de <strong>function1</strong>).</li>
<li><strong>Program Counter (pc):</strong> Apunta a la instrucciÃ³n actual. Cada instrucciÃ³n toma 1 o 2 <code>felts</code>, y <code>pc</code> avanza 1 o 2 despuÃ©s de cada instrucciÃ³n. Los saltos pueden cambiar el valor del <code>pc</code> a un valor absoluto o relativo, segÃºn las operaciones de salto.</li>
</ol>
<h2 id="validaciÃ³n-y-deducciÃ³n-de-valores"><a class="header" href="#validaciÃ³n-y-deducciÃ³n-de-valores">ValidaciÃ³n y DeducciÃ³n de Valores</a></h2>
<p>La MÃ¡quina Virtual Cairo es capaz de deducir valores de memoria y validar la ejecuciÃ³n de instrucciones para asegurar la integridad y correctitud del programa. Utiliza pruebas recursivas para optimizar y paralelizar la ejecuciÃ³n, lo que mejora la eficiencia y escalabilidad del sistema.</p>
<h2 id="jerarquÃ­a-de-estructuras"><a class="header" href="#jerarquÃ­a-de-estructuras">JerarquÃ­a de Estructuras</a></h2>
<p>La MÃ¡quina Virtual Cairo se basa en una jerarquÃ­a de estructuras que permiten un manejo complejo de la memoria y las operaciones:</p>
<ol>
<li><strong><code>VirtualMachineBase</code>:</strong> Proporciona la base para la MÃ¡quina Virtual Cairo, con atributos importantes como el contexto de ejecuciÃ³n, registros, funciones incorporadas y mÃ¡s.</li>
<li><strong><code>ValidatedMemoryDict</code>:</strong> Contiene una memoria validada con reglas de validaciÃ³n y auto-deducciÃ³n de valores.</li>
<li><strong><code>auto_deduction</code></strong>: Es un diccionario que mapea un Ã­ndice de memoria segmento a una lista de reglas para deducir el valor de una celda de memoria.</li>
</ol>
<h2 id="representaciÃ³n-del-programa"><a class="header" href="#representaciÃ³n-del-programa">RepresentaciÃ³n del Programa</a></h2>
<p>El programa Cairo se representa mediante la estructura <code>ProgramBase</code>, que contiene informaciÃ³n sobre funciones, referencias, constantes y otros elementos del programa. Esta estructura es serializable, lo que facilita su almacenamiento y distribuciÃ³n en la cadena de bloques.</p>
<h2 id="air-y-builtins"><a class="header" href="#air-y-builtins">AIR y Builtins</a></h2>
<p>Profundizaremos en la arquitectura de la CVM y su funcionamiento a nivel de ejecutar AIR, optimizaciones usando builtins, instrucciones y sus diseÃ±os para mejorar pasos y potenciar sus funciones. En ellos, estarÃ¡ cÃ³mo se organizan los diseÃ±os lineales o dinÃ¡micos para optimizar el rendimiento de un programa de Cairo, y revisaremos las celdas traza.</p>
<p>Este conjunto minimalista de instrucciones se denomina <code>RISC algebraico</code> (Computadora de conjunto de instrucciones reducidas); <code>Algebraico</code> se refiere al hecho de que las operaciones admitidas son operaciones de campo. El uso de un <code>RISC algebraico</code> nos permite construir un AIR para Cairo con solo 51 celdas traza por paso.</p>
<p>Uno de los mejores ejemplos es <a href="https://www.risczero.com/">RISC Zero</a>, que detallaremos mÃ¡s en otras arquitecturas. BÃ¡sicamente, <code>RISC Zero zkVM</code> es un ordenador verificable que funciona como un microprocesador <code>RISC-V</code> real integrado, lo que permite a los programadores escribir pruebas ZK como si escribieran cualquier otro cÃ³digo. TambiÃ©n destaca que soporta Rust para escribir pruebas ZK y puede admitir cualquier lenguaje que compile en RISC-V.</p>
<h3 id="builtin"><a class="header" href="#builtin">Builtin</a></h3>
<p>Los builtins son unidades de ejecuciÃ³n de bajo nivel optimizadas predefinidas que se agregan a la placa de la CPU de Cairo para realizar cÃ¡lculos predefinidos que son costosos de realizar en vainilla Cairo (por ejemplo, verificaciones de rango, hash de Pedersen, ECDSA, ...).</p>
<p>Poseidon es una familia de funciones hash diseÃ±adas para ser muy eficientes como circuitos algebraicos. Como tales, pueden ser muy Ãºtiles en sistemas de prueba ZK como STARK y otros.</p>
<p>La comunicaciÃ³n entre la CPU y los builtins se realiza a travÃ©s de la memoria: a cada builtin se le asigna un Ã¡rea continua en la memoria y aplica algunas restricciones (dependiendo de la definiciÃ³n del builtin) en las celdas de memoria en esa Ã¡rea. En tÃ©rminos de construcciÃ³n del AIR, significa que agregar builtins no afecta las restricciones de la CPU. Simplemente significa que la misma memoria se comparte entre la CPU y los builtins.</p>
<p>Para <code>invocar</code> un builtin, el programa de Cairo <code>se comunica</code> con ciertas celdas de memoria, y el builtin impone algunas restricciones en esas celdas de memoria.</p>
<h2 id="fase-de-inicializaciÃ³n-y-ejecuciÃ³n-de-hints-en-la-cvm"><a class="header" href="#fase-de-inicializaciÃ³n-y-ejecuciÃ³n-de-hints-en-la-cvm">Fase de InicializaciÃ³n y EjecuciÃ³n de Hints en la CVM</a></h2>
<p>La operaciÃ³n de la CVM involucra dos fases cruciales: la Fase de InicializaciÃ³n y la Fase de EjecuciÃ³n. Durante estas etapas, se administran y ejecutan las &quot;hints&quot; (pistas o indicaciones) que desempeÃ±an un papel esencial en el procesamiento eficiente y seguro de programas. Los &quot;hints&quot; son fragmentos de informaciÃ³n contextual que se incorporan en el cÃ³digo del programa, suministrando instrucciones especÃ­ficas a la CVM durante su ejecuciÃ³n. Estas instrucciones abarcan desde detalles sobre el flujo de ejecuciÃ³n hasta orientaciones sobre las operaciones a llevar a cabo. Los &quot;hints&quot; ofrecen un mecanismo para optimizar y agilizar la ejecuciÃ³n de contratos inteligentes, al tiempo que garantizan su correcciÃ³n y seguridad.</p>
<p>En el Ã¡mbito de las pruebas en la cadena de bloques, los &quot;hints&quot; desempeÃ±an un papel crucial en la generaciÃ³n y verificaciÃ³n de los STARKS. Los &quot;hints&quot; en este contexto proporcionan informaciÃ³n adicional a los Provers y el Verifier, posibilitando la generaciÃ³n y revisiÃ³n de pruebas con mayor precisiÃ³n.</p>
<p>A continuaciÃ³n, se desglosan los procesos inherentes a cada una de estas fases:</p>
<h3 id="fase-de-inicializaciÃ³n"><a class="header" href="#fase-de-inicializaciÃ³n">Fase de InicializaciÃ³n</a></h3>
<p>En esta etapa inicial, se realizan una serie de actividades fundamentales:</p>
<ol>
<li>
<p><strong>Carga del Programa:</strong> La fase se inicia con la disponibilidad de un archivo JSON compilado que encapsula detalles exhaustivos sobre un programa en la MÃ¡quina Virtual Cairo.</p>
</li>
<li>
<p><strong>SecciÃ³n de Hints:</strong> Dentro del archivo, una secciÃ³n denominada &quot;hint&quot; alberga informaciÃ³n detallada sobre cada &quot;hint&quot; presente en el programa.</p>
</li>
<li>
<p><strong>Detalle de Hints:</strong> Cada &quot;hint&quot; contiene datos esenciales, como su cÃ³digo, los contextos en los que es accesible (principal, funciÃ³n actual, funciones integradas e incluso la ruta de importaciÃ³n en el caso de funciones importadas), seguimiento de flujo y las &quot;reference_ids&quot; que se vinculan a las variables con las que interactÃºa en su entorno.</p>
</li>
<li>
<p><strong>Almacenamiento de InformaciÃ³n:</strong> Al cargar el archivo JSON y crear un objeto &quot;Program&quot;, toda la informaciÃ³n relacionada con los &quot;hints&quot; se organiza en un campo llamado &quot;hints&quot;, estructurado como un diccionario.</p>
</li>
<li>
<p><strong>Carga y AsociaciÃ³n:</strong> En el inicio de la mÃ¡quina virtual (VM) y la carga de los datos del programa a travÃ©s de la funciÃ³n &quot;load_program&quot;, tambiÃ©n se ejecuta la funciÃ³n &quot;load_hints&quot;. Esto da como resultado la creaciÃ³n de un diccionario que relaciona una direcciÃ³n en el programa con una lista de &quot;hints&quot; compilados. Es posible que una misma direcciÃ³n albergue varios &quot;hints&quot;.</p>
</li>
<li>
<p><strong>AsignaciÃ³n de Identificadores:</strong> AdemÃ¡s, se establece un mapeo que conecta un &quot;id&quot; (identificador Ãºnico del &quot;hint&quot;) con una direcciÃ³n y, en situaciones en las que existen mÃºltiples &quot;hints&quot; en la misma direcciÃ³n, se asigna un Ã­ndice. Esta disposiciÃ³n facilita la identificaciÃ³n y gestiÃ³n de los &quot;hints&quot;.</p>
</li>
<li>
<p><strong>CompilaciÃ³n de Hints:</strong> La obtenciÃ³n de los &quot;hints&quot; compilados se lleva a cabo mediante la funciÃ³n &quot;compile&quot; de Python en modo de ejecuciÃ³n, utilizando el cÃ³digo inherente a cada &quot;hint&quot;.</p>
</li>
</ol>
<h3 id="fase-de-ejecuciÃ³n"><a class="header" href="#fase-de-ejecuciÃ³n">Fase de EjecuciÃ³n</a></h3>
<p>La Fase de EjecuciÃ³n abarca los siguientes pasos:</p>
<ol>
<li>
<p><strong>GestiÃ³n de Hints:</strong> Al dar comienzo a un paso en la ejecuciÃ³n del programa, se inicia el manejo de los &quot;hints&quot;.</p>
</li>
<li>
<p><strong>RecopilaciÃ³n y ExploraciÃ³n:</strong> Se reÃºne la lista de &quot;hints&quot; en la direcciÃ³n actual del programa (si estÃ¡ presente) y se procede a iterar a travÃ©s de ella.</p>
</li>
<li>
<p><strong>Entorno de EjecuciÃ³n:</strong> Se crea un diccionario llamado &quot;exec_locals&quot;, el cual encapsula informaciÃ³n relevante. Esto incluye la entrada del programa, la memoria validada (&quot;validated_memory&quot;), los registros actuales (ap, fp, pc), el paso actual, los identificadores (que contienen memoria), ap, fp y pc como constantes, y algunas funciones especÃ­ficas del programa.</p>
</li>
<li>
<p><strong>EjecuciÃ³n de Hints:</strong> Posteriormente, cada &quot;hint&quot; se ejecuta mediante la funciÃ³n &quot;exec&quot; de Python. En este contexto, el diccionario &quot;exec_locals&quot; se emplea como entorno de ejecuciÃ³n para estas operaciones.</p>
</li>
</ol>
<h2 id="versiones-vm"><a class="header" href="#versiones-vm">Versiones VM</a></h2>
<p>A medida que ha transcurrido el tiempo, se han implementado una serie de optimizaciones en varias versiones de la CVM. Nuestra atenciÃ³n se concentrarÃ¡ en el contexto del ecosistema desarrollado por Starkware, especÃ­ficamente, exploraremos las distintas encarnaciones de la VM dentro de este marco. Sin embargo, es importante resaltar que el tema de las relaciones con las STARKs en diversos contextos, mÃ¡s allÃ¡ de Starknet y otras arquitecturas, es un asunto amplio y diversificado que tiene varios espacios detallados en capÃ­tulos separados.</p>
<ul>
<li>Inicialmente, se creÃ³ la MÃ¡quina Virtual Cairo en Python por parte de Starkware, y durante varios aÃ±os, esta versiÃ³n fue el nÃºcleo del ecosistema.</li>
<li>Posteriormente, con Quantum Leap y la versiÃ³n 0.12, se incorporÃ³ una implementaciÃ³n en Rust de la VM de Cairo, conocida como <a href="/https://github.com/lambdaclass/cairo-vm">cairo-vm en Rust</a>. Esta implementaciÃ³n en Rust logrÃ³ un rendimiento destacado gracias a Lambda Class.</li>
<li>AdemÃ¡s, se encuentra en desarrollo una <a href="https://github.com/lambdaclass/cairo-vm.go">VM en GO</a> desde Lamda Class, esta implementaciÃ³n en curso de la MÃ¡quina Virtual Cairo en Go tiene mÃºltiples objetivos, pero podemos destacar la <strong>Diversidad de Implementaciones</strong>. Contar con varias implementaciones contribuye a la detecciÃ³n de errores y fortalece todo el ecosistema, ademÃ¡s de poder documentar ampliamente la MÃ¡quina Virtual en su conjunto.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtins-y-mecanismos-de-fee"><a class="header" href="#builtins-y-mecanismos-de-fee">Builtins y Mecanismos de Fee</a></h1>
<p>En esta secciÃ³n, revisaremos el mecanismo de tarifas de Starknet Alpha. Si desea omitir la motivaciÃ³n y profundizar en el mecanismo.</p>
<p>Los usuarios pueden especificar la mÃ¡xima tarifa que estÃ¡n dispuestos a pagar por una transacciÃ³n a travÃ©s del campo <code>max_fee</code>.</p>
<p>La Ãºnica limitaciÃ³n en el secuenciador (impuesta por Starknet OS) es que la tarifa real cobrada estÃ¡ acotada por <code>max_fee</code>, pero por ahora, StarkWareâ€™s secuenciador solo cobrarÃ¡ la tarifa requerida para cubrir el costo de la prueba (potencialmente menos que la tarifa mÃ¡xima).</p>
<p>Actualmente, el secuenciador solo tiene en cuenta los costos de L1 relacionados con la presentaciÃ³n de la prueba. Hay dos componentes que afectan el rastro de L1 de una transacciÃ³n:</p>
<ol>
<li>
<p><strong>Complejidad computacional</strong>: cuanto mÃ¡s pesada sea la transacciÃ³n, mayor serÃ¡ su parte en el costo de verificaciÃ³n de la prueba.</p>
</li>
<li>
<p><strong>Datos en cadena</strong>: costo de datos de L1 originados por la disponibilidad de datos y mensajes de L2 â†’ L1.</p>
</li>
</ol>
<p>Las unidades de tarif estÃ¡n denominadas en <strong>ETH</strong>, <em>(esto puede cambiar en versiones futuras)</em>. Cada transacciÃ³n estÃ¡ asociada con una estimaciÃ³n de gas, y al combinar esto con el precio del gas, se obtiene la tarifa estimada.</p>
<h2 id="descripciÃ³n-general-de-alto-nivel"><a class="header" href="#descripciÃ³n-general-de-alto-nivel">DescripciÃ³n general de alto nivel</a></h2>
<p>Analicemos la mÃ©trica correcta para medir la complejidad de una transacciÃ³n. Para simplificar, ignoraremos las funciones incorporadas de Cairo con fines de explicaciÃ³n, y luego veremos cÃ³mo abordarlas.</p>
<h3 id="sin-builtins-incorporados"><a class="header" href="#sin-builtins-incorporados">Sin builtins incorporados</a></h3>
<p>Recordemos que la ejecuciÃ³n de un programa Cairo produce una traza de ejecuciÃ³n. Al probar un bloque de Starknet, agregamos todas las transacciones que aparecen en ese bloque a la traza de ejecuciÃ³n.</p>
<p>El Prover de Starknet genera pruebas para trazas de ejecuciÃ³n, con una longitud mÃ¡xima <strong><code>L</code></strong>, derivada de las especificaciones de la mÃ¡quina de pruebas y la latencia de la prueba deseada.</p>
<p>Es sencillo hacer un seguimiento de la longitud de la traza de ejecuciÃ³n asociada con cada transacciÃ³n. Cada operaciÃ³n sobre field elements <em>(como verificar la suma/multiplicaciÃ³n sobre el field)</em> requiere el mismo nÃºmero constante de celdas de traza (trace cells). </p>
<p>Cuando mencionamos <strong>sin builtin incorporados</strong> nos referimos a un escenario en el que todas las operaciones en el programa Cairo son operaciones bÃ¡sicas y no implican el uso de funciones mÃ¡s complejas, como las que encontramos <strong>con builtin incorporados</strong>. En esta situaciÃ³n, la ejecuciÃ³n de una operaciÃ³n simple, como una suma, requerirÃ¡ menos celdas de traza que una operaciÃ³n mÃ¡s compleja como la funciÃ³n Pedersen. Es evidente que la funciÃ³n Pedersen ocuparÃ¡ mÃ¡s celdas de traza debido a su naturaleza mÃ¡s compleja en comparaciÃ³n con una simple suma.</p>
<h3 id="con-builtins-incorporados"><a class="header" href="#con-builtins-incorporados">Con builtins incorporados</a></h3>
<p>La traza de ejecuciÃ³n de Cairo estÃ¡ separada, y cada builtin incorporado tiene su propia ranura. Debemos tener en cuenta esta asignaciÃ³n de ranura al determinar la tarifa.</p>
<p>Repasemos primero un ejemplo concreto. Imagina que la traza de ejecuciÃ³n tiene una capacidad mÃ¡xima que ocuparÃ¡ el Prover:</p>
<ul>
<li>500.000.000 pasos de Cairo</li>
<li>20.000.000 hashes de Pedersen</li>
<li>4.000.000 verificaciones de firma</li>
<li>10.000.000 comprobaciones de rango</li>
</ul>
<p>La prueba se cerrarÃ¡ y se enviarÃ¡ a L1 cuando cualquiera de estos componentes se llene. </p>
<blockquote>
<p>Es importante darse cuenta de que la divisiÃ³n en funciones incorporadas debe estar predeterminada. No podemos decidir sobre la marcha tener una prueba con <strong>20.000.001 Pedersen</strong>.</p>
</blockquote>
<p>Supongamos, por ejemplo, que una transacciÃ³n utiliza <strong>10.000 pasos de Cairo</strong> y <strong>500 hashes de Pedersen</strong>. Podemos acomodar como mÃ¡ximo <strong>40.000 transacciones</strong> de este tipo en nuestro rastro hipotÃ©tico <strong>(20.000.000/500)</strong>. Por lo tanto, la tarifa de la transacciÃ³n se relaciona con <strong>1/40.000</strong> del costo de enviar la prueba.</p>
<p>Es importante notar que el nÃºmero de pasos de Cairo no es el factor limitante en esta estimaciÃ³n del rendimiento de la transacciÃ³n <em>(ya que <strong>500,000,000/10,000 &gt; 20,000,000/500</strong>)</em>. Con este ejemplo en mente, ahora podemos formular la tarifa exacta asociada con el cÃ³mputo de L2.</p>
<h3 id="caso-general"><a class="header" href="#caso-general">Caso general</a></h3>
<p>Para cada transacciÃ³n, el secuenciador calcula un vector <code>CairoResourceUsage</code> que contiene:</p>
<ul>
<li>NÃºmero de pasos de Cairo</li>
<li>NÃºmero de aplicaciones de cada funciÃ³n incorporada de Cairo (por ejemplo, cinco comprobaciones de rango y dos hashes de Pedersen)</li>
</ul>
<p>El secuenciador cruza esta informaciÃ³n con el vector <code>CairoResourceFeeWeights</code>. Para cada tipo de recurso (paso o una aplicaciÃ³n especÃ­fica de funciÃ³n incorporada), <code>CairoResourceFeeWeights</code> tiene una entrada que especifica el costo de gas relativo de ese componente en la prueba.</p>
<p>Volviendo al ejemplo anterior, si el costo de enviar una prueba con <strong>20.000.000 hashes de Pedersen</strong> es aproximadamente <strong>5m</strong> de gas, entonces el nÃºmero de pasos de la funciÃ³n incorporada de Pedersen es <strong>0.2 gas</strong> por aplicaciÃ³n (<strong>5,000,000/20,000,000</strong>). El secuenciador tiene un vector de pasos predefinidos, de acuerdo con los parÃ¡metros de la prueba.</p>
<p>El secuenciador cobrarÃ¡ solo segÃºn el factor limitante. Por lo tanto, la tarifa estÃ¡ correlacionada con:</p>
<p><img src="./assets//Fee.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Donde <code>k</code> enumera los componentes de recursos de Cairo, es decir, el nÃºmero de pasos y funciones incorporadas utilizados.</p>
<p>Los pasos son:</p>
<ul>
<li><strong>Paso de Cairo:</strong> 0.01 gas/paso</li>
<li><strong>Pedersen:</strong> 0.32 gas/aplicaciÃ³n</li>
<li><strong>Poseidon:</strong> 0.32 gas/aplicaciÃ³n</li>
<li><strong>ComprobaciÃ³n de rango:</strong> 0.16 gas/aplicaciÃ³n</li>
<li><strong>ECDSA:</strong> 20.48 gas/aplicaciÃ³n</li>
<li><strong>Bitwise:</strong> 0.64 gas/aplicaciÃ³n</li>
<li><strong>EC_OP:</strong> 10.24 gas/aplicaciÃ³n</li>
</ul>
<h2 id="datos-on-chain"><a class="header" href="#datos-on-chain">Datos On-Chain</a></h2>
<p>Los datos en cadena asociados con una transacciÃ³n estÃ¡n compuestos por tres partes:</p>
<ul>
<li>Actualizaciones de Storage.</li>
<li>Mensajes L2 â†’ L1.</li>
<li>Contratos implementados.</li>
</ul>
<h3 id="actualizaciones-de-storage"><a class="header" href="#actualizaciones-de-storage">Actualizaciones de Storage</a></h3>
<p>Cuando una transacciÃ³n actualiza una clave en el almacenamiento de algÃºn contrato, los siguientes datos llegan a L1:</p>
<ul>
<li>Contract_address</li>
<li>NÃºmero de claves actualizadas en ese contrato</li>
<li>Clave para actualizar</li>
<li>Nuevo valor</li>
</ul>
<blockquote>
<p>Nota: Solo el valor mÃ¡s reciente llega a L1. Es decir, la tarifa de la transacciÃ³n solo depende del nÃºmero de actualizaciones de storage Ãºnicas (si la misma celda de storage se actualiza varias veces dentro de la transacciÃ³n, la tarifa sigue siendo la de una Ãºnica actualizaciÃ³n).</p>
</blockquote>
<p>La tarifa de actualizaciÃ³n de storage asociada para una transacciÃ³n que actualiza <code>n</code> contratos Ãºnicos y <code>m</code> claves Ãºnicas es:</p>
<p><img src="./assets//Fee1.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Donde <code>cw</code> es el costo de <code>calldata</code> (en gas) por palabra de 32 bytes.</p>
<blockquote>
<p>Nota: Hay muchas posibles mejoras a la estimaciÃ³n pesimista anterior que se presentarÃ¡n gradualmente en futuras versiones de Starknet. Por ejemplo, si diferentes transacciones dentro del mismo bloque actualizan la misma celda de almacenamiento, no es necesario cobrar ambas (solo el valor mÃ¡s reciente llega a L1). En el futuro, Starknet podrÃ­a incluir un mecanismo de reembolso para tales casos.</p>
</blockquote>
<h3 id="mensajes-l2--l1"><a class="header" href="#mensajes-l2--l1">Mensajes L2 â†’ L1</a></h3>
<p>Cuando se realiza una transacciÃ³n que invoca la llamada del sistema <code>send_message_to_l1</code> y se incluye en una actualizaciÃ³n de estado, los siguientes datos llegan a la capa L1 (capa de destino):</p>
<ol>
<li>
<p><strong>L2 sender address:</strong> Es la direcciÃ³n del remitente en la capa L2, es la direcciÃ³n de la entidad o contrato en la capa 2 que iniciÃ³ la transacciÃ³n o enviÃ³ el mensaje.</p>
</li>
<li>
<p><strong>L1 destination address:</strong> Es la direcciÃ³n de destino en la capa L1. Esta direcciÃ³n indica el contrato o entidad en la capa 1 que recibirÃ¡ el mensaje enviado desde la capa 2.</p>
</li>
<li>
<p><strong>Payload size:</strong> Es el tamaÃ±o del contenido Ãºtil o informaciÃ³n que se envÃ­a en el mensaje. Representa la cantidad de datos que se transmiten desde la capa 2 a la capa 1.</p>
</li>
<li>
<p><strong>Payload <em>(lista de field element)</em>:</strong> Es la lista de elementos o datos que constituyen el contenido Ãºtil o payload del mensaje enviado desde la capa 2 a la capa 1.</p>
</li>
</ol>
<p>En cuanto a la tarifa asociada con un solo mensaje de la capa L2 a la capa L1, se calcula utilizando la siguiente fÃ³rmula:</p>
<p><img src="./assets//Fee2.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Donde:</p>
<ul>
<li><code>gas_price</code> es el precio del gas (unidad de costo) establecido en la transacciÃ³n.</li>
<li><code>cw</code> es el costo de calldata (datos de llamada) en gas por palabra de 32 bytes.</li>
<li><code>payload_size</code> es el tamaÃ±o del contenido Ãºtil o payload del mensaje en bytes.</li>
</ul>
<p>Esta fÃ³rmula te permite determinar el costo total de enviar un mensaje desde la capa L2 a la capa L1, tomando en cuenta el precio del gas, el costo de calldata y el tamaÃ±o del contenido enviado.</p>
<h3 id="contratos-implementados"><a class="header" href="#contratos-implementados">Contratos implementados</a></h3>
<p>Cuando una transacciÃ³n que eleva la llamada del sistema <code>deploy</code> se incluye en una actualizaciÃ³n de estado, los siguientes datos llegan a L1:</p>
<ul>
<li><strong>DirecciÃ³n del contrato.</strong></li>
<li><strong>Class Hash.</strong></li>
</ul>
<p>La tarifa asociada con una implementaciÃ³n Ãºnica es:</p>
<p><img src="./assets//Fee3.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Donde <code>cw</code> es el costo de calldata (en gas) por palabra de 32 bytes.</p>
<h2 id="tarifa-total"><a class="header" href="#tarifa-total">Tarifa total</a></h2>
<p>La tarifa para una transacciÃ³n con:</p>
<ul>
<li>La utilizaciÃ³n de Cairo se representa mediante el vector <code>v</code>, donde las entradas de <code>v</code> corresponden al nÃºmero de pasos y al nÃºmero de aplicaciones por builtin incorporado.</li>
<li><code>n</code> actualizaciones de contratos Ãºnicos</li>
<li><code>m</code> actualizaciones de claves Ãºnicas</li>
<li><code>t</code> mensajes con tamaÃ±os de carga <code>q1,...,qt</code></li>
<li><code>â„“</code> implementaciones de contratos</li>
</ul>
<p>EstÃ¡ dada por:</p>
<p><img src="./assets//Fee4.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>Donde <code>w</code> es el vector de pasos discutido anteriormente y <code>cw</code> es el costo de calldata (en gas) por palabra de 32 bytes.</p>
<p>La tarifa se cobra atÃ³micamente durante la ejecuciÃ³n de la transacciÃ³n en L2. El SO de Starknet realiza una transferencia del ERC-20 asociado con la tarifa, con una cantidad igual a la tarifa pagada, utilizando al remitente de la transacciÃ³n como emisor y al secuenciador como receptor.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sierra---ir"><a class="header" href="#sierra---ir">Sierra - IR</a></h1>
<p>En este apartadao detallaremos mÃ¡s la sintÃ¡xis del lenguague que su de finiciÃ³n de IR, que podra revisar en la <a href="">secciÃ³n</a></p>
<ul>
<li><strong>Variables mutables:</strong> En un lenguaje de programaciÃ³n tradicional, cada variable estÃ¡ asociada con una celda de memoria especÃ­fica, una ubicaciÃ³n en la memoria de la computadora donde se almacenan los datos de la variable. Cuando a una variable se le asigna un valor, el valor se almacena en la celda de memoria asociada con esa variable. La variable puede acceder o modificar el valor almacenado en esa celda de memoria durante la ejecuciÃ³n del programa.</li>
</ul>
<p>Sin embargo, en Cairo, es imposible modificar el contenido de una celda de memoria a la que ya se ha escrito.</p>
<p>Las variables mutables son el azÃºcar sintÃ¡ctico que permite a los desarrolladores de El Cairo modificar y actualizar sin esfuerzo los valores de datos a lo largo de la ejecuciÃ³n de un programa sin tener que seguir manualmente la variable declarada anteriormente. Cuando modificamos nuestra variable mutable x, la variable Sierra correspondiente que almacena su valor se descarta primero ya que ya no se usa, y luego se crea una nueva variable con el valor actualizado</p>
<p>Del mismo modo, para una variable no mutable y, cuyo valor estÃ© sombreado, el procedimiento en Sierra es exactamente el mismo: el valor anterior se cae y uno nuevo se instancia con el valor actualizado asociado con y. Sin embargo, se recomienda usar variables mutables en lugar de sombrear donde sea posible, ya que garantiza la consistencia en los tipos.</p>
<ul>
<li>
<p><strong>Referencias:</strong> En los idiomas tradicionales, â€œpass-by-referenceâ€ es un mÃ©todo para pasar variables a funciones donde la funciÃ³n recibe una referencia a la ubicaciÃ³n de memoria de la variable. Esto permite que la funciÃ³n modifique el valor de la variable directamente. En Cairo, el equivalente se logra utilizando el ref modificador al definir el parÃ¡metro de funciÃ³n. Sin embargo, como se dijo anteriormente, es esencial tener en cuenta que una vez que los valores variables asignados no se pueden modificar directamente en Cairo, a diferencia de otros idiomas.</p>
</li>
<li>
<p><strong>Snapshot:</strong> En el lenguaje de programaciÃ³n de Cairo, las instantÃ¡neas se introducen como un tipo de envoltura que crea una vista inmutable de un objeto en un momento dado. Las instantÃ¡neas son Ãºtiles cuando necesitamos realizar en tipos no duplicables como matrices. En la implementaciÃ³n del tiempo de ejecuciÃ³n, las instantÃ¡neas son abstracciÃ³n de costo cero debido al modelo de memoria escrita de la Asamblea de Cairo.</p>
</li>
</ul>
<p>En el <a href="https://github.com/starkware-libs/cairo/blob/main/crates/cairo-lang-sierra/src/extensions/modules/snapshot.rs#L37">crates cairo-lang-sierra</a>, aprendemos que una instantÃ¡nea es solo una envoltura alrededor de un objeto que garantiza que el objeto original no se modifique. los snapshot_take libfunc solo devuelve una instantÃ¡nea al tipo si el tipo no se puede copiar. Los tipos duplicables son su propia instantÃ¡nea, ya que la instantÃ¡nea en sÃ­ misma es inÃºtil si podemos duplicar el valor. Este concepto de instantÃ¡neas solo existe en el nivel Sierra y hace que el sistema de tipo lineal sea efectivo al garantizar que el objeto envuelto en una instantÃ¡nea no pueda modificarse.</p>
<p>Pero, Â¿cuÃ¡ndo encontramos instantÃ¡neas particularmente Ãºtiles? EspecÃ­ficamente cuando se trabaja con tipos no duplicables como Arrays. En el siguiente cÃ³digo, una funciÃ³n foo toma como parÃ¡metro una matriz a. Una instantÃ¡nea de esta matriz se pasa a dos funciones, y luego se devuelve la matriz.</p>
<p>Cuando una funciÃ³n lleva una instantÃ¡nea a un valor usando @, solo puede leer el valor y no modificarlo. Se comporta como un prÃ©stamo inmutable usando &amp; en Rust, que permite que varias partes del programa lean el mismo valor simultÃ¡neamente y se asegura de que no se modifique. Cuando trabaja con objetos no copiables, el uso de instantÃ¡neas le permite retener la propiedad del objeto en el contexto de llamada y garantizar que el objeto permanezca inalterado.</p>
<ul>
<li><strong>Function inlining:</strong> La combinaciÃ³n de funciones es una tÃ©cnica de optimizaciÃ³n del compilador que sustituye una llamada de funciÃ³n con el cÃ³digo real de la funciÃ³n que se llama. Elimina la sobrecarga de una llamada de funciÃ³n integrando el cÃ³digo de la funciÃ³n directamente en la funciÃ³n de llamada.</li>
</ul>
<p>El compilador de El Cairo reemplazarÃ¡ automÃ¡ticamente las llamadas a funciones marcadas como en lÃ­nea directamente con su cÃ³digo Sierra. Esta optimizaciÃ³n es especialmente Ãºtil para funciones pequeÃ±as frecuentemente llamadas. Inlining puede reducir la sobrecarga de las llamadas a funciones y conducir a ejecuciones mÃ¡s rÃ¡pidas y optimizadas, ya que los valores no necesitan ser recordados.</p>
<p>Resumen: Hemos explorado algunos conceptos centrales de El Cairo 1, como variables mutables, referencias e instantÃ¡neas. Hemos visto cÃ³mo las variables mutables en El Cairo son equivalentes a las variables sombreadas en Sierra y cÃ³mo las referencias en El Cairo usan el ref prefijo para pasar variables e implÃ­citamente devolverlas. AdemÃ¡s, hemos visto cÃ³mo las instantÃ¡neas en El Cairo son un concepto Ãºnico que permite a los desarrolladores mantener la propiedad de los objetos al tiempo que garantiza que el valor original permanezca sin modificar. Finalmente, exploramos cÃ³mo los desarrolladores pueden usar la funciÃ³n como una tÃ©cnica de optimizaciÃ³n.</p>
<p>Cairo = Mejoras unicas en cairo?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cairo-native---mlir"><a class="header" href="#cairo-native---mlir">Cairo Native - MLIR</a></h1>
<p>MLIR significa <code>(Intermediate Representation for Multi-Level Intermediate Representations)</code>, (RepresentaciÃ³n Intermedia MÃºltiNivel). Se refiere a un lenguaje de representaciÃ³n intermedia diseÃ±ado para ser flexible y adaptable a diferentes requisitos en una infraestructura unificada.</p>
<p>A diferencia de <a href="https://llvm.org/docs/LangRef.html#introduction">LLVM IR</a>, que tiene una Ãºnica representaciÃ³n intermedia central que abarca un conjunto completo de instrucciones para representar programas de CPU/GPU, MLIR adopta un enfoque diferente. En MLIR, no existe una Ãºnica representaciÃ³n intermedia unificada.</p>
<blockquote>
<p>MLIR tiene como objetivo abordar la fragmentaciÃ³n del software, mejorar la compilaciÃ³n de hardware heterogÃ©neo, reducir significativamente el costo de construir compiladores especÃ­ficos de dominio y ayudar a conectar compiladores existentes.</p>
</blockquote>
<p>En su lugar, MLIR introduce conceptos abstractos como dialectos, operaciones y regiones. Estos conceptos permiten la definiciÃ³n de diferentes dialectos o lenguajes especializados, cada uno con su propio conjunto de operaciones y reglas semÃ¡nticas especÃ­ficas.</p>
<p>La idea detrÃ¡s de MLIR es brindar una infraestructura flexible que pueda adaptarse a mÃºltiples requisitos y necesidades en el Ã¡mbito de la representaciÃ³n intermedia. Esto significa que se pueden definir dialectos especÃ­ficos para diferentes dominios, como procesadores especÃ­ficos, aceleradores o incluso lenguajes de programaciÃ³n especÃ­ficos.</p>
<p>En resumen, MLIR busca proporcionar una forma flexible y modular de representar programas en un nivel intermedio, permitiendo la adaptabilidad a diferentes requisitos y escenarios mediante el uso de dialectos y operaciones especÃ­ficas de cada dominio.</p>
<blockquote>
<p>En otras palabras, si LLVM IR estÃ¡ centralizado por la naturaleza y favorece los flujos unificados del compilador, la infraestructura MLIR y su ecosistema de dialecto estÃ¡n descentralizados por la naturaleza y favorecen los diversos flujos del compilador. Lo que es bastante poderoso es que MLIR permite representar diferentes niveles utilizando la misma infraestructura, para que el flujo entre diferentes niveles pueda ser continuo.</p>
</blockquote>
<p>La mayorÃ­a de los protocolos ZKP implican aritmetizaciÃ³n, que es el proceso de representar el cÃ¡lculo en un formato numÃ©rico que puede utilizar el sistema de prueba, generalmente tomando las instrucciones en el cÃ¡lculo y construyendo un grÃ¡fico de expresiÃ³n de operaciones en bits llamado circuito aritmÃ©tico y luego generando un seguimiento de ejecuciÃ³n, que muy brevemente es una matriz de elementos de campo que representan la evoluciÃ³n del cÃ¡lculo a lo largo del tiempo. Este rastro de ejecuciÃ³n se alimenta al probador.</p>
<p>Para encapsular estos procesos, las mÃ¡quinas virtuales se han diseÃ±ado e implementado para generar estos rastros de ejecuciÃ³n numÃ©ricos y proporcionar garantÃ­as computacionales, como <a href="https://github.com/0xPolygonMiden/miden-vm?ref=notamonadtutorial.com">Miden</a> y <a href="https://github.com/lambdaclass/cairo-rs/pulls?ref=notamonadtutorial.com">cairo-rs</a>. Una vez que tenga una mÃ¡quina virtual, necesita un compilador y una representaciÃ³n intermedia.</p>
<p>Tampoco puede aceptar ningÃºn programa, ya que necesita saber que su ejecuciÃ³n es demostrable a menos que estÃ© dispuesto a asumir la posibilidad de programas no terminales, transacciones invÃ¡lidas que consumen gas excesivo, la producciÃ³n de trazas invÃ¡lidas o incompletas, y que el probador simplemente renuncie en el medio. La teorÃ­a de tipos y las representaciones intermedias dentro de los compiladores se han convertido en una de las herramientas mÃ¡s potentes para producir cÃ³digo que tiene propiedades que podemos razonar y verificar mecÃ¡nicamente.</p>
<p>En resumen, la necesidad de ejecutar hardware mÃ¡s diverso, incorporar tecnologÃ­a de lenguaje de programaciÃ³n, para permitir el uso fÃ¡cil de primitivas criptogrÃ¡ficas complejas, Para transportar garantÃ­as de herramientas de desarrolladores a capas de ejecuciÃ³n, todos se han unido para lograr un pequeÃ±o renacimiento de la implementaciÃ³n del lenguaje en el mundo criptogrÃ¡fico.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="herodotus---storage-proof"><a class="header" href="#herodotus---storage-proof">Herodotus - Storage Proof</a></h1>
<p>En el mundo de los sistemas descentralizados y la tecnologÃ­a blockchain, garantizar la precisiÃ³n y autenticidad de los datos es de suma importancia. A medida que el ecosistema evoluciona, se hace cada vez mÃ¡s necesario compartir informaciÃ³n a travÃ©s de diferentes cadenas, lo que lleva al desarrollo de soluciones innovadoras para verificar la integridad de los datos sin sacrificar la seguridad o la eficiencia. Una de esas soluciones es el uso de Storage Proof .</p>
<p>Las Storage Proof  ofrecen un mÃ©todo criptogrÃ¡fico para rastrear y compartir informaciÃ³n de blockchain a travÃ©s de cadenas, similar a los orÃ¡culos. Sin embargo, la diferencia clave radica en el modelo de confianza.</p>
<p>Las Storage Proof  proporcionan inherentemente una prueba de autenticidad sin depender de la confianza de terceros. En algunas situaciones, incluso pueden reemplazar o complementar los orÃ¡culos, allanando el camino para nuevos casos de uso y aplicaciones en el ecosistema blockchain.</p>
<p>Imagina que tienes un libro gigante lleno de informaciÃ³n y quieres demostrar que un dato concreto estÃ¡ en ese libro, en lugar de pedir a alguien que revise todo el libro para encontrar la informaciÃ³n, se utiliza un sistema inteligente (en nuestro caso, la criptografÃ­a) para crear una pequeÃ±a prueba que pueda demostrar fÃ¡cilmente la presencia de la informaciÃ³n en el libro. Esta prueba es lo que llamamos una Storage Proof.</p>
<p>En el contexto de las cadenas de bloques, estos libros gigantes son las bases de datos que almacenan todas las transacciones y datos de la red. Las Storage Proof permiten crear una prueba pequeÃ±a y verificable de que ciertos datos existen dentro del estado del blockchain en un momento determinado. Para ello se utilizan tÃ©cnicas criptogrÃ¡ficas incorporadas al propio almacenamiento.</p>
<p>Las cadenas de bloques utilizan varias estructuras de datos, como los Ã¡rboles Merkle, los Ã¡rboles Merkle Patricia y los Ã¡rboles Verkle, para comprometer criptogrÃ¡ficamente sus datos. Utilizando estas estructuras de datos, se pueden generar Storage Proof  para demostrar que una informaciÃ³n especÃ­fica forma parte de un estado determinado. Sin embargo, cuando se utilizan solas, estas pruebas pueden llegar a ser bastante grandes, lo que las hace poco prÃ¡cticas para la verificaciÃ³n en cadena. Para superar este problema, las Storage Proof  suelen combinarse con tÃ©cnicas criptogrÃ¡ficas avanzadas, como STARK o SNARK, para crear pruebas mÃ¡s pequeÃ±as y eficientes que puedan verificarse en cualquier dominio sin confiar en terceros. En su lugar, la seguridad y la confianza proceden de la propia blockchain subyacente.</p>
<p>Las Storage Proof  le permiten abrir compromisos criptogrÃ¡ficos de estado. Se pueden optimizar al unirlos con S [ N / T ] ARKS. . Estas pruebas de validez prueban que existÃ­a un estado en particular y que era vÃ¡lido en un bloque en particular en el pasado.</p>
<p>Fundamentalmente, las cadenas de bloques son bases de datos que contienen datos comprometidos criptogrÃ¡ficamente utilizando (Ã¡rboles Merkle, Ã¡rboles Merkle Patricia, Ã¡rboles Verkle, etc. ). Como todos los datos estÃ¡n comprometidos, podemos demostrar que cierta informaciÃ³n estÃ¡ encapsulada en un estado dado. Sin embargo, con esquemas de compromiso simples, el tamaÃ±o de esta prueba se vuelve mÃ¡s prominente a medida que el tamaÃ±o de los datos que incluye se hace mÃ¡s grande. Verificar tales pruebas en cadena se vuelve demasiado costoso para ser prÃ¡ctico.</p>
<p>Las Storage Proof , por otro lado, cuando se usan junto con <code>STARK</code> o <code>SNARK</code>, pueden ser relativamente pequeÃ±as y le permiten verificar un estado especÃ­fico, en un momento especÃ­fico y en cualquier dominio,  <code>sin confiar en un tercero</code>. En su lugar, confÃ­an en la seguridad de la cadena subyacente.</p>
<p>Â¿Por quÃ© es esto importante? Ethereum hoy no es la cadena monolÃ­tica simple (L1) que era hace varios aÃ±os. Con el advenimiento de las soluciones L2, los datos ahora se distribuyen en mÃºltiples cadenas.</p>
<p>Ya no se pueden hacer suposiciones sincrÃ³nicas sobre el estado de la cadena. Muchas soluciones para compartir datos ahora estÃ¡n en vivo, como los sistemas de mensajerÃ­a <code>L1 -&gt; L2</code>, puentes entre cadenas y orÃ¡culos. Pero el problema con estas soluciones actuales es que incluyen la confianza en un tercero, como los relevistas, los firmantes multisig y los comitÃ©s. Las Storage Proof  nos permiten validar el estado de una cadena de bloques en cualquier momento utilizando compromisos criptogrÃ¡ficos sin asumir la confianza de un tercero.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arquitectura-herodotus"><a class="header" href="#arquitectura-herodotus">Arquitectura Herodotus</a></h1>
<p>Cada despliegue de contratos inteligentes de HerÃ³doto que admite una cadena especÃ­fica consta de los siguientes contratos:</p>
<ol>
<li><strong>Commitments inbox:</strong>  Este contrato es responsable de procesar y verificar la validez de otros compromisos de la cadena, como bloqueos o raÃ­ces estatales.</li>
<li><strong>Headers store:</strong>  Esto contrata almacena y permite procesar encabezados desde un punto dado hasta la gÃ©nesis al afirmar que <code>blockhash(x - 1) = parenthash(x)</code>.</li>
<li><strong>Facts registry:</strong> Este contrato realiza la verificaciÃ³n de Storage Proof  y almacena los valores solicitados en su estado.</li>
</ol>
<p><img src="./assets/Herodotus.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commitments-inbox"><a class="header" href="#commitments-inbox">Commitments Inbox</a></h1>
<p>Cada vez que se accede a datos provenientes de un dominio diferente en otro dominio, se requiere un compromiso para asegurar su correcciÃ³n criptogrÃ¡fica. Estos compromisos pueden ser:</p>
<ol>
<li>State root</li>
<li>Block hash</li>
<li>Transactions root</li>
<li>Receipts root</li>
</ol>
<p>El contrato <code>CommitmentsInbox</code> se encarga de recibir y gestionar estos compromisos. Los compromisos pueden entregarse de diversas formas, como:</p>
<ol>
<li>Recibir mensajes asÃ­ncronos.</li>
<li>Validar el consenso de la red de manera verificable (disponible solo para L2 descentralizados).</li>
<li>Utilizar relayers optimistas.</li>
</ol>
<p>Una vez que un compromiso es aceptado por el <code>CommitmentsInbox</code>, se pasa al <code>HeadersStore</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="headers-store"><a class="header" href="#headers-store">Headers Store</a></h1>
<p>El contrato HeadersStore refleja los encabezados de las cadenas admitidas en el almacenamiento del state de este contrato. Estos encabezados solo pueden agregarse si el del encabezado <code>parentHash</code> ya ha sido pasado al <code>CommitmentsInbox</code>.</p>
<p>Cualquier persona puede enviar encabezados, pero un encabezado solo es vÃ¡lido si su hash calculado en la cadena coincide con el hash certificado previamente por el <code>CommitmentsInbox</code>.</p>
<p>Cada vez que se procesa un encabezado, se guarda el hash de su encabezado padre en el estado del contrato para permitir que el encabezado anterior en la cadena se procese de la misma manera.</p>
<p>Al procesar un bloque, sus parÃ¡metros pueden guardarse en el estado inteligente de los contratos. Cada cadena blockchain contiene diferentes parÃ¡metros en su encabezado. Por ejemplo, un encabezado de EVM en Ethereum L1 contiene las siguientes propiedades:</p>
<ul>
<li><a href="https://ethereum.org/en/developers/docs/gas/#base-fee"><strong>baseFeePerGas</strong></a></li>
<li><a href="https://ethereum.org/en/glossary/#difficulty"><strong>difficulty</strong></a></li>
<li><a href=""><strong>extraData</strong></a></li>
<li><a href="https://ethereum.org/en/glossary/#gas-limit"><strong>gasLimit</strong></a></li>
<li><a href=""><strong>gasUsed</strong></a></li>
<li><a href=""><strong>parentHash</strong></a></li>
<li><a href=""><strong>receiptsRoot</strong></a></li>
<li><a href=""><strong>transactionsRoot</strong></a></li>
<li><a href=""><strong>stateRoot</strong></a></li>
<li><a href=""><strong>timestamp</strong></a></li>
<li><a href=""><strong>logsBloom</strong></a></li>
<li><a href=""><strong>nonce</strong></a></li>
<li><a href=""><strong>miner</strong></a></li>
<li><a href=""><strong>mixHash</strong></a></li>
<li><a href=""><strong>sha3Uncles</strong></a></li>
<li><a href=""><strong>number</strong></a></li>
<li><a href=""><strong>extraData</strong></a></li>
</ul>
<p>La especificaciÃ³n de los parÃ¡metros que deben guardarse se realiza mediante un valor entero que codifica un mapa desde el Ã­ndice del parÃ¡metro hasta si debe guardarse o no. Los Ã­ndices para cada parÃ¡metro son:</p>
<ul>
<li><code>PARENT_HASH = 0</code></li>
<li><code>UNCLES_HASH = 1</code></li>
<li><code>MINER = 2</code></li>
<li><code>STATE_ROOT = 3</code></li>
<li><code>TRANSACTION_ROOT = 4</code></li>
<li><code>RECEIPTS_ROOT = 5</code></li>
<li><code>LOGS_BLOOM = 6</code></li>
<li><code>DIFFICULTY = 7</code></li>
<li><code>BLOCK_NUMBER = 8</code></li>
<li><code>GAS_LIMIT = 9</code></li>
<li><code>GAS_USED = 10</code></li>
<li><code>TIMESTAMP = 11</code></li>
<li><code>EXTRA_DATA = 12</code></li>
<li><code>MIX_HASH = 13</code></li>
<li><code>NONCE = 14</code></li>
<li><code>BASE_FEE = 15</code></li>
</ul>
<p>Por ejemplo, para establecer solo la <code>STATE_ROOT</code>, el valor para ese parÃ¡metro serÃ­a 8, ya que su representaciÃ³n binaria es <code>000000000001000</code>, lo cual es igual a <code>2^3</code>, donde <code>3</code> es el Ã­ndice de la <code>STATE_ROOT</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="facts-registry"><a class="header" href="#facts-registry">Facts Registry</a></h1>
<p>Este es el Ãºltimo contrato en la pila bÃ¡sica de Herodotus y optimiza el proceso de acceso a las propiedades de una cuenta, como:</p>
<p>Nonces (si estÃ¡n disponibles).</p>
<p>Saldos (si estÃ¡n disponibles).</p>
<p>Storage hash.</p>
<p>Code hash.</p>
<p>El primer nivel de almacenamiento en las blockchains basadas en cuentas son las propias cuentas. Para probarlas, es necesario tener acceso a la stateRoot, cuya correcciÃ³n se verifica mediante el contrato HeadersStore. Con dicha raÃ­z del estado, se puede verificar una prueba de MPT que demuestra las propiedades mencionadas de una cuenta.</p>
<p>Estas propiedades, de manera similar a HeadersStore, se pueden guardar en el estado para reducir la cantidad de cÃ¡lculos necesarios cada vez que se accede al almacenamiento del contrato inteligente.</p>
<p>Acceso al almacenamiento del contrato</p>
<p>Como se mencionÃ³ anteriormente, el primer nivel de almacenamiento son las cuentas. El segundo nivel es el almacenamiento real del contrato. Este almacenamiento se guarda en un Ã¡rbol Merkle Patricia Tree, donde la raÃ­z es el StorageHash de la cuenta. Al ser un Ã¡rbol Merkle Patricia, se puede probar cualquier cosa incluida en Ã©l.</p>
<p>Esto permite que Herodotus habilite el acceso al almacenamiento de los contratos inteligentes. El almacenamiento de los contratos inteligentes es una base de datos de clave-valor donde cada clave corresponde a 32 bytes de datos.</p>
<p>Para obtener mÃ¡s informaciÃ³n sobre cÃ³mo asignar un nombre de variable a su clave de almacenamiento, consulte la documentaciÃ³n de Solidity. Recomendamos encarecidamente utilizar esta guÃ­a cuando se trabaja con el diseÃ±o del almacenamiento de contratos inteligentes en Solidity.</p>
<div style="break-before: page; page-break-before: always;"></div><p>El uso de una API para solicitar Storage Proof  es sencillo, pero creemos que todavÃ­a no es lo suficientemente simple. Hoy anunciamos Herodotus Turbo ğŸ›°</p>
<p>Turbo permitirÃ¡ una interoperabilidad 100% sin confianza entre las capas 2 de Ethereum con solo escribir una lÃ­nea de cÃ³digo.</p>
<p>https://twitter.com/HerodotusDev/status/1682400907969822722</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="casos-de-usos"><a class="header" href="#casos-de-usos">Casos de Usos</a></h1>
<p>Dado que las Storage Proof  nos permiten comprimir eficientemente â€œ â€ una cadena de bloques y transmitir los datos a otra parte, tienen bastantes aplicaciones. El costo de verificaciÃ³n asequible, una propiedad integral de las Storage Proof , permite validar la prueba en el destino cadena, minimizando la necesidad de desarrollar sistemas de mensajerÃ­a entre cadenas.</p>
<p>Los casos de uso potencial incluyen:</p>
<ul>
<li><strong>Acceso a informaciÃ³n general</strong> de una cadena de otra sobre el estado y las transacciones en la cadena de bloques.</li>
<li><strong>Sistemas de votaciÃ³n entre cadenas simplificados</strong> Con frecuencia, los usuarios mantienen sus activos en una cadena A lenta pero mÃ¡s segura, pero se produce una votaciÃ³n basada en tokens en una cadena B con transacciones mÃ¡s baratas. Esto obliga al usuario a omitir su voto o pagar enormes tarifas de transacciÃ³n para unir sus activos de la A a la B, emitir su voto y luego obligarlos a la A. En tales casos, las Storage Proof  permiten a los usuarios probar su equilibrio de fichas en la cadena A en un bloque dado y emitir su voto a la perfecciÃ³n en la cadena B.</li>
<li><strong>Alternativa a los puentes entre cadenas.</strong> Actualmente, los puentes entre cadenas asumen un nivel de confianza en un tercero porque generalmente involucran a un intermediario, como un custodio o una organizaciÃ³n autÃ³noma descentralizada ( DAO ). Este intermediario es responsable de garantizar que el intermediario reciba una cierta cantidad de tokens en la cadena de origen y de mantener los activos en la cadena de origen. Posteriormente, las fichas correspondientes se acuÃ±an en la cadena de destino. Las Storage Proof  pueden permitir puentes sin confianza entre cadenas, ya que una aplicaciÃ³n de contrato inteligente en la cadena de destino podrÃ­a validar una transacciÃ³n en la que los activos se transfirieron al contrato inteligente del puente en la cadena de origen y acuÃ±ar los activos puenteados. Sin embargo,en muchos casos, la necesidad de transferir activos entre cadenas puede eliminarse ya que la propiedad de los activos en otra cadena podrÃ­a demostrarse simplemente con Storage Proof .</li>
<li><strong>UX mejorado para la abstracciÃ³n de la cuenta ( AA ) casos de uso.</strong> AA se ha implementado en diferentes cadenas y se considera una innovaciÃ³n crucial para incorporar a los primeros mil millones de usuarios al espacio blockchain. Con Storage Proof , las billeteras podrÃ­an incluir la funcionalidad adicional de restaurar el acceso solo si la billetera no enviÃ³ ninguna transacciÃ³n durante una larga duraciÃ³n. TambiÃ©n se podrÃ­an hacer cumplir verificaciones adicionales que requieren que algunos datos se utilicen de otras cadenas.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ejemplos-storage-proof"><a class="header" href="#ejemplos-storage-proof">Ejemplos Storage Proof</a></h1>
<p>Generar Storage Proof en cadenas compatibles con EVM es sencillo. Por ejemplo, la biblioteca Web3.js tiene la funciÃ³n <code>getProof</code> que puede generar pruebas del estado de un contrato en Ethereum (y otras cadenas compatibles con EVM como Polygon, BSC, L2 Optimism...). Una direcciÃ³n de contrato y la ranura de almacenamiento para el contrato deben ser pasados a la funciÃ³n.</p>
<p>En Ethereum, los contratos inteligentes utilizan un almacÃ©n de clave-valor para almacenar los datos en su almacÃ©n. Cada dato se almacena en una ubicaciÃ³n especÃ­fica conocida como <code>ranura de almacenamiento</code>. Las ranuras de almacenamiento son ubicaciones de memoria dentro del almacenamiento del contrato y se identifican mediante un Ã­ndice Ãºnico. Veamos un ejemplo de contrato inteligente con el siguiente cÃ³digo desplegado en la mainnet de Ethereum.</p>
<p><img src="./assets/storage.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>La variable owner se almacenarÃ­a en la ranura <code>0</code>. Ahora, para generar la prueba de que el owner de este contrato era una <code>direcciÃ³n A</code>, podemos utilizar la funciÃ³n <code>getProof</code> de la siguiente manera:</p>
<p><img src="./assets/storage1.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>El resultado del cÃ³digo anterior es algo parecido a esto:</p>
<p><img src="./assets/storage2.png" alt="graph" /></p>
<div align="center">
<em></em>
</div>
<p>El <code>storageProof</code> devuelto contiene la prueba de almacenamiento para la variable <code>owner</code>. Dado que Ethereum utiliza Merkle Patricia Trees para comprometer su estado, el estado de las cuentas y su almacenamiento, el almacenamiento generado puede ser utilizado para probar una ranura de almacenamiento (o estado de la cuenta). Sin embargo, como se ha indicado anteriormente, estas pruebas no son lo suficientemente escalables como para discutir las transferencias de mensajes entre cadenas, para ello el uso de complejas matemÃ¡ticas ZK sobre esto puede disminuir el cÃ¡lculo necesario para verificar la prueba.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proyectos-shh-y-hackaton"><a class="header" href="#proyectos-shh-y-hackaton">Proyectos SHH y Hackaton</a></h1>
<ul>
<li><a href="https://devfolio.co/projects/starksight-5d82"><strong>StarkSight:</strong></a> Use Worldcoin (Polygon) on Starknet. Storage proof of storage slot.</li>
<li><a href="https://643b0387a7ab7800083bb427--cosmic-unicorn-126e1a.netlify.app/"><strong>MAID:</strong></a> Proof of OG (Are you a long-time holder of this coin?). Historical storage proof of storage slot</li>
<li><a href="https://www.mergeswap.xyz/"><strong>Merge Swap:</strong></a> Use storage proof on PoW to PoS chain.</li>
</ul>
<h2 id="shh"><a class="header" href="#shh">SHH</a></h2>
<ul>
<li><a href="https://twitter.com/piapark_eth/status/1681312309032128515"><strong>Chess Dojo</strong></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merkle-mountain-ranges-en-cairo"><a class="header" href="#merkle-mountain-ranges-en-cairo">Merkle Mountain Ranges en Cairo</a></h1>
<p>Herodotus ha implementado una nueva estructura de datos criptogrÃ¡fica llamada Merkle Mountain Ranges (MMR) en Cairo. Las MMR son una lista de Ãrboles de Merkle, donde cada Ã¡rbol se representa como una montaÃ±a y la lista completa forma el rango.</p>
<p>Las MMR comparten las propiedades comunes de los Ãrboles de Merkle, como el almacenamiento eficiente de datos y la capacidad de generar pruebas de Merkle para demostrar la existencia de un elemento en el Ã¡rbol. Sin embargo, tambiÃ©n ofrecen ventajas adicionales, como la eficiencia en la adiciÃ³n y actualizaciÃ³n de elementos, detallemos algunas:</p>
<ul>
<li>La adiciÃ³n de un elemento a un MMR es mucho mÃ¡s eficiente, ya que en la mayorÃ­a de los casos no es necesario recorrer todo el Ã¡rbol. La complejidad subyacente es log2(n) <code>puntas de montaÃ±a</code>.</li>
<li>Las pruebas de Merkle en un MMR se realizan mediante pruebas de tamaÃ±o log2(n) que consisten en una ruta Merkle hasta la punta del Ã¡rbol.</li>
<li>La actualizaciÃ³n de un elemento tambiÃ©n se puede realizar de manera eficiente.</li>
<li>Es posible optimizar aÃºn mÃ¡s al comparar inserciones y actualizaciones.</li>
<li>Tanto las inserciones como las actualizaciones se pueden implementar en cadena, lo que garantiza una total transparencia sobre cÃ³mo se actualiza el Ã¡rbol.</li>
</ul>
<p>Con esta nueva estructura de datos en Cairo, buscamos mejorar la eficiencia y verificabilidad del almacenamiento de datos en la plataforma, haciÃ©ndola Ãºtil para diversas aplicaciones que requieren almacenamiento y verificaciÃ³n de datos en la cadena.</p>
<h2 id="esquema-de-firma-ecdsa-con-umbral"><a class="header" href="#esquema-de-firma-ecdsa-con-umbral">Esquema de firma ECDSA con umbral</a></h2>
<p>Algunas innovaciones que se irÃ¡n tratando como el esquema de firma ECDSA con umbral en bandeja de entrada de compromisos optimistas. </p>
<p>Para acceder al estado de diferentes cadenas, necesitamos acceder a las cabeceras de bloque, de las que podemos recuperar todo tipo de informaciÃ³n (incluido el estado). Tenemos varias estrategias para obtener las cabeceras de bloque de diferentes cadenas, una de las cuales es un protocolo MPC que ejecuta un algoritmo de firma ECDSA de umbral. La salida del protocolo es una Ãºnica firma que se validarÃ¡ en la cadena. Esto es mejor que tener una firma por parte, lo que es posible gracias a una ceremonia DKG (generaciÃ³n de clave distribuida).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-proof-vs-oracle"><a class="header" href="#storage-proof-vs-oracle">Storage Proof Vs Oracle</a></h1>
<p>Las cadenas de bloques estÃ¡n diseÃ±adas para no generar confianza, lo que significa que no pueden acceder intrÃ­nsecamente a datos fuera de la cadena. Esta limitaciÃ³n afecta a la capacidad de los contratos inteligentes para tomar decisiones basadas en eventos del mundo real o en informaciÃ³n histÃ³rica de la cadena de bloques. Como soluciÃ³n, se introdujeron los orÃ¡culos para proporcionar a los contratos inteligentes datos fuera de la cadena o resultados de cÃ¡lculos fuera de la cadena que consumen muchos recursos.</p>
<p>Los orÃ¡culos suelen requerir que un tercero, como una instituciÃ³n o una red descentralizada de operadores de nodos, envÃ­e datos a la cadena. Aunque esto introduce un nivel de confianza, varios equipos, como Pragma, estÃ¡n trabajando para minimizar este requisito de confianza.</p>
<p>Chainlink es un conocido orÃ¡culo de blockchain que proporciona datos del mundo real, servicios de cÃ¡lculo fuera de la cadena y servicios entre cadenas. Dado que los contratos inteligentes dependen actualmente de los orÃ¡culos para obtener datos del mundo real, los orÃ¡culos se han convertido en una parte crucial del ecosistema blockchain.</p>
<h2 id="pueden-los-orÃ¡culos-ser-sustituidos-o-mejorados-por-storage-proof"><a class="header" href="#pueden-los-orÃ¡culos-ser-sustituidos-o-mejorados-por-storage-proof">Â¿Pueden los orÃ¡culos ser sustituidos o mejorados por Storage Proof?</a></h2>
<p>En algunos casos, las Storage Proof pueden sustituir a los orÃ¡culos. Algunos datos proporcionados por los orÃ¡culos ya estÃ¡n disponibles en la cadena, y una prueba de almacenamiento puede eliminar la necesidad de confiar en un tercero, permitiendo que los contratos inteligentes se basen por completo en la seguridad de los compromisos criptogrÃ¡ficos. Sin embargo, en otros casos en los que las Storage Proof  no pueden sustituir completamente a los orÃ¡culos, pueden mejorarlos con una funcionalidad adicional:</p>
<ul>
<li>Las Storage Proof permiten realizar cÃ¡lculos sobre datos de diferentes fuentes y exportar los resultados a otras cadenas, haciendo posible que los orÃ¡culos transmitan informaciÃ³n a travÃ©s de mÃºltiples cadenas.</li>
<li>Las Storage Proof pueden facilitar una validaciÃ³n rentable en las cadenas de destino, ya que la cadena de origen preferida suele tener un cÃ¡lculo barato.</li>
<li>LÃ­deres en investigaciÃ³n, como Herodotus, permiten el acceso a datos entre dominios a travÃ©s de cadenas Ethereum utilizando Storage Proof y matemÃ¡ticas ZK. Pragma planea asociarse con Herodotus para soportar orÃ¡culos entre cadenas en un futuro prÃ³ximo.</li>
<li>Las Storage Proof pueden unificar el estado de mÃºltiples rollups e incluso permitir lecturas sÃ­ncronas entre capas Ethereum.</li>
<li>La recuperaciÃ³n fiable de datos histÃ³ricos de la cadena es otra mejora posible gracias a las Storage Proof . Las cadenas de bloques con estado, como Ethereum y Starknet, preservan criptogrÃ¡ficamente su estado a travÃ©s de estructuras de datos especializadas, lo que permite probar la inclusiÃ³n de datos. Esto permite a los contratos inteligentes acceder a informaciÃ³n que se remonta al bloque de gÃ©nesis.</li>
</ul>
<p>Pragma estÃ¡ explorando el desarrollo de un orÃ¡culo L3 en Starknet, que podrÃ­a permitir a otras cadenas extraer y verificar datos utilizando Storage Proof. Los beneficios de tener un orÃ¡culo L3 en una red computacionalmente barata como Starknet incluyen:</p>
<ul>
<li>Consenso mÃ¡s rÃ¡pido en bloques debido a la cadena L3 altamente personalizable, reduciendo significativamente la latencia de datos para el orÃ¡culo.</li>
<li>Transferencia asÃ­ncrona de datos de baja latencia a otras cadenas al alcanzar el consenso en la cadena de origen, en combinaciÃ³n con Storage Proof .</li>
<li>Mayor confianza en los datos mediante un sistema incorporado para penalizar a los proveedores de datos deshonestos. Los proveedores de datos en la L3 podrÃ­an poner en juego sus activos como garantÃ­a de la exactitud de los datos. Como toda la red L3 debe alcanzar un consenso antes de que otras cadenas puedan utilizar los datos, los datos del orÃ¡culo pueden considerarse garantizados por la apuesta de los validadores en L3.</li>
</ul>
<p>La creciente adopciÃ³n de soluciones L2 de Ethereum, como Starknet, Optimism y Arbitrum, ha permitido vislumbrar el futuro del sector. Sin embargo, un reto clave que impide un mayor crecimiento es la implementaciÃ³n de un sistema descentralizado de mensajerÃ­a entre cadenas, las Storage Proof tienen un enorme potencial para resolver este problema.</p>
<p>En algunos casos, las Storage Proof pueden sustituir o mejorar los orÃ¡culos, facilitando una comunicaciÃ³n entre cadenas mÃ¡s eficiente y el acceso a datos histÃ³ricos. Al reducir la dependencia de la confianza en terceros, las Storage Proof  pueden reforzar significativamente la seguridad y la eficiencia de las aplicaciones de blockchain.</p>
<p>A medida que el panorama de las cadenas de bloques siga evolucionando, podemos anticipar nuevos desarrollos e innovaciones en Storage Proof, orÃ¡culos y comunicaciÃ³n entre cadenas. Aprovechando estas tecnologÃ­as, el ecosistema blockchain puede mantener su crecimiento y ofrecer mÃ¡s valor tanto a los usuarios como a los desarrolladores.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estado-de-oracles-en-starknet"><a class="header" href="#estado-de-oracles-en-starknet">Estado de Oracles en Starknet</a></h1>
<p>En la red de pruebas de Starknet, Chainlink proporciona datos de precios para siete pares de criptomonedas y se ha asociado con Starkware para acelerar el desarrollo y crecimiento de aplicaciones en el ecosistema de Starknet. Chainlink minimiza los supuestos de confianza a travÃ©s de una red descentralizada de nodos, pero la agregaciÃ³n de datos se produce fuera de la cadena.</p>
<p>Pragma y Stork Network son dos importantes proveedores de orÃ¡culos en Starknet, que operan tanto en la mainnet como en la testnet. Ofrecen tickers de precios para mÃºltiples pares de criptomonedas, y Pragma estÃ¡ trabajando en la implementaciÃ³n de una fuente de aleatoriedad verificable en la mainnet para una aleatoriedad segura en la cadena. Las fuentes de precios de Pragma se basan en envÃ­os de grandes instituciones y creadores de mercado, aprovechando la eficiente tecnologÃ­a ZK para la agregaciÃ³n de precios en la cadena.</p>
<p>En resumen, tanto las Storage Proof  como los orÃ¡culos son cruciales para facilitar la comunicaciÃ³n entre cadenas y el acceso a datos fuera de la cadena. Mientras que los orÃ¡culos son indispensables para los datos del mundo real, las Storage Proof  ofrecen una forma fiable y eficiente de transferir y verificar la informaciÃ³n de la cadena de bloques entre cadenas. Juntos, ayudan a crear un ecosistema de cadenas de bloques mÃ¡s sÃ³lido e interconectado.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pragma---bases"><a class="header" href="#pragma---bases">Pragma - Bases</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainlink---bases"><a class="header" href="#chainlink---bases">Chainlink - Bases</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="exploradores-de-bloques-"><a class="header" href="#exploradores-de-bloques-">Exploradores de Bloques ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starkscan-"><a class="header" href="#starkscan-">Starkscan ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="voyager-"><a class="header" href="#voyager-">Voyager ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="madara-"><a class="header" href="#madara-">Madara ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elixir-"><a class="header" href="#elixir-">Elixir ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="view-block-"><a class="header" href="#view-block-">View Block ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cairo---arquitectura"><a class="header" href="#cairo---arquitectura">Cairo - Arquitectura</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sintÃ¡xis-bÃ¡sica"><a class="header" href="#sintÃ¡xis-bÃ¡sica">SintÃ¡xis BÃ¡sica</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cairo-v2---nueva-versiÃ³n-del-compilador"><a class="header" href="#cairo-v2---nueva-versiÃ³n-del-compilador">Cairo v2 - Nueva versiÃ³n del Compilador</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>https://twitter.com/nodeguardians/status/1682410394864832514</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducciÃ³n-parte-3"><a class="header" href="#introducciÃ³n-parte-3">IntroducciÃ³n Parte 3</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="otras-arquitecturas"><a class="header" href="#otras-arquitecturas">Otras Arquitecturas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambda-en-starknet-"><a class="header" href="#lambda-en-starknet-">Lambda en Starknet ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-en-rust-"><a class="header" href="#starknet-en-rust-">Starknet en Rust ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambda-prover---platinum-"><a class="header" href="#lambda-prover---platinum-">Lambda Prover - Platinum ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambda-sequencer-"><a class="header" href="#lambda-sequencer-">Lambda Sequencer ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdaworks-"><a class="header" href="#lambdaworks-">LambdaWorks ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="madara---exploraciÃ³n-de-su-arquitectura-"><a class="header" href="#madara---exploraciÃ³n-de-su-arquitectura-">Madara - ExploraciÃ³n de su Arquitectura ğŸš§</a></h1>
<p>En este capÃ­tulo realizaremos un anÃ¡lisis exhaustivo de la arquitectura de Madara, este componente fundamental desempeÃ±arÃ¡ un papel vital en el ecosistema de Starknet, destacÃ¡ndose por su enfoque en el escalado fractal y la modularidad dentro del mundo de las blockchains. Antes de sumergirnos en las intrincadas capas de Madara, es recomendable revisar los cimientos y las definiciones clave, las cuales estÃ¡n detalladas en el apartado <a href="/Book-Starkware/src/Madara_Base.html#madara---bases-de-su-arquitectura">Base Madara</a> de la Parte 2 del Libro de L2 sobre la Arquitectura de Starknet y Cairo.</p>
<p>La esencia de Madara se fusiona con la plataforma Substrate, un framewrok de innovaciÃ³n en la cadena de bloques que se erige como el fundamento de Madara. Las Chains montadas con Substrate se representan como una combinaciÃ³n de tres tecnologÃ­as fundamentales: </p>
<ul>
<li>
<p><strong>WebAssembly:</strong> Wasm es un formato binario de instrucciones diseÃ±ado para una mÃ¡quina virtual basada en pilas. Su principal propÃ³sito es servir como un objetivo de compilaciÃ³n portÃ¡til para diversos lenguajes de programaciÃ³n, lo que facilita su implementaciÃ³n en aplicaciones tanto de cliente como de servidor en la web.</p>
</li>
<li>
<p><strong>Libp2p:</strong> Es una colecciÃ³n de protocolos, especificaciones y herramientas que facilitan la construcciÃ³n de redes descentralizadas y resistentes a la censura en el Ã¡mbito de la web. Esta biblioteca estÃ¡ diseÃ±ada para brindar una capa de comunicaciÃ³n peer-to-peer eficiente y flexible, permitiendo que los nodos se conecten y se comuniquen de manera segura a travÃ©s de una variedad de redes y protocolos subyacentes. Libp2p se adapta a una amplia gama de aplicaciones, desde sistemas de almacenamiento distribuido hasta redes de transmisiÃ³n de datos, lo que lo convierte en un componente esencial para la arquitectura de Madara y su integraciÃ³n con Starknet.</p>
</li>
<li>
<p><strong>GRANDPA:</strong> Es la abreviatura de (GHOST-based Recursive Ancestor Deriving Prefix Agreement), un componente de vital importancia que desempeÃ±a un rol crucial similar a una &quot;llave maestra&quot; para los clientes de cadenas de bloques basadas en Substrate. Podemos definir este algoritmo de finalizaciÃ³n que intenta conseguirel  equilibrio perfecto entre velocidad y seguridad en el intrincado proceso de consenso. Su enfoque innovador se centra en el concepto de votar por bloques vÃ¡lidos y, de manera progresiva y transitiva, aplicar esos votos a lo largo de las generaciones de bloques ancestrales. Esta estrategia inteligente permite la finalizaciÃ³n de bloques al lograr una supermayorÃ­a de votos, lo que asegura una finalidad asincrÃ³nica y, ademÃ¡s, otorga adaptabilidad ante diversas condiciones de la red.</p>
<p>La distinciÃ³n de GRANDPA se manifiesta en su capacidad excepcional para finalizar mÃºltiples bloques de manera simultÃ¡nea, una caracterÃ­stica que confirma su resiliencia incluso en circunstancias de particiones prolongadas en la red. En un esfuerzo por mantener la integridad del proceso, aquellos participantes que emiten votos contradictorios son detectados y enfrentan consecuencias mediante un protocolo meticuloso de desafÃ­o y respuesta. Un aspecto digno de menciÃ³n es la flexibilidad de GRANDPA para asignar pesos individuales a nodos, considerando factores como la cantidad apostada en el protocolo. Esta capacidad de personalizaciÃ³n potencia la influencia de los nodos en el proceso de finalizaciÃ³n, contribuyendo a un consenso robusto y equilibrado.</p>
<p>En esencia, GRANDPA fusiona magistralmente la estructura misma de la cadena de bloques con el intrincado proceso de consenso, generando asÃ­ un mecanismo seguro y responsable de finalizaciÃ³n. La habilidad para concluir mÃºltiples bloques, adaptarse Ã¡gilmente a condiciones cambiantes en la red y otorgar a los nodos la posibilidad de influir en el proceso, lo sitÃºa como un pilar esencial en la arquitectura dinÃ¡mica de Polkadot y en la evoluciÃ³n continua de las cadenas de bloques hacia un futuro prometedor.</p>
</li>
</ul>
<h2 id="substrate"><a class="header" href="#substrate">Substrate</a></h2>
<p>Las cadenas Substrate presentan tres caracterÃ­sticas distintivas que las califican como &quot;de prÃ³xima generaciÃ³n&quot;:</p>
<ul>
<li>Una funciÃ³n de transiciÃ³n de estado dinÃ¡mica y autodefinida.</li>
<li>Funcionalidad de cliente ligero desde el primer dÃ­a.</li>
<li>Un algoritmo de consenso progresivo con una rÃ¡pida producciÃ³n de bloques y una finalidad adaptativa y definida.</li>
</ul>
<p>La funciÃ³n de transiciÃ³n de estado (STF), codificada en WebAssembly, se conoce como el &quot;tiempo de ejecuciÃ³n&quot; (runtime). Esta define la funciÃ³n <code>execute_block</code>, y puede especificar desde el algoritmo de staking, la semÃ¡ntica de transacciones, los mecanismos de registro y los procedimientos para reemplazar cualquier aspecto de sÃ­ misma o del estado de la cadena (gobernanza). Debido a la total dinamicidad del tiempo de ejecuciÃ³n, todos estos elementos pueden cambiarse o actualizarse en cualquier momento. En esencia, una cadena Substrate es comparable a un &quot;organismo vivo&quot;.</p>
<p>Para obtener mÃ¡s informaciÃ³n sobre Substrate, puedes <a href="https://www.parity.io/what-is-substrate/">consultar este enlace.</a>.</p>
<h3 id="explorando-las-posibilidades-de-substrate"><a class="header" href="#explorando-las-posibilidades-de-substrate">Explorando las Posibilidades de Substrate</a></h3>
<p>Substrate estÃ¡ diseÃ±ado para ser utilizado de tres maneras diferentes:</p>
<ol>
<li>
<p><strong>Sencilla:</strong> Se ejecuta el binario Substrate y se configura con un bloque gÃ©nesis que incluye el tiempo de ejecuciÃ³n de demostraciÃ³n actual. En este caso, simplemente construyes Substrate, configuras un archivo JSON y lanzas tu propia cadena de bloques. Esto te brinda un nivel mÃ­nimo de personalizaciÃ³n, permitiÃ©ndote principalmente cambiar los parÃ¡metros gÃ©nesis de los diversos mÃ³dulos de tiempo de ejecuciÃ³n, como balances, staking, perÃ­odo de bloque, tarifas y gobernanza.</p>
</li>
<li>
<p><strong>Modular:</strong> Se ensamblan paquetes (pallets) con Substrate FRAME para crear un nuevo tiempo de ejecuciÃ³n, posiblemente alterando o reconfigurando la lÃ³gica de generaciÃ³n de bloques del cliente Substrate. Esto te otorga una gran cantidad de libertad sobre la lÃ³gica de tu cadena de bloques, permitiÃ©ndote cambiar los tipos de datos, aÃ±adir o quitar mÃ³dulos y, crucialmente, agregar tus propios mÃ³dulos. Gran parte puede modificarse sin afectar la lÃ³gica de generaciÃ³n de bloques (pues es genÃ©rica). En este caso, el binario Substrate existente puede usarse para la generaciÃ³n de bloques y sincronizaciÃ³n. Si es necesario ajustar la lÃ³gica de generaciÃ³n de bloques, serÃ¡ necesario construir un nuevo binario de generaciÃ³n de bloques modificado como proyecto independiente y utilizarlo para los validadores. Este enfoque se utiliza para la cadena de relÃ©s de Polkadot y deberÃ­a ser adecuado para la mayorÃ­a de las circunstancias a corto y mediano plazo.</p>
</li>
<li>
<p><strong>GenÃ©rico:</strong> Es posible ignorar completamente FRAME y diseÃ±ar e implementar el tiempo de ejecuciÃ³n desde cero. Si se desea, esto puede hacerse en un lenguaje distinto de Rust, siempre y cuando pueda apuntar a WebAssembly. Si el tiempo de ejecuciÃ³n es compatible con la lÃ³gica de generaciÃ³n de bloques del cliente existente, simplemente puedes construir un nuevo bloque gÃ©nesis a partir de tu fragmento de WebAssembly (Wasm) y lanzar tu cadena con el cliente Substrate existente basado en Rust. Si no es asÃ­, serÃ¡ necesario ajustar la lÃ³gica de generaciÃ³n de bloques del cliente segÃºn corresponda. Esta opciÃ³n es probablemente la menos utilizada por la mayorÃ­a de los proyectos, pero ofrece una flexibilidad completa que permite un camino de actualizaciÃ³n a largo plazo y de amplio alcance para el paradigma Substrate.</p>
</li>
</ol>
<p>Sin embargo, es importante destacar que Substrate tambiÃ©n establece normas y convenciones, especialmente en relaciÃ³n con la Biblioteca de MÃ³dulos de Runtime. En tÃ©rminos generales, estos tipos de datos fundamentales se corresponden con interfaces (&quot;traits&quot;) en lo que respecta al estÃ¡ndar no negociable y estructuras genÃ©ricas (&quot;structs&quot;) en lo que respecta a la convenciÃ³n.</p>
<ul>
<li><strong>Encabezado:</strong> = Padre + ExtrinsicsRoot + StorageRoot + Digest</li>
<li><strong>Bloque:</strong> = Encabezado + Extrinsics + Justificaciones</li>
</ul>
<p>Con este conocimiento en mente, podemos sumergirnos en las complejidades de Madara y comprender mejor cÃ³mo Substrate proporciona una base sÃ³lida para su construcciÃ³n.</p>
<h2 id="execution"><a class="header" href="#execution">Execution</a></h2>
<p>En la base de esta fascinante estructura se encuentra la capa de EjecuciÃ³n (Execution). AquÃ­, la ejecuciÃ³n de los bloques y la evoluciÃ³n del state distaf toman forma. Lo impresionante de Madara es su habilidad para transitar sin esfuerzo entre dos enfoques de ejecuciÃ³n: [Blockifier] de Starkware y [starknet_in_rust] de LambdaClass. Esta flexibilidad promete optimizaciones en constante evoluciÃ³n, con la posibilidad de consolidar en un Ãºnico enfoque a medida que el tiempo avance.</p>
<h2 id="settlement-eficiente"><a class="header" href="#settlement-eficiente">Settlement Eficiente</a></h2>
<p>En la dinÃ¡mica de un Validity Rollup, podemos usar la arquitectura de Madara se despliega magistralmente desde su estrato de Settlement. En esta genialidad tÃ©cnica, Madara no impone restricciones sobre las opciones disponibles para esta capa. </p>
<p>Para ilustrarlo con un ejemplo concreto, consideremos un escenario de nivel L3. </p>
<blockquote>
<p>Madara tiene la capacidad de orquestar la transmisiÃ³n de pruebas periÃ³dicas hacia Starknet, especÃ­ficamente para un conjunto de bloques L3. El intervalo de aproximadamente ~ 5 horas para la liquidaciÃ³n en Starknet, un parÃ¡metro influenciado por los costos asociados con la liquidaciÃ³n en Ethereum, adquiere un matiz de eficiencia extraordinaria. En contraposiciÃ³n, en una configuraciÃ³n L3, se abre la posibilidad de establecer la liquidaciÃ³n en Starknet en intervalos aÃºn mÃ¡s frecuentes, lo cual conlleva una disminuciÃ³n significativa en los costos operativos.</p>
</blockquote>
<p>Madara es el arquitecto de la cadena que permite erigir la totalidad de su estructura a partir de su capa de asentamiento. Se distingue por su enfoque agnÃ³stico respecto a las capas de asentamiento, ofreciendo asÃ­ un lienzo en blanco para las decisiones de diseÃ±o. Asimismo, dentro de este ecosistema, Madara proporciona el marco para establecer tanto la finalidad Hard como la Soft, una dualidad contextual que aporta versatilidad y adaptabilidad a la plataforma.</p>
<h2 id="sequencing-adaptativa"><a class="header" href="#sequencing-adaptativa">Sequencing Adaptativa</a></h2>
<p>La SecuenciaciÃ³n (Sequencing), vital en el funcionamiento de Madara, es moldeable segÃºn las necesidades. Las posibilidades son infinitas: desde esquemas sencillos First-Come-First-Served (FCFS) hasta enfoques mÃ¡s sofisticados como Narwhall &amp; Bullshark o el intrigante HotStuff.</p>
<ul>
<li><strong>HotStuff:</strong> Basado en el protocolo de consenso PBFT (Practical Byzantine Fault Tolerance), HotStuff es una evoluciÃ³n de PBFT diseÃ±ada para optimizar el rendimiento y la latencia. Introduce el &quot;consensus certificate&quot; y utiliza una estructura de Ã¡rbol llamada &quot;fair chain&quot; para agilizar el proceso de consenso. Este enfoque permite lograr consenso con menor latencia y nÃºmero reducido de mensajes.</li>
</ul>
<p>En el contexto de la secuenciaciÃ³n, el orden de las transacciones desempeÃ±a un papel crucial para proteger contra ataques MEV y asegurar una distribuciÃ³n equitativa. Las aplicaciones especÃ­ficas pueden incluso implementar estrategias como memorias encriptadas para garantizar un orden equitativo.</p>
<h2 id="fundamentos-de-disponibilidad-de-datos"><a class="header" href="#fundamentos-de-disponibilidad-de-datos">Fundamentos de Disponibilidad de Datos</a></h2>
<p>En Madara, se estÃ¡n explorando diversos esquemas de DA para garantizar la integridad y accesibilidad de la informaciÃ³n.</p>
<ul>
<li><strong>Validium:</strong> Este enfoque implica datos con disponibilidad off-chain, administrados por un ComitÃ© conocido como Data Availability Committee (DAC). Este comitÃ© se encarga de asegurar que los datos estÃ©n disponibles y se mantengan fuera de la cadena principal.</li>
<li><strong>Rollup:</strong> AquÃ­, los datos tienen disponibilidad on-chain, siguiendo una dinÃ¡mica similar a lo que estamos familiarizados con los Validity Rollup. En este caso, se almacena la diferencia de estado (state delta) en la cadena Ethereum.</li>
<li><strong>Volition:</strong> Ofrece una alternativa personalizada y hÃ­brida, permitiendo a los usuarios decidir quÃ© datos desean guardar en la capa L1 de Ethereum y cuÃ¡les mantener off-chain, esto empodera a los desarrolladores para seleccionar el nivel de disponibilidad de datos mÃ¡s adecuado para sus aplicaciones, ya sea en la L1 de Ethereum para una seguridad sÃ³lida o en la L2 de Starknet para reducciÃ³n de costos. Adicionalmente, Volition brinda la opciÃ³n de autohospedar sus propios datos o alojarlos en otros esquemas de gestiÃ³n de datos, como <strong>Celestia</strong> o <strong>Eigen DA.</strong></li>
</ul>
<p>Estos enfoques en la disponibilidad de datos no solo demuestran la versatilidad y capacidad de adaptaciÃ³n de Madara, sino que tambiÃ©n allanan el camino hacia soluciones mÃ¡s eficientes y escalables dentro del ecosistema de Starknet y otros entornos. En estos contextos, Madara puede ser empleada como punto de entrada para capitalizar la potencia de Cairo y los STARKs, brindando nuevas oportunidades para impulsar la innovaciÃ³n y el crecimiento tecnolÃ³gico.</p>
<h2 id="diseÃ±o-de-gobernanza-robusta-en-madara-y-starknet"><a class="header" href="#diseÃ±o-de-gobernanza-robusta-en-madara-y-starknet">DiseÃ±o de Gobernanza Robusta en Madara y Starknet</a></h2>
<p>En el contexto de Starknet y Madara, se estÃ¡ llevando a cabo un proceso de descentralizaciÃ³n tanto en la infraestructura de red como en la toma de decisiones del protocolo. Esta iniciativa tiene como objetivo primordial fortalecer la participaciÃ³n y el empoderamiento de la comunidad en el desarrollo y las decisiones clave.</p>
<p>Uno de los elementos esenciales de Madara es Snapshot X, que establece un sistema completamente en cadena basado en sÃ³lidas pruebas de almacenamiento. Esta estrategia de gobernanza ha demostrado su efectividad en diversas situaciones, incluyendo casos como el de Turbo VM. Las pruebas de almacenamiento se presentan como el principal mecanismo de conexiÃ³n en el ecosistema de Madara, garantizando la integridad de las resoluciones tomadas por la comunidad.</p>
<p>AdemÃ¡s, Madara se encuentra en proceso de exploraciÃ³n de alternativas, tales como el mÃ³dulo de gobernanza nativa de Substrate. Aprendiendo de lecciones valiosas provenientes de plataformas exitosas, Madara reconoce la trascendencia de mantener una gobernanza en cadena, en lÃ­nea con la filosofÃ­a observada en ecosistemas como Cosmos y Polkadot.</p>
<p>En busca de una gobernanza mÃ¡s inclusiva y efectiva, Madara considera la adopciÃ³n de herramientas avanzadas como <a href="https://wiki.polkadot.network/docs/learn-polkadot-opengov">OpenGov</a> y <a href="https://docs.rs/pallet-democracy/latest/pallet_democracy/">Pallet Democracy</a>. Estas herramientas permiten una toma de decisiones participativa y adaptable a travÃ©s de la delegaciÃ³n y la participaciÃ³n directa de la comunidad.</p>
<ul>
<li>
<p><strong>OpenGov:</strong> Dentro del ecosistema de Polkadot, OpenGov promueve la inclusiÃ³n al permitir que cualquier miembro de la comunidad proponga y vote en referendos. Basado en 15 Trayectorias Ãºnicas, cada una con reglas predefinidas, OpenGov permite que las propuestas sean evaluadas y votadas por expertos en Ã¡reas especÃ­ficas. Esto asegura que incluso aquellos menos familiarizados con los aspectos tÃ©cnicos puedan influir en las decisiones clave.</p>
</li>
<li>
<p><strong>Pallet Democracy:</strong> Este paquete se encarga de la administraciÃ³n de las votaciones generales de los stakeholders. A travÃ©s de un proceso en dos colas, las propuestas son transformadas en referendos. Cualquier titular de tokens puede votar, utilizando un sistema de bloqueo temporal para expresar su convicciÃ³n en las decisiones. La flexibilidad y la adaptabilidad son elementos clave de este enfoque.</p>
</li>
</ul>
<p>Esta convergencia entre Madara y Starknet resalta la vital importancia de la descentralizaciÃ³n y la gobernanza activa en la evoluciÃ³n de estos ecosistemas. La prometedora trayectoria de ambas plataformas se moldea a travÃ©s de la colaboraciÃ³n y la participaciÃ³n comunitaria en la toma de decisiones.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="madara---fusionando-fuerzas-"><a class="header" href="#madara---fusionando-fuerzas-">Madara - Fusionando Fuerzas ğŸš§</a></h1>
<p>En esta secciÃ³n, exploraremos la poderosa alianza entre Madara y Kakarot, culminando en la creaciÃ³n de L3 zkEVMs en la red de Starknet. Este hito marca un paso crucial hacia un futuro de escalabilidad y modularidad en el Ã¡mbito de las cadenas de bloques, abriendo la puerta a un panorama en constante evoluciÃ³n. AquÃ­, los equipos pueden implementar cadenas de aplicaciones (dApp Chains) zkEVM y aprovechar las Pruebas de Validez para garantizar transacciones seguras en Starknet.</p>
<p>La asociaciÃ³n entre Kakarot y Madara cobra vida como una sinergia cautivadora, a pesar de ser componentes completamente distintos. Pero, Â¿cÃ³mo se entrelazan estos elementos en un tejido coherente que impulsa el futuro de la tecnologÃ­a blockchain? La respuesta reside en la capacidad de integrar Kakarot con Madara, lo que nos brinda un abanico de oportunidades diversas.</p>
<p>Imagina a Madara como el sÃ³lido cimiento, un sustrato fundamental que establece las bases para futuras dApp Chains, secuenciadores descentralizados y una variedad de opciones en diferentes capas. Detallamos la gestiÃ³n en la capa de DA en el capÃ­tulo anterior, que puedes revisar en <a href="/Book-Starkware/src/Madara.html#fundamentos-de-data-availability">Madara - Fundamentos de DA</a>.</p>
<p>Estas bases, que pueden optimizarse desde el componente de Madara gracias a Substrate y los Pallets, logran mejorar las caracterÃ­sticas de escalabilidad, modularidad y seguridad, formando asÃ­ una plataforma sÃ³lida y lista para recibir nuevas capas de innovaciÃ³n.</p>
<p>Por otro lado, Kakarot asume el papel de un manto creativo, siendo la zkEVM en Starkent capaz de interpretar el lenguaje de Solidity y ejecutarlo en Cairo. Ambas capas o componentes estÃ¡n protegidos por Validity Proof, donde en este caso, los STARKs aseguran la integridad de los datos, mientras que otros elementos potencian la descentralizaciÃ³n y la eficiencia.</p>
<p>Esta simbiosis entre Madara y Kakarot establece los cimientos para un futuro emocionante y dinÃ¡mico en el universo de las cadenas de bloques, allanando el camino hacia una mayor adopciÃ³n y evoluciÃ³n tecnolÃ³gica.</p>
<h2 id="la-fusiÃ³n-de-madara-y-kakarot"><a class="header" href="#la-fusiÃ³n-de-madara-y-kakarot">La FusiÃ³n de Madara y Kakarot</a></h2>
<p>La fusiÃ³n de ambos componentes da lugar a una L3 zkEVM. El impacto de L3 zkEVM trasciende la mera innovaciÃ³n tecnolÃ³gica. Su importancia radica en la descentralizaciÃ³n y la seguridad que brinda. Al lograr altos niveles de seguridad sin depender de una multitud de validadores, se establece una nueva norma en la industria. La descentralizaciÃ³n se convierte en una poderosa arma contra la censura y la vulnerabilidad, elementos fundamentales a menudo pasados por alto en la bÃºsqueda de soluciones de cadena de bloques.</p>
<p>El viaje apenas comienza con L3 zkEVM. La armonÃ­a entre Madara y Kakarot allana el camino para futuras evoluciones, incluyendo L4, L5 y mÃ¡s allÃ¡. La modularidad de Substrate otorga a Kakarot la libertad de innovar en protocolos de consenso, mientras que las actualizaciones de tiempo de ejecuciÃ³n sin bifurcaciones en Substrate permiten una adaptaciÃ³n fluida del EVM.</p>
<p>La colaboraciÃ³n entre Madara y Kakarot tambiÃ©n da lugar a posibilidades avanzadas, como la creaciÃ³n de zkEVM tipo 1. Mediante la incorporaciÃ³n de las reglas de consenso de Ethereum en Cairo dentro del nodo completo Madara x Kakarot y el cambio a Keccak MPT, Kakarot puede convertirse en un cliente zkEVM tipo 1 capaz de probar bloques L1. Aunque este es un caso de uso mÃ¡s avanzado que depende de la hoja de ruta de Ethereum, muestra cÃ³mo la innovaciÃ³n puede seguir floreciendo.</p>
<h3 id="optimizando-la-eficiencia-con-l3-zkevm"><a class="header" href="#optimizando-la-eficiencia-con-l3-zkevm">Optimizando la Eficiencia con L3 zkEVM</a></h3>
<p>Un aspecto subestimado pero crucial de L3 zkEVM es su capacidad para desacoplar seguridad y descentralizaciÃ³n. Aprovechando el enfoque de Prueba de Validez de Kakarot, los usuarios pueden disfrutar de niveles de seguridad comparables a Ethereum L1 sin requerir la misma cantidad de validadores. La descentralizaciÃ³n, con su resistencia y capacidad anti-censura, sigue siendo esencial, y se logra a travÃ©s de un secuenciador establecido en cientos en lugar de miles.</p>
<p>La eficiencia se multiplica aÃºn mÃ¡s gracias a la computaciÃ³n en capas, lo que resulta en costos de gas exponencialmente mÃ¡s bajos que en L2 y un mayor rendimiento (TPS). Esta escalabilidad acumulativa allana el camino para una escalada mÃ¡s allÃ¡ de L3, abriendo la puerta a futuras evoluciones.</p>
<p>Para reducir aÃºn mÃ¡s los costos de gas y mejorar la disponibilidad de datos, se plantea la separaciÃ³n de verificaciÃ³n de pruebas y DA. Mientras que Starknet L2 puede servir como una capa de verificaciÃ³n de prueba segura, soluciones innovadoras como Celestia o EigenDA pueden utilizarse para publicar datos de transacciones de manera rentable.</p>
<h2 id="explorando-horizontes-de-investigaciÃ³n"><a class="header" href="#explorando-horizontes-de-investigaciÃ³n">Explorando Horizontes de InvestigaciÃ³n</a></h2>
<p>Madara se destaca como un faro de innovaciÃ³n en el vasto ocÃ©ano de la tecnologÃ­a blockchain. Sus capas y componentes se entrelazan en una sinfonÃ­a de eficiencia, seguridad y escalabilidad. Esta colaboraciÃ³n con Kakarot da forma a un futuro vibrante, donde los zkEVMs florecen y la cadena de bloques alcanza nuevas alturas. A medida que Madara continÃºa su evoluciÃ³n, anticipamos con entusiasmo las hazaÃ±as que el futuro tiene reservadas para esta extraordinaria creaciÃ³n.</p>
<p>El viaje en la arquitectura Madara no se detiene aquÃ­, se estÃ¡n explorando temas intrigantes, como la comunicaciÃ³n de cross-rollups aprovechando el protocolo de mensajerÃ­a de Substrate. La uniÃ³n de Madara y Kakarot representa una sinergia poderosa, sentando las bases para una evoluciÃ³n constante en el ecosistema blockchain. Cada avance y cada innovaciÃ³n en esta colaboraciÃ³n allana el camino para un futuro donde la seguridad, la descentralizaciÃ³n y la escalabilidad convergen en un todo armonioso.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sharingan"><a class="header" href="#sharingan">Sharingan</a></h1>
<p>En este capÃ­tulo hablaremos como Sharingan representa una innovadora y transitoria testnet al servicio de Starknet, donde la totalidad de las entidades nodales que conforman la infraestructura son encarnaciones virtuales de Madara. En este entorno de pruebas, la funcionalidad de Starknet es sometida a rigurosas pruebas de campo en un paradigma descentralizado, en el cual los nodos colaboran armoniosamente para determinar la continuaciÃ³n de la cadena mediante un proceso de consenso. La arquitectura subyacente de Sharingan se apoya en la utilizaciÃ³n de lo que denominamos <strong>secuenciadores</strong>, elementos cruciales responsables de la producciÃ³n, validaciÃ³n y anexiÃ³n de bloques en la cadena de bloques.</p>
<p>No obstante, es importante destacar que algunos nodos dentro de este ecosistema tienen un rol especÃ­fico en el almacenamiento y retenciÃ³n de datos, sin involucrarse activamente en las decisiones de consenso.</p>
<p>Si bien Madara se refiere comÃºnmente como el <strong>Secuenciador</strong> en el contexto de Starknet, es relevante establecer una distinciÃ³n intrÃ­nseca en Sharingan entre dos categorÃ­as de nodos:</p>
<ol>
<li><strong>Madara en calidad de Secuenciador</strong>: PartÃ­cipe activo en el proceso de consenso y toma de decisiones.</li>
<li><strong>Madara en calidad de Fullnode</strong>: Contribuyente a la persistencia y almacenamiento de datos en la red.</li>
</ol>
<p>El propÃ³sito fundamental que subyace a Sharingan consiste en inaugurar un capÃ­tulo de pruebas descentralizadas para Starknet y, simultÃ¡neamente, proporcionar un acceso inclusivo y participativo a todos los actores interesados en experimentar con la red Starknet.</p>
<p>Para facilitar la interacciÃ³n con la red Starknet, los nodos Starknet ofrecen una interfaz de programaciÃ³n de aplicaciones (API) en formato JSON RPC. Como consecuencia, cada instancia de Madara que contribuye al entorno de Sharingan posee un puerto expuesto, diseÃ±ado para admitir la comunicaciÃ³n externa.</p>
<p>Se distinguen un total de seis secuenciadores reconocidos dentro del contexto de Sharingan, aunque siempre revise documentaciÃ³n ofical para estar actualizados:</p>
<div class="table-wrapper"><table><thead><tr><th>Mantenedor</th><th>ID</th><th>Alias de clave</th><th>IP</th><th>ID de par</th><th>Puerto RPC</th></tr></thead><tbody>
<tr><td>Starkware</td><td>1</td><td>alice</td><td><code>52.7.206.208</code></td><td><code>12D3KooWJytWW4wqhG1xp9ckLb7B15KqDU24Q8HHo8VfwXmFe5ZE</code></td><td><code>9933</code></td></tr>
<tr><td>Starkware</td><td>2</td><td>bob</td><td><code>44.195.161.82</code></td><td><code>12D3KooWHocNfvLz6rgpb8wJsynSpMwkspkcRn6gmN5UiK1tTTeG</code></td><td><code>9933</code></td></tr>
<tr><td>Cartridge</td><td>3</td><td>charlie</td><td><code>208.67.222.222</code></td><td><code>12D3KooWQe2ZtqiyC5CLJKZr9i9xTmEyiAikZcr5J18w3cG1dQAc</code></td><td><code>9933</code></td></tr>
<tr><td>LambdaClass</td><td>4</td><td>dave</td><td><code>65.109.91.29</code></td><td><code>12D3KooWK8QhFjkGYGyMskDuCyaS1nrhfTfadMeRjJkox4SV32co</code></td><td><code>9933</code></td></tr>
<tr><td>Pragma</td><td>5</td><td>eve</td><td><code>13.39.22.82</code></td><td><code>12D3KooWGMCGJ517tFor12U9n2v3ax5WNw1pXFdj48hSHYQe6oyJ</code></td><td><code>9933</code></td></tr>
<tr><td>Kakarot</td><td>6</td><td>ferdie</td><td><code>52.50.242.182</code></td><td><code>12D3KooWHnQ8LC113DgB5cVVyx2mvTN7bBkm75zvzsndr2WhstEE</code></td><td><code>9933</code></td></tr>
</tbody></table>
</div>
<p>Este selecto grupo de secuenciadores desempeÃ±a un papel crucial en la gobernanza y operaciÃ³n de Sharingan, aportando una diversidad de perspectivas y recursos para enriquecer el desarrollo y evoluciÃ³n de Starknet en su trayectoria hacia la descentralizaciÃ³n.</p>
<h2 id="explorando-los-recursos-de-sharingan"><a class="header" href="#explorando-los-recursos-de-sharingan">Explorando los Recursos de Sharingan</a></h2>
<p>A continuaciÃ³n, proporcionamos un enlace hacia una <a href="https://github.com/Nadai2010/Nadai-StarknetEs-Sharingan/blob/master/Gu%C3%ADa-StarknetEs.md">guÃ­a exhaustiva en espaÃ±ol</a> que le brindarÃ¡ una orientaciÃ³n detallada sobre su utilizaciÃ³n.</p>
<p>Dentro del marco de esta guÃ­a, examinaremos una porciÃ³n selecta para ilustrar el funcionamiento. Una vez que hayamos establecido una configuraciÃ³n precisa, nos aventuraremos a conectarnos a la interfaz RPC mediante un comando, es importante seÃ±alar que tenemos la capacidad de configurar cualquiera de los seis operadores previamente mencionados, siempre y cuando estÃ©n operativos.</p>
<p>Realicemos una demostraciÃ³n prÃ¡ctica al invocar el mÃ©todo <code>starknet_blockHashAndNumber</code> a travÃ©s del operador de Starkware, con el propÃ³sito de obtener informaciÃ³n crucial acerca de un bloque en la red.</p>
<pre><code class="language-bash">curl --header &quot;Content-Type: application/json&quot; \
  --request POST \
  --data '{
   &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;starknet_blockHashAndNumber&quot;,
    &quot;params&quot;: [],
    &quot;id&quot;:1
}' http://52.7.206.208:9933
</code></pre>
<p>La respuesta obtenida deberÃ¡ proporcionar el hash del bloque mÃ¡s reciente, junto con su nÃºmero de bloque e identificador:</p>
<p><img src="./assets/Sharingan.png" alt="graph" /></p>
<div align="center">
</div>
<p>Avanzando, exploramos otro ejemplo, en este caso, empleamos <code>starknet_getBlockWithTxHashes</code> para obtener el bloque mÃ¡s reciente, acompaÃ±ado por su hash relacionado, el estado actual de la transacciÃ³n, el timestamp (sello de tiempo) y la direcciÃ³n del secuenciador.</p>
<pre><code class="language-bash">curl --header &quot;Content-Type: application/json&quot; \
  --request POST \
  --data '{
   &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;starknet_getBlockWithTxHashes&quot;,
    &quot;params&quot;: [
        &quot;latest&quot;
    ],
    &quot;id&quot;:1
}' http://52.7.206.208:9933
</code></pre>
<p>La respuesta a esta consulta deberÃ¡ seguir la estrucutra de salida de la siguiente imagen:</p>
<p><img src="./assets/Sharingan2.png" alt="graph" /></p>
<div align="center">
</div>
<p>En Ãºltima instancia, proporcionamos el enlace directo al documento hospedado en el repositorio oficial. Este recurso le permitirÃ¡ mantenerse al tanto de las actualizaciones mÃ¡s recientes y acceder al <a href="https://github.com/keep-starknet-strange/madara/blob/main/docs/sharingan-starter-pack.md">Sharingan Starter Pack</a> para examinar los <strong>Comandos y Recomendaciones actualizadas</strong>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="otros-secuenciadores-"><a class="header" href="#otros-secuenciadores-">Otros Secuenciadores ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="katana-"><a class="header" href="#katana-">Katana ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="radius-"><a class="header" href="#radius-">Radius ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="otros-prover-"><a class="header" href="#otros-prover-">Otros Prover ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sandstorm-"><a class="header" href="#sandstorm-">Sandstorm ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kakarot-"><a class="header" href="#kakarot-">Kakarot ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dojo-"><a class="header" href="#dojo-">Dojo: ğŸš§</a></h1>
<p>Este capÃ­tulo nos sumerge en el intrigante universo del motor Dojo y su capacidad para revolucionar los juegos demostrables. Desglosaremos los conceptos emergentes de mundos autÃ³nomos y juegos probables a travÃ©s de una secciÃ³n especial dedicada a la TeorÃ­a. Dojo, impulsado por colaboradores destacados como Cartridge, Realms &amp; BibliothecaDAO, briq y muchos otros, es una iniciativa de cÃ³digo abierto con licencia MIT.</p>
<h2 id="un-motor-para-crear-mundos-autÃ³nomos"><a class="header" href="#un-motor-para-crear-mundos-autÃ³nomos">Un Motor para Crear Mundos AutÃ³nomos</a></h2>
<p>Dojo es una herramienta poderosa que trasciende los lÃ­mites de un motor de juegos convencional. Su diseÃ±o estÃ¡ enfocado en la creaciÃ³n de juegos y mundos autÃ³nomos en la cadena de bloques utilizando la versatilidad de Cairo. Incorpora un sistema innovador de componentes de entidades y adopta el patrÃ³n diamante, lo que facilita la construcciÃ³n de entornos modulares y escalables. La esencia de Dojo radica en la incorporaciÃ³n de Componentes (estado) y Sistemas (lÃ³gica) que dan vida a estos mundos digitales. Su arquitectura se inspira en la brillantez del motor Bevy.</p>
<h2 id="caracterÃ­sticas-clave-y-futuro-prometedor"><a class="header" href="#caracterÃ­sticas-clave-y-futuro-prometedor">CaracterÃ­sticas Clave y Futuro Prometedor</a></h2>
<p>Dojo destaca por su Sistema de Componentes de Entidades (ECS) basado en Cairo 1.0, asÃ­ como por elementos clave como Sozo, Torii y Katana que impulsan la red y la indexaciÃ³n. AdemÃ¡s, Dojo ofrece SDKs tipados para un desarrollo eficiente. Este proyecto de cÃ³digo abierto se encuentra en sus fases iniciales de desarrollo y acoge con entusiasmo a colaboradores de todos los niveles. Dojo se erige como una respuesta a las lecciones aprendidas en la bÃºsqueda de construir juegos en cadena, aligerando la carga de la infraestructura compleja y permitiendo a los desarrolladores centrarse en la esencia de sus creaciones. Los juegos demostrables demandan propiedades de conocimiento cero (ZK) para su escalabilidad y verificaciÃ³n de cÃ¡lculos eficiente. Cairo, un lenguaje versÃ¡til, es la piedra angular que facilita este proceso, eliminando la complejidad de crear circuitos para integrar SNARKs. AsÃ­, programar en Cairo se traduce en aplicaciones automÃ¡ticamente demostrables. AdemÃ¡s, Dojo ofrece una versatilidad excepcional en cuanto a implementaciÃ³n. Puedes llevar tus programas a la MÃ¡quina Virtual Cairo (CVM), que es compatible con la Capa 2 de Starknet y las appchains de Starknet. Incluso puedes llevar tus creaciones al navegador a travÃ©s de WebAssembly (WASM). Dojo estÃ¡ diseÃ±ado para impulsar el desarrollo de juegos en mÃºltiples contextos, aportando primitivas de conocimiento cero (ZK). A medida que el proyecto avanza, su objetivo es empoderar a los desarrolladores, acortando drÃ¡sticamente el tiempo necesario para crear juegos en cadena y Mundos AutÃ³nomos (AWs), convirtiendo semanas de trabajo en un proceso eficiente de horas. AcompÃ¡Ã±anos en esta emocionante travesÃ­a hacia el futuro del entretenimiento digital con Dojo. Â¡El horizonte de los juegos demostrables y mundos autÃ³nomos espera ser explorado! ğŸŒŸ</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="giza-"><a class="header" href="#giza-">Giza ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orion-"><a class="header" href="#orion-">Orion ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cartridge-"><a class="header" href="#cartridge-">Cartridge ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vistara-"><a class="header" href="#vistara-">Vistara ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="servicios-api-"><a class="header" href="#servicios-api-">Servicios API ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="infura"><a class="header" href="#infura">Infura</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alchemy"><a class="header" href="#alchemy">Alchemy</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexer"><a class="header" href="#indexer">Indexer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checkpoint-"><a class="header" href="#checkpoint-">Checkpoint ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apibara-"><a class="header" href="#apibara-">Apibara ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokenflow-"><a class="header" href="#tokenflow-">TokenFlow ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="torii-"><a class="header" href="#torii-">Torii ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dapp---ecosistema-"><a class="header" href="#dapp---ecosistema-">Dapp - Ecosistema ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="avnu"><a class="header" href="#avnu">Avnu</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursos"><a class="header" href="#recursos">Recursos</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cairo-by-example"><a class="header" href="#cairo-by-example">Cairo by Example</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="challengues"><a class="header" href="#challengues">Challengues</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cairo-book"><a class="header" href="#cairo-book">Cairo book</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-book"><a class="header" href="#starknet-book">Starknet book</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starkli-"><a class="header" href="#starkli-">Starkli ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scarb-"><a class="header" href="#scarb-">Scarb ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oz---wizard-"><a class="header" href="#oz---wizard-">OZ - Wizard ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="remix---starknet-"><a class="header" href="#remix---starknet-">Remix - Starknet ğŸš§</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknetjs-"><a class="header" href="#starknetjs-">Starknet.js ğŸš§</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
